# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Lidarcombustibles
                                 A QGIS plugin
Permite procesar datos LiDAR de una manera sencilla para obtener modelo de combustibles
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-01-29
        git sha              : $Format:%H$
        copyright            : (C) 2019 by javier diez
        email                : dierabfr@jcyl.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
#from PyQt5.QtGui import QIcon
#from PyQt5.QtWidgets import QAction

from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .lidarcombustibles_dialog import LidarcombustiblesDialog
from .config_dialog import ConfigDialog
from .project_dialog import ProjectDialog
from .salida_dialog import SalidaDialog
import os.path

#import para procesar
from qgis.core import QgsProject, QgsRasterLayer, QgsVectorLayer,QgsFeatureRequest,QgsField,QgsExpression,QgsExpressionContext,QgsExpressionContextScope,QgsVectorFileWriter, QgsFillSymbol,QgsRendererCategory,QgsCategorizedSymbolRenderer,QgsExpressionContextUtils, QgsApplication
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
#from PyQt5.QtCore import QFileInfo
from qgis.PyQt.QtCore import QFileInfo
from qgis.analysis import QgsRasterCalculator, QgsRasterCalculatorEntry
import processing
import os
import glob
import re
import sys
#from qgis import *
import time
import webbrowser

class Salida:
    def __init__(self, iface):
        self.dlg4 = SalidaDialog()

class Project:
    def __init__(self, iface):
        self.dlg3 = ProjectDialog()

class Config:
    def __init__(self, iface):
        self.dlg2 = ConfigDialog()

class Lidarcombustibles:
    """QGIS Plugin Implementation."""
    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Lidarcombustibles_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        self.dlg = LidarcombustiblesDialog()
        self.dlg2 = ConfigDialog()
        self.dlg3 = ProjectDialog()
        self.dlg4 = SalidaDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Lidarcombustibles')
        
        self.toolbar = self.iface.addToolBar(u'Lidarcombustibles')             
        self.toolbar.setObjectName(u'Lidarcombustibles')            
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)
        self.dlg.help_button.clicked.connect(self.help_pressed)
        self.dlg.pushButton_parametros.clicked.connect(self.configurar_parametros)
        self.dlg.pushButton_proyectar.clicked.connect(self.proyectar_datos_lidar)
        self.dlg.pushButton_salida.clicked.connect(self.salida)
        self.dlg3.crecimiento.textChanged.connect(self.datosenlazados)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Lidarcombustibles', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """


        
        #cambio el icon path para mi equipo.
        usuario=QgsApplication.qgisSettingsDirPath()
        icon_path=os.path.join(usuario,r"python\plugins\lidarcombustibles\icon.png")
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)
            #self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/lidarcombustibles/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Lidarcombustibles'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        

    def select_laz_folder(self):
        """seleciono la carpeta con los datos de entrada"""

        #self.dlg.carpetalaz.clear()
        carpeta = QFileDialog.getExistingDirectory(self.dlg , "Selecciona carpeta")
        self.dlg.carpetalaz.setText(carpeta)
        print(carpeta)
        
    def help_pressed(self):
        print("abre la ayuda")
        help_file = 'file:' + os.path.dirname(__file__) + '/Ayuda_Silvilidar.pdf'
        webbrowser.open_new(help_file)
        
    def configurar_parametros(self):
        print("entro en configurar")
        self.dlg2.show()
    def proyectar_datos_lidar(self):
        print("entro en proyectar datos lidar")
        self.dlg3.show()
    def salida(self):
        print("entro en configurar salidas")
        self.dlg4.show()
    def datosenlazados(self):
        self.dlg3.crecimientofcc.setText(str(8*float(self.dlg3.crecimiento.text())))

 


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.iface.removePluginMenu(
                self.tr(u'&Lidarcombustibles'),
                action)





    

    


    def run(self):
        
        #defino la funcion que busca los archivos las o laz que existan y le paso los parametros resultantes del formulario
        def buscalidaryejecuta(carpeta, crecimiento, fccbaja, fccterrazas, fccmedia, fccalta, hmontebravoe, hmontebravo, hselvicolas, hclaras, hclaras2, hbcminima, hbcdesarrollado, rcclaras, rcextremo, longitudcopaminima, crecimientofcc):
            print("empieza busca y ejecuta")
            print (carpeta)
            for base, dirs, files in os.walk(carpeta):
                carpetas_y_subcarpetas=base
                archivos=files
                for archivo in archivos:
                    a=list(os.path.splitext(archivo))
                    extension=a[1].lower()
                    print (extension)
                    if extension==".laz" or extension==".las":
                        b=os.path.join(base,a[0]+a[1])
                        las = os.path.join(a[0]+a[1])
                        print (las)
                        print ("paso por busca y ejecuta lidar")
                        #ejecuto el exprimelidar
                        print (" llamo a exprime lidar")
                        exprimelidar(las, carpeta, crecimiento, fccbaja, fccterrazas, fccmedia, fccalta, hmontebravoe, hmontebravo, hselvicolas, hclaras, hclaras2, hbcminima, hbcdesarrollado, rcclaras, rcextremo, longitudcopaminima, crecimientofcc)
                        
        #defino la funcion que lo hace todo con un archivo las o laz concreto
        def exprimelidar(las, carpeta, crecimiento, fccbaja, fccterrazas, fccmedia, fccalta, hmontebravoe, hmontebravo, hselvicolas, hclaras, hclaras2, hbcminima, hbcdesarrollado, rcclaras, rcextremo, longitudcopaminima, crecimientofcc):
            fcstring = ""
            print("empieza exprime lidar")
            horaepiezaexprimelidar= time.time()
            print(horaepiezaexprimelidar)
            #defino un par de variables con el nombre del archivo y su abreviatura. Pensado para la denominacion estandar de los archivos LiDAR del PNOA
            tronco=las[:-4]
            patron = re.compile(('\d{3}\_\d{4}|\d{3}\-\d{4}|\d{4}\_\d{1}\-\d{1}'))
            troncoresumido=patron.findall(las)[0].replace("-","_")
            
            #definicion de parametros funciones y rutas
            funcion_groundfilter = "c:/fusion/groundfilter"
            funcion_surfacecreate = "c:/fusion/gridsurfacecreate"
            funcion_gridmetric = "c:/fusion/gridmetrics"
            funcion_cover="c:/fusion/cover"
            funcion_csv2grid = "c:/fusion/csv2grid"
            funcion_dtm2ascii = "c:/fusion/DTM2ASCII"
            funcion_lda2ascii = "c:/Fusion/LDA2ASCII"
            funcion_dtm2tif= "c:/Fusion/DTM2TIF"

            salida0 =  os.path.join(carpeta,a[0]+ ".las")
            salida00 =  os.path.join(carpeta,"filt"+a[0]+ ".las")
            salida1 = os.path.join(carpeta,"groundfilter_"+tronco+".lda")
            salida2 = os.path.join(carpeta,"groundfilter_"+tronco+".dtm")
            salida6 = os.path.join(carpeta,"groundfilter_"+tronco+".las")
            salida3 = os.path.join(carpeta,"metric.csv")
            salida4 = os.path.join(carpeta,tronco+"_height_grid.asc")
            salida5 = os.path.join(carpeta,tronco+"_cover_grid.asc")
            salida7 = os.path.join(carpeta,tronco+"_height.txt")
            salida8 = os.path.join(carpeta,tronco+"_height_grid_original.asc")
            salida100=os.path.join(carpeta,tronco+"_basecopa.asc")
            salida_coverfile1=os.path.join(carpeta,tronco+"_coverfile1.dtm")
            salida_coverfile2=os.path.join(carpeta,tronco+"_coverfile2.dtm")
            salida_coverfile3=os.path.join(carpeta,tronco+"_coverfile3.dtm")
            salida_coverfile4=os.path.join(carpeta,tronco+"_coverfile4.dtm")
            
            
            parametro_tamanocelda = 25
            parametros1_0 = "" #"/median:3 /wparam:2.5 /aparam:4 /bparam:4"
            parametros_surfacecreate= str(parametro_tamanocelda)+" M M 0 0 0 0"
            parametro_h_corte="0.3"
            parametros3_1 = "/minht:"+str(parametro_h_corte)+" /nointensity" 
            parametros3_2 = str(parametro_h_corte)+" "+str(parametro_tamanocelda)
            paramertos_limite_inferior_1=parametro_h_corte
            paramertos_limite_inferior_2=0.6
            paramertos_limite_inferior_3=2
            paramertos_limite_inferior_4=4
            parametros_cover1="/upper:0.6"
            parametros_cover2="/upper:2"
            parametros_cover3="/upper:4"
            parametros_cover4="/upper:30"
        
            parametros4 = 7
            parametros5 = 49
            parametros6 = "/raster"
            parametro7 = 2
            parametros101 = 999 #percentil del 10 por ciento
            parametros100 = 27 #percentil del 20 por ciento
            parametros102 = 999 #percentil del 15 por ciento
            parametros104 = 37 #percentil del 95 por ciendto
            
            entrada0 = os.path.join(carpeta,las)
            entrada1 = os.path.join(carpeta,las) 
            entrada2 = os.path.join(carpeta,"groundfilter_"+tronco+".las")
            entrada_groundfile = salida2
            entrada3_2 = entrada1
            entrada4 = os.path.join(carpeta,"metric_all_returns_elevation_stats_"+tronco+".csv")
            entrada6 = salida2
            print("voy a empezar el try")
            #try:  ## va con el except de antes de Run method that performs all the real work. Volverlo a poner en cuanto sea posible. Ahora falla en el stringtolayer por el qfile info.   ojojojojojoj
            #while True:   ojo ha cambiado en python3, lo quito
            print ("empiezo el while true")
            #paso1 groundfilter
            total1 = funcion_groundfilter+" "+parametros1_0+" "+salida1+" "+str(parametro_tamanocelda)+" "+ entrada1
            print (total1)
            os.system(total1)

            #paso2 grid del suelo
            total2 = funcion_surfacecreate+" "+salida2+" "+str(parametros_surfacecreate)+" "+ entrada2
            os.system(total2)

            #paso3 saca los parametros de ese grid
            total3 = funcion_gridmetric+" "+str(parametros3_1)+" "+entrada_groundfile+" "+str(parametros3_2)+" "+salida3+" "+ entrada3_2
            os.system(total3)
            os.rename(carpeta+"/metric_all_returns_elevation_stats.csv", carpeta+"/metric_all_returns_elevation_stats_"+tronco+".csv")
            os.rename(carpeta+"/metric_all_returns_elevation_stats_ascii_header.txt", carpeta+"/metric_all_returns_elevation_stats_"+tronco+"_ascii_header.txt")

            #saco los fcc en distintos estratos 1
            total_cover1 = funcion_cover+" "+str(parametros_cover1)+" "+entrada_groundfile+" "+salida_coverfile1+ " "+   str(paramertos_limite_inferior_1)+" " +str(parametro_tamanocelda)+  " m m 1 30 0 0 "          + entrada3_2
            print(total_cover1)
            os.system(total_cover1)
            #genera un tif del dtm de fcc entre 2 alturas determinadas 1
            total_covertif1 = funcion_dtm2ascii+" "+salida_coverfile1
            os.system(total_covertif1)
            
            #saco los fcc en distintos estratos 2
            total_cover2 = funcion_cover+" "+str(parametros_cover2)+" "+entrada_groundfile+" "+salida_coverfile2+ " "+   str(paramertos_limite_inferior_2)+" " +str(parametro_tamanocelda)+  " m m 1 30 0 0 "          + entrada3_2
            print(total_cover2)
            os.system(total_cover2)
            #genera un tif del dtm de fcc entre 2 alturas determinadas 2
            total_covertif2 = funcion_dtm2ascii+" "+salida_coverfile2
            os.system(total_covertif2)
            
            #saco los fcc en distintos estratos 3
            total_cover3 = funcion_cover+" "+str(parametros_cover3)+" "+entrada_groundfile+" "+salida_coverfile3+ " "+   str(paramertos_limite_inferior_3)+" " +str(parametro_tamanocelda)+  " m m 1 30 0 0 "          + entrada3_2
            print(total_cover3)
            os.system(total_cover3)
            #genera un tif del dtm de fcc entre 2 alturas determinadas 3
            total_covertif3 = funcion_dtm2ascii+" "+salida_coverfile3
            os.system(total_covertif3)
            #saco los fcc en distintos estratos 4
            total_cover4 = funcion_cover+" "+str(parametros_cover4)+" "+entrada_groundfile+" "+salida_coverfile4+ " "+   str(paramertos_limite_inferior_4)+" " +str(parametro_tamanocelda)+  " m m 1 30 0 0 "          + entrada3_2
            print(total_cover4)
            os.system(total_cover4)
            #genera un tif del dtm de fcc entre 2 alturas determinadas 4
            total_covertif4 = funcion_dtm2ascii+" "+salida_coverfile4
            os.system(total_covertif4)

            

            #paso4 genera un grid del csv anterior  de alturas
            total4 = funcion_csv2grid+" "+entrada4+" "+str(parametros104)+" "+ salida4
            os.system(total4)
          
            #paso100 percentil20
            total100 = funcion_csv2grid+" "+entrada4+" "+str(parametros100)+" "+ salida100
            os.system(total100)

            #paso5 genera un grid del csv anterior de fcc
            total5 = funcion_csv2grid+" "+entrada4+" "+str(parametros5)+" "+ salida5
            os.system(total5)
            
            #paso6 convierto en ascii 
            total6 = funcion_dtm2ascii+" "+str(parametros6)+" "+entrada6
            os.system(total6)
            
            #paso7  convierto en ascii
            total7 = funcion_lda2ascii+" "+entrada1+" "+salida7+" "+str(parametro7)
            os.system(total7)
                      
            #cargo  raster fcc
            fileName=salida5
            Layer= QgsRasterLayer(fileName,"fcc")
            QgsProject.instance().addMapLayers([Layer])
            if not Layer:
                print ("fallo carga de capa") 
            
            #creo lista vacia entries
            entries = []
             #funcion que carga una capa y prepara la banda para operar con ella
            def StringToRaster(raster,banda):
                fileInfo = QFileInfo(raster)
                path = fileInfo.filePath()
                baseName = fileInfo.baseName()
                global layerglobal
                layerglobal = QgsRasterLayer(path, baseName)
                QgsProject.instance().addMapLayer(layerglobal)
                if layerglobal.isValid() is True:
                    bandaref=str(banda)+'@1'
                    # Define band1
                    banda = QgsRasterCalculatorEntry()
                    banda.ref = bandaref
                    banda.raster = layerglobal
                    banda.bandNumber = 1
                    entries.append( banda )
                else:
                    print ("Unable to read basename and file path - Your string is probably invalid" +str(baseName))
                    
            #defino funcion para hacer calculo de capas raster        
            def calculo(expresion,capa):
                calc = QgsRasterCalculator(expresion, 
                                os.path.join(carpeta,troncoresumido+'_'+capa+'.tif'), 
                                'GTiff', 
                                layerglobal.extent(), 
                                layerglobal.width(), 
                                layerglobal.height(), 
                                entries )
                                 
                calc.processCalculation()
                del(calc)

            #defino funcion para crear una capa shape que generalice los datos de un raster    filtro es el nivel de generalizacion entre 0 y 1
            def agregado(rasterdeentrada,filtro):
                #try:
                    #filtro para rellenar huecos
                    print("empieza agregado")
                    horaepiezaagregado= time.time()
                    
                    input=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'1.tif')
                    output=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'1n.tif')
                    params={'INPUT':input,'DISTANCE': 100, 'BAND': 1,'ITERATIONS': 0,'NO_MASK': False,'OUTPUT':output}
                    processing.run('gdal:fillnodata', params)
                    #processing.run('gdal:fillnodata', input, distance, iterations, band,mask,no_default_mask, output)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'1n.tif'),rasterdeentrada+str("1n"))
                    
                    #filtro y me quedo con lo mayor de 0,99
                    calc = QgsRasterCalculator("'"+rasterdeentrada+'1n@1 > 0.9999999',
                                           os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'1nf.tif'),
                                           'GTiff',
                                    layerglobal.extent(), 
                                    layerglobal.width(), 
                                    layerglobal.height(), 
                                    entries )
                    calc.processCalculation()
                    del(calc)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'1nf.tif'),rasterdeentrada+str("1nf"))
                   
                    #filtro gausian para dar valor en funcion de los vecinos
                    input=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'1nf.tif')
                    result=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'g2.sdat')
                    params={'INPUT':input,'MODE': 1, 'RADIUS': 5,'SIGMA' :1,'RESULT':result}
                    processing.run('saga:gaussianfilter', params)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'g2.sdat'),rasterdeentrada+str("g2"))
                
                    #filtro y me quedo con lo mayor de un valor 
                    calc = QgsRasterCalculator("'"+rasterdeentrada+'g2@1 > '+str(filtro)+"'",
                                           os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'g2s.tif'),
                                           'GTiff',
                                    layerglobal.extent(), 
                                    layerglobal.width(), 
                                    layerglobal.height(), 
                                    entries )
                    calc.processCalculation()
                    del(calc)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'g2s.tif'),rasterdeentrada+str("g2s"))
                
                    #filtro  filter clums eliminar los huecos menores de 1300 m2
                    input=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'g2s.tif')  
                    result=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'3.sdat')
                    params={'GRID' : input,'OUTPUT' :result ,'THRESHOLD' :13}
                    processing.run('saga:removesmallpixelclumpstonodata', params)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'3.sdat'),rasterdeentrada+str("3"))

                    #filtro para rellenar huecos pequenos
                    print ("paso5 de agregado")
                    input=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'3.sdat')
                    output=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'31.tif')
                    params={'INPUT':input,'DISTANCE': 3, 'BAND': 1,'ITERATIONS': 0,'NO_MASK': False,'OUTPUT':output}
                    processing.run('gdal:fillnodata', params)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'31.tif'),rasterdeentrada+str("31"))

                    #filtro mayorityffilter para dar valor en funcion de los vecinos
                    print ("paso6 de agregado")
                    input=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'31.tif')
                    result=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'4.sdat')
                    params={ 'INPUT' : input, 'MODE' : 0, 'RADIUS' : 1, 'RESULT' : result, 'THRESHOLD' : 4 }
                    processing.run('saga:majorityfilter', params)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'4.sdat'),rasterdeentrada+str("4"))
                    
                    #filtro  filter clums eliminar los huecos
                    print ("paso7 de agregado")
                    input=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'4.sdat')
                    min=5
                    result=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'6.tif')
                    params={ 'EIGHT_CONNECTEDNESS' : False, 'INPUT' : input, 'MASK_LAYER' : None, 'NO_MASK' : False, 'OUTPUT' : result, 'THRESHOLD' : 5 }
                    processing.run('gdal:sieve', params)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'6.tif'),rasterdeentrada+str("6"))

                    #filtro para rellenar huecos pequenos
                    print ("paso8 de agregado")
                    input=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'6.tif')
                    output=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'7.tif')
                    params={'INPUT':input,'DISTANCE': 3, 'BAND': 1,'ITERATIONS': 0,'NO_MASK': False,'OUTPUT':output}
                    processing.run('gdal:fillnodata', params)
                    StringToRaster(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'7.tif'),rasterdeentrada+str("7"))
                    
                    #lo vectorizo
                    print ("paso9 de agregado")
                    parameters = {'INPUT': os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'7.tif'),'BAND': 1,  'FIELD': "DN",  'EIGHT_CONNECTEDNESS':False, 'OUTPUT': os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp')}
                    processing.runAndLoadResults("gdal:polygonize",parameters)
                    #processing.runalg("gdalogr:polygonize",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'7.tif'),"DN",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'))
                    #seleciono lo que me interesa
                    print ("paso10 de agregado")
                    lyr=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'),rasterdeentrada,"ogr")
                    ##QgsProject.instance().addMapLayers([lyr]) #ojo no me hace falta cargarlo dos veces
                    """selection = lyr.getFeatures(QgsFeatureRequest().setFilterExpression(u'"DN" = 1'))
                    ##selecionado = lyr.setSelectedFeatures([s.id() for s in selection])
                    selecionado = lyr.selectByIds([s.id() for s in selection])
                    nbrSelected=lyr.selectedFeatureCount()
                    print ("selecionados")
                    print (nbrSelected)
                    print ([s.id() for s in selection])"""
                    
                    #hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces. 
                    layer = lyr #iface.activeLayer()
                    print ("paso11 de agregado")
                    expression = QgsExpression( u'"DN" = 1' )
                    print ("paso12 de agregado")
                    # Added / changed lines ##########
                    context = QgsExpressionContext()
                    scope = QgsExpressionContextScope()
                    context.appendScope(scope)
                    print ("paso13 de agregado")
                    layer = lyr
                    feats=[]
                    ids=[]
                    for feat in layer.getFeatures():
                        scope.setFeature(feat)
                        result = expression.evaluate(context)
                        if result:
                            feats.append(feat)
                            ids.append(feat.id())
                            #areas.append(feat.geometry().area() )
                    ################
                    horaacabaagregado0= time.time()
                    print("tiempo agregado0")
                    print(horaepiezaagregado-horaacabaagregado0)
                    if len(ids)>0:
                        #print ("len feats")
                        #print( len( feats))
                        print ("paso14 de agregado")
                        """epsg = layer.crs().postgisSrid()
                        uri = "Polygon?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
                        mem_layer = QgsVectorLayer(uri, 'mem_layer', 'memory')
                        prov = mem_layer.dataProvider()
                        print ("paso15 de agregado")"""
                        """for i, feat in enumerate(feats):
                            #feat.setAttributes([i])
                            mem_layer.addFeature(feat)
                            ids.append(feat.id())"""
                        #prov.addFeatures(feats)
                        lyr.selectByIds(ids)
                        #lyr es la capa de entrada, la origen ue contiene todos los elementos
                        output_path=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')
                        QgsVectorFileWriter.writeAsVectorFormat(lyr, output_path, "CP120", lyr.crs(), "ESRI Shapefile", onlySelected=True)
                        lyr2=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp'),rasterdeentrada+str("2"),"ogr")
                        QgsProject.instance().addMapLayer(lyr2)
                        print ("en teoria ha hecho la seleccion")
                                            

                    #if nbrSelected > 0:
                        #guardo lo selecionado
                        """print ("pasa por aqui")
                        #params={ 'INPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'), 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                        params={ 'INPUT' : mem_layer, 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                        processing.run("qgis:saveselectedfeatures",params)"""

                        #calcula la superficie de esta capa pero no en todos los registros
                        layer=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp'),rasterdeentrada+str("2"),"ogr")
                        #layer=lyr2
                        provider = layer.dataProvider()
                        print ("layer get features")
                        #for feat in layer.getFeatures():
                            #print ("feat")
                            #print (feat)
                        areas = [ feat.geometry().area()  for feat in layer.getFeatures() ]
                        #print (areas)
                        indice = [ feat.id()  for feat in layer.getFeatures() ]
                        #print (indice)
                        field = QgsField("area", QVariant.Int)
                        provider.addAttributes([field])
                        layer.updateFields()
                        #idx = layer.fieldNameIndex('area')
                        idx = layer.fields().indexFromName('area')###ojo aqui es donde da cero el indice
                        long=len(indice)
                        print ("long")
                        print (long)
                        i=0
                        print ("pasa por aqui2")
                        while i<long:
                            new_values = {idx : float(areas[i])}
                            #print ("pasa por aqui3")
                            provider.changeAttributeValues({indice[i]:new_values})
                            #print ("pasa por aqui4")
                            i=i+1           
                        layer.updateFields()
                        print ("pasa por aqui5")

                        #selecciono las teselas mayor de una superficie dada.
                        #hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces. 
                        #layer2 = layer #iface.activeLayer()
                        print ("paso11 de agregado")
                        expression = QgsExpression( u'"area" > 2500')
                        print ("paso12 de agregado")
                        # Added / changed lines ##########
                        context = QgsExpressionContext()
                        scope = QgsExpressionContextScope()
                        context.appendScope(scope)
                        
                        feats=[]
                        ids=[]
                        for feat in layer.getFeatures():
                            scope.setFeature(feat)
                            result = expression.evaluate(context)
                            if result:
                                feats.append(feat)
                                ids.append(feat.id())
                                #areas.append(feat.geometry().area() )
                        ################
                        if len(ids)>0:
                            #print ("len feats")
                            #print( len( feats))
                            print ("paso14 de agregado")
                            """epsg = layer.crs().postgisSrid()
                            uri = "Polygon?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
                            mem_layer = QgsVectorLayer(uri, 'mem_layer', 'memory')
                            prov = mem_layer.dataProvider()
                            print ("paso15 de agregado")"""
                            """for i, feat in enumerate(feats):
                                #feat.setAttributes([i])
                                mem_layer.addFeature(feat)
                                ids.append(feat.id())"""
                            #prov.addFeatures(feats)
                            lyr2.selectByIds(ids)
                            #lyr es la capa de entrada, la origen ue contiene todos los elementos
                            output_path=os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'3.shp')
                            QgsVectorFileWriter.writeAsVectorFormat(lyr2, output_path, "CP120", lyr.crs(), "ESRI Shapefile", onlySelected=True)
                            lyr3=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'3.shp'),rasterdeentrada+str("3"),"ogr")
                            QgsProject.instance().addMapLayer(lyr3)
                            print ("en teoria ha hecho la seleccion2")
                            horaacabaagregado1= time.time()
                            print("tiempoacabaagregado1")
                            print(horaacabaagregado1-horaacabaagregado0)


                        
                        """ layer2=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp'),rasterdeentrada+str("2"),"ogr")
                        print ("pasa por aqui6")
                        QgsProject.instance().addMapLayers([layer2])
                        print ("pasa por aqui7")
                        selection = layer2.getFeatures(QgsFeatureRequest().setFilterExpression(u'"area" > 2500'))
                        print ("pasa por aqui8")
                        elementos=len(list(selection))
                        print (elementos)
                        if elementos >0:
                            selection = layer2.getFeatures(QgsFeatureRequest().setFilterExpression(u'"area" > 2500'))#lo repito porque se pierde
                            selecionado = layer2.setSelectedFeatures([s.id() for s in selection])
                            print (selecionado)
                            params={ 'INPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp'), 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'3.shp') }
                            processing.run("qgis:saveselectedfeatures",params)
                            print("ha chutado")
                            layer3=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'3.shp'),rasterdeentrada+str("3"),"ogr")
                            QgsProject.instance().addMapLayer(layer3)
                            print("ha cargado el layer3")"""
                        #else:
                         #   print("pass en el agregado")
                          #  pass
                        #del(selection)
                        #del(selecionado)
                                      
                #except:
                 #   pass
            #calculo las variables basicas sin proyectar
            print("empieza calculo las variables basicas sin proyectar")
            horaepiezacalculovariabesbasicas= time.time()
            print(horaepiezacalculovariabesbasicas)
            StringToRaster(salida5,"fcc")
            calculo('fcc@1',"fcc")
            StringToRaster(salida4,"hm")
            calculo('hm@1',"hm")
            StringToRaster(salida100,"hbc")
            calculo('hbc@1',"hbc")
            calculo('100 * ( hm@1 - hbc@1 ) / hm@1',"rc")
            StringToRaster(os.path.join(carpeta,troncoresumido+'_rc.tif'),"rc")
            calculo(' hm@1 - hbc@1 ',"lc")
            StringToRaster(os.path.join(carpeta,troncoresumido+'_lc.tif'),"lc")
            
            

            
            StringToRaster(salida_coverfile1.replace(".dtm", ".asc"),"fcc1")#de0.3 a 0.6
            calculo('fcc1@1',"fcc1")
            StringToRaster(salida_coverfile2.replace(".dtm", ".asc"),"fcc2")#de 0.6 a 2
            calculo('fcc2@1',"fcc2")
            StringToRaster(salida_coverfile3.replace(".dtm", ".asc"),"fcc3")#de 2 a 4
            calculo('fcc3@1',"fcc3")
            StringToRaster(salida_coverfile4.replace(".dtm", ".asc"),"fcc4")#>4
            calculo('fcc4@1',"fcc4")

            #genero una carpeta para los datos intermedios
            carpetap=os.path.join(carpeta,"p")
            carpeta=carpetap
            if not os.path.exists(carpetap):
                os.mkdir(carpetap)
            #proyecto la altura con el crecimiento
            calculo('(hm@1 < 5) * hm@1 + (hm@1 >= 5) * (hm@1 + ' +str(crecimiento)+')', 'hmp')
            StringToRaster(os.path.join(carpeta,troncoresumido+'_hmp.tif'),"hmp")
            #proyecto la altura  de la base de la copa con el crecimiento
            calculo('(hm@1 < 7.5) * hbc@1 + (hm@1 >= 7.5) * (hbc@1 + ' +str(crecimiento)+')','hbcp')
            StringToRaster(os.path.join(carpeta,troncoresumido+'_hbcp.tif'),"hbcp")
            #calculo  la razon de copa una vez proyectada la altura y la base de la copa
            calculo('100 * ( hmp@1   -  hbcp@1  ) / ( hmp@1 )', 'rcp')
            StringToRaster(os.path.join(carpeta,troncoresumido+'_rcp.tif'),"rcp")
            #proyecto la fraccion de cabida cubierta
            calculo('('+str(crecimiento)+' > 0) * (fcc@1  + ' +str(crecimientofcc)+') + ( '+str(crecimiento)+' = 0) * (fcc@1 )', 'fccp')
            StringToRaster(os.path.join(carpeta,troncoresumido+'_fccp.tif'),"fccp")
            #proyecto la longitud de copa
            calculo('(hmp@1 - hbcp@1)','lcp')
            StringToRaster(os.path.join(carpeta,troncoresumido+'_lcp.tif'),"lcp")

            #introduzco los condicionantes para cada tipo de masa

            calculo('(fcc1@1 >= '+str(50)+') * 1 ','C1')
            calculo('(fcc1@1 >= '+str(60)+')*(fcc4@1 < '+str(50)+')*2','C2')
            calculo('((fcc1@1 + fcc2@1) >= '+str(60)+')*(fcc4@1 < '+str(50)+')*3','C3')
            calculo('(fcc3@1 > '+str(60)+')*(fcc4@1 < '+str(50)+')*4','C4')
            calculo('((fcc1@1 + fcc2@1 + fcc3@1) < '+str(30)+')*(hm@1 >= '+str(4)+')*5', 'C5')
            calculo('((fcc1@1 + fcc2@1 + fcc3@1) > '+str(30)+')*(hm@1 >= '+str(4)+')*6', 'C6')#falta considerar la continuidad vertical
            
            
            horaepiezacalculotiposdemasa= time.time()
            print("tiempo en raster")
            print(horaepiezacalculotiposdemasa-horaepiezacalculovariabesbasicas)
            #empiezo carga de capas c
            print("empieza cargadecapastipos")
            horaepiezacargadecapastipos= time.time()
            print(horaepiezacargadecapastipos)
            StringToRaster(os.path.join(carpeta,troncoresumido+'_C1.tif'),"c1")
            StringToRaster(os.path.join(carpeta,troncoresumido+'_C2.tif'),"c2")
            StringToRaster(os.path.join(carpeta,troncoresumido+'_C3.tif'),"c3")
            StringToRaster(os.path.join(carpeta,troncoresumido+'_C4.tif'),"c4")
            StringToRaster(os.path.join(carpeta,troncoresumido+'_C5.tif'),"c5")
            StringToRaster(os.path.join(carpeta,troncoresumido+'_C6.tif'),"c6")
                
            #sumo todas las capas c
            calculo('c1@1 + c2@1 + c3@1 + c4@1 + c5@1 + c6@1   ', 'suma')
            StringToRaster(os.path.join(carpeta,troncoresumido+'_suma.tif'),"suma")

#lo vectorizo
            parameters = {'INPUT': os.path.join(carpeta,troncoresumido+'_suma.tif'),'BAND': 1,  'FIELD': "DN",  'EIGHT_CONNECTEDNESS':False, 'OUTPUT': os.path.join(carpeta,troncoresumido+'_suma.shp')}
            processing.runAndLoadResults("gdal:polygonize",parameters)
            #processing.run("gdalogr:polygonize",os.path.join(carpeta,troncoresumido+'_suma.tif'),"DN",os.path.join(carpeta,troncoresumido+'_suma.shp'))
            #sumashp=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_suma.shp'),"sumashp","ogr")
            #QgsMapLayerRegistry.instance().addMapLayer(sumashp)
            """
            #filtro para quedarme con la clara
            if self.dlg4.checkBox_claras.isChecked(): 
                calculo('c11@1 / 81 + c14@1 / 9  + c15@1 / 81 + c19@1 / 82 + c20@1 / 121 + c21@1 / 82 + c25@1 / 122 + c26@1 / 13', 'clara1')
                StringToRaster(os.path.join(carpeta,troncoresumido+'_clara1.tif'),"clara1")
                agregado("clara",0.26)

            #filtro para quedarme con la regeneracion
            if self.dlg4.checkBox_regeneracion.isChecked():   
                calculo('c28@1 / 15 ','regeneracion1')
                StringToRaster(os.path.join(carpeta,troncoresumido+'_regeneracion1.tif'),"regeneracion1")
                agregado("regeneracion",0.26)

            #filtro para quedarme con el resalveo
            if self.dlg4.checkBox_resalveo.isChecked():
                calculo('c3@1 / 51 + c8@1 / 52', 'resalveo1')
                StringToRaster(os.path.join(carpeta,troncoresumido+'_resalveo1.tif'),"resalveo1")
                agregado("resalveo",0.16)
            """
            #elimino las capas que he cargado durante el proceso
            capas =QgsProject.instance().mapLayers()
            for capa in capas:
                if capa not in capasoriginales:
                    QgsProject.instance().removeMapLayers( [capa] )

            print("deberia acabar el while true")
            #break  ojo iba con el while true
            print("pero no ha acabado el while true")
        #except:
            #print ("excepcion")
            #pass
            print ("acaba exprime lidar")
   


        #defino una funcion que une en una capa el resultado de todas las hojas
        def juntoshapes(busca,salida):
            print("empieza juntoshapes")
            horaepiezajuntoshapes= time.time()
            files=glob.glob(busca)
            out=os.path.join(carpeta,salida+".shp")
            entradas=";".join(files)
            #entrada=[]
            entrada=files
            print("entrada")
            print(entrada)
            print("entradas")
            print (entradas)
            params={ 'LAYERS' : entrada, 'OUTPUT' : out , 'CRS' : None }
            if len(files)>100:
                lista1=files[:len(files)/2]
                lista2=files[len(files)/2:]
                out=os.path.join(carpeta,salida+"1.shp")
                entrada=";".join(lista1)                
                processing.run('native:mergevectorlayers',params)
                out=os.path.join(carpeta,salida+"2.shp")
                entrada=";".join(lista2)
                processing.run('native:mergevectorlayers',params)
            elif len(files) >1 and len(files) <=100:
                processing.run('native:mergevectorlayers',params)
            elif len(files) ==1:#### metodo bueno de selecionar y guardar mirar tiempos para ver si esta es mejor a la que tengo en agregate
                layer2=QgsVectorLayer(files[0],"entrada","ogr")
                QgsProject.instance().addMapLayers([layer2])
                selection = layer2.getFeatures(QgsFeatureRequest().setFilterExpression(u'"DN" > 0'))
                selecionado = layer2.selectByIds([s.id() for s in selection])
                params={'INPUT': files[0]  , 'OUTPUT': out}
                processing.run("native:saveselectedfeatures",params)
            else:
                pass
            del(out)
            del(entrada)
            del(files)
            horaacabajuntoshapes= time.time()
            print ("tiempo junto shapes")
            print(horaepiezajuntoshapes-horaacabajuntoshapes)


        #defino una funcion que une en una capa el resultado de todas las hojas raster, hace un grid de lo que encuentre con la cadena
        def juntarasters(cadena):
            busca=os.path.join(carpeta,"*_"+cadena+".tif")
            files=glob.glob(busca)
            out=os.path.join(carpeta,cadena.upper()+".vrt")
            params={ 'INPUT':files,'RESOLUTION':0,'SEPARATE':False,'PROJ_DIFFERENCE':False,'ADD_ALPHA':False,'ASSIGN_CRS':None,'RESAMPLING':0,'SRC_NODATA':'','EXTRA':'','OUTPUT':out} 
            result = processing.run("gdal:buildvirtualraster", params)
            rutacapa=result['OUTPUT']
            layer = QgsRasterLayer(rutacapa, cadena.upper())
            QgsProject.instance().addMapLayer(layer)
            #coloreo

            layer.loadNamedStyle(os.path.dirname(__file__)+'/styles/'+cadena+'.qml')
            layer.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology( layer.id() )



        
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            #self.dlg = SilvilidarDialog()
            #la siguiente linea inicia el boton de cargar carpetas, peta al cerrar el qgis, deberia poner algun close o algo
            #self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)
            print("inicio el boton en el gui")
            #self.dlg.pushButton_select_path.setEnabled(True)
            print ("pone le boton como habiltado")
            

        # show the dialog
        self.dlg.show()
        
        #self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #print ("lo imprime si le doy a aceptar en el dialogo")
            carpeta=self.dlg.carpetalaz.text()#displayText()
            #la carpeta la he cogido al pulsar el boton de la carpeta

             #meto aqui variables que luego deberan estar en la cajita   OJO
            crecimiento= self.dlg3.crecimiento.text()##displayText()
            fccbaja=self.dlg2.fccbaja.text()##displayText()
            fccterrazas=self.dlg2.fccterrazas.text()##displayText()
            fccmedia=self.dlg2.fccmedia.text()##displayText()
            fccalta=self.dlg2.fccalta.text()##displayText()
            hmontebravoe=self.dlg2.hmontebravoe.text()##displayText()
            hmontebravo=self.dlg2.hmontebravo.text()##displayText()
            hselvicolas=self.dlg2.hselvicolas.text()##displayText()
            hclaras=self.dlg2.hclaras.text()#displayText()
            hclaras2=self.dlg2.hclaras2.text()#displayText()
            hbcminima=self.dlg2.hbcminima.text()#displayText()
            hbcdesarrollado= self.dlg2.hbcdesarrollado.text()#displayText()
            rcclaras=self.dlg2.rcclaras.text()#displayText()
            rcextremo=self.dlg2.rcextremo.text()#displayText()
            longitudcopaminima=self.dlg2.longitudcopaminima.text()##displayText()
            crecimientofcc=self.dlg3.crecimientofcc.text()##displayText()
            """crecimiento= 1.5
            fccbaja=20.0
            fccterrazas=57.5
            fccmedia=46.0
            fccalta=95.0
            hmontebravoe=3.5
            hmontebravo=5.0
            hselvicolas=7.5
            hclaras=12.0
            hclaras2=16.5
            hbcminima=3.0
            hbcdesarrollado= 5.5
            rcclaras=35.0
            rcextremo=17.0
            longitudcopaminima=3.25
            crecimientofcc=12.5"""

            #AQUI ACABA
            
            #compruebo que capas estan cargadas en el proyecto al iniciar el script
            capasoriginales =QgsProject.instance().mapLayers()
            a=["nombre de archivo","extension"]

            #congelo la vista  para ahorrar memoria  #ojo lo descongelo de momento   ojo ojo
            canvas = iface.mapCanvas()
            #canvas.freeze(True)


            #ejecuto la busqueda de archivos las
            buscalidaryejecuta(carpeta, crecimiento, fccbaja, fccterrazas, fccmedia, fccalta, hmontebravoe, hmontebravo, hselvicolas, hclaras, hclaras2, hbcminima, hbcdesarrollado, rcclaras, rcextremo, longitudcopaminima, crecimientofcc)



            #uno en una capa todas las hojas de claras, regeneracion, resalveo y teselas
            juntoshapes(os.path.join(carpeta,"p","*clara3.shp"),"Clara_merged")
            juntoshapes(os.path.join(carpeta,"p","*regeneracion3.shp"),"Regeneracion_merged")
            juntoshapes(os.path.join(carpeta,"p","*resalveo3.shp"),"Resalveo_merged")
            juntoshapes(os.path.join(carpeta,"p","*suma.shp"),"Teselas_merged")

            #elimino las capas que he cargado durante el proceso
            capas =QgsProject.instance().mapLayers()
            for capa in capas:
                if capa not in capasoriginales:
                    QgsProject.instance().removeMapLayers( [capa] )
            del(capas)
                
            #cargo las capas finales
            teselas=QgsVectorLayer(os.path.join(carpeta,'Teselas_merged.shp'),"Teselas","ogr")
            teselas1=QgsVectorLayer(os.path.join(carpeta,'Teselas_merged_proyectado1.shp'),"Teselas Proyectado1","ogr")
            teselas2=QgsVectorLayer(os.path.join(carpeta,'Teselas_merged_proyectado2.shp'),"Teselas Proyectado2","ogr")
            clara=QgsVectorLayer(os.path.join(carpeta,'Clara_merged.shp'),"Clara","ogr")
            regeneracion=QgsVectorLayer(os.path.join(carpeta,'Regeneracion_merged.shp'),"Regeneracion","ogr")
            resalveo=QgsVectorLayer(os.path.join(carpeta,'Resalveo_merged.shp'),"Resalveo","ogr")

            
            #aplico simbologia a estas capas, si existen
            try:
                symbolsclara=clara.renderer().symbol()
                sym=symbolsclara
                sym.setColor(QColor.fromRgb(255,0,0))
                QgsProject.instance().addMapLayer(clara)
            except: 
              pass

            try:
                symbolsregeneracion=regeneracion.renderer().symbol()
                sym=symbolsregeneracion
                sym.setColor(QColor.fromRgb(0,255,0))
                QgsProject.instance().addMapLayer(regeneracion)
            except: 
              pass

            try:
                symbolsresalveo=resalveo.renderer().symbol()
                sym=symbolsresalveo
                sym.setColor(QColor.fromRgb(0,0,255))
                QgsProject.instance().addMapLayer(resalveo)
            except: 
              pass

            #coloresteselas={"1":("solid","255,255,204,255","Raso o Regenerado","001"),"2":("solid","255,255,0,255","Menor (Monte Bravo)","002"),"3":("vertical","255,192,0,255","Poda Baja (y Clareo) en Bajo Latizal (Posibilidad si C elevada)","004"),"4":("solid","255,204,153,255","Bajo Latizal Desarrollado","005"),"51":("b_diagonal","255,0,255,255","Resalveo en Latizal poco desarrollado","006"),"52":("f_diagonal","255,0,0,255","Resalveo en Latizal","007"),"61":("solid","255,153,255,255","Latizal poco desarrollado Tratado","008"),"62":("solid","255,124,128,255","Latizal Tratado","009"),"7":("solid","204,255,153,255","Alto Latizal Claro","010"),"81":("b_diagonal","146,208,80,255","Poda Alta y Clara Suave en Latizal","011"),"82":("b_diagonal","51,204,204,255","Poda Alta y Clara Suave en Monte Desarrollado","015"),"9":("f_diagonal","0,176,80,255","Primera Clara y Poda Alta","012"),"10":("solid","102,255,153,255","Alto Latizal Aclarado","013"),"111":("solid","102,255,255,255","Fustal Claro","014"),"112":("solid","139,139,232,255","Fustal Maduro Claro","018"),"121":("f_diagonal","0,176,255,240","Clara en Fustal","016"),"122":("b_diagonal","65,51,162,255","Clara en Fustal Maduro","019"),"13":("cross","0,112,192,255","Clara Urgente en Fustal Maduro","020"),"141":("solid","204,236,255,255","Fustal Aclarado","017"),"142":("solid","166,166,207,255","Fustal Maduro Aclarado","021"),"15":("horizontal","112,48,160,255","Posibilidad de Regeneracion","022"),"17":("solid","orange","Bajo Latizal No Concurrente o Latizal Encinar no Denso","003")}

            #ordeno los elementos de teselas ojo ojo
            #ordenados=coloresteselas.items()
            #ordenados.sort(key=lambda clave: str(clave[1][3]))
            #me salto el orden del diccionario
            ordenados=[('1', ('solid', '255,255,204,255', 'Raso o Regenerado', '001')), ('2', ('solid', '255,255,0,255', 'Menor (Monte Bravo)', '002')), ('17', ('solid', 'orange', 'Bajo Latizal No Concurrente o Latizal Encinar no Denso', '003')), ('3', ('vertical', '255,192,0,255', 'Poda Baja (y Clareo) en Bajo Latizal (Posibilidad si C elevada)', '004')), ('4', ('solid', '255,204,153,255', 'Bajo Latizal Desarrollado', '005')), ('51', ('b_diagonal', '255,0,255,255', 'Resalveo en Latizal poco desarrollado', '006')), ('52', ('f_diagonal', '255,0,0,255', 'Resalveo en Latizal', '007')), ('61', ('solid', '255,153,255,255', 'Latizal poco desarrollado Tratado', '008')), ('62', ('solid', '255,124,128,255', 'Latizal Tratado', '009')), ('7', ('solid', '204,255,153,255', 'Alto Latizal Claro', '010')), ('81', ('b_diagonal', '146,208,80,255', 'Poda Alta y Clara Suave en Latizal', '011')), ('9', ('f_diagonal', '0,176,80,255', 'Primera Clara y Poda Alta', '012')), ('10', ('solid', '102,255,153,255', 'Alto Latizal Aclarado', '013')), ('111', ('solid', '102,255,255,255', 'Fustal Claro', '014')), ('82', ('b_diagonal', '51,204,204,255', 'Poda Alta y Clara Suave en Monte Desarrollado', '015')), ('121', ('f_diagonal', '0,176,255,240', 'Clara en Fustal', '016')), ('141', ('solid', '204,236,255,255', 'Fustal Aclarado', '017')), ('112', ('solid', '139,139,232,255', 'Fustal Maduro Claro', '018')), ('122', ('b_diagonal', '65,51,162,255', 'Clara en Fustal Maduro', '019')), ('13', ('cross', '0,112,192,255', 'Clara Urgente en Fustal Maduro', '020')), ('142', ('solid', '166,166,207,255', 'Fustal Maduro Aclarado', '021')), ('15', ('horizontal', '112,48,160,255', 'Posibilidad de Regeneracion', '022'))]

            categorias=[]

            for clase,(relleno,color, etiqueta,orden) in ordenados:    
                props={'style':relleno, 'color':color, 'style_border':'no'}
                sym=QgsFillSymbol.createSimple(props)
                categoria=QgsRendererCategory(clase,sym,etiqueta)
                categorias.append(categoria)

            field="DN"
            renderer=QgsCategorizedSymbolRenderer(field,categorias)
            teselas.setRenderer(renderer)
            QgsProject.instance().addMapLayer(teselas)

            #cargo los rasters virtuales si chekeado en la salidas
            if self.dlg4.checkBox_altura.isChecked():
                juntarasters("hm")
            if self.dlg4.checkBox_fcc.isChecked():
                juntarasters("fcc")
            if self.dlg4.checkBox_rc.isChecked():
                juntarasters("rc")
            if self.dlg4.checkBox_lc.isChecked():
                juntarasters("lc")
            if self.dlg4.checkBox_hbc.isChecked():
                juntarasters("hbc")

            
            """
            categorias1=[]
            for clase,(relleno,color, etiqueta,orden) in ordenados:    
                props={'style':relleno, 'color':color, 'style_border':'no'}
                sym=QgsFillSymbol.createSimple(props)
                categoria1=QgsRendererCategory(clase,sym,etiqueta)
                categorias1.append(categoria1)

            field="DN"
            renderer=QgsCategorizedSymbolRenderer(field,categorias1)
            teselas1.setRenderer(renderer)
            QgsProject.instance().addMapLayer(teselas1)

            categorias2=[]
            for clase,(relleno,color, etiqueta,orden) in ordenados:    
                props={'style':relleno, 'color':color, 'style_border':'no'}
                sym=QgsFillSymbol.createSimple(props)
                categoria2=QgsRendererCategory(clase,sym,etiqueta)
                categorias2.append(categoria2)

            field="DN"
            renderer=QgsCategorizedSymbolRenderer(field,categorias2)
            teselas2.setRenderer(renderer)
            QgsProject.instance().addMapLayer(teselas2)
            """
            
            #repinto todo refrescando la vista
            canvas.freeze(False)
            canvas.refresh()
            #self.dlg.pushButton_select_path.setEnabled(False)
            #self.dlg.close()
            #print (capasoriginales)

            
            print (carpeta, crecimiento, fccbaja, fccterrazas, fccmedia, fccalta, hmontebravoe, hmontebravo, hselvicolas, hclaras, hclaras2, hbcminima, hbcdesarrollado, rcclaras, rcextremo, longitudcopaminima, crecimientofcc)
            
            pass
