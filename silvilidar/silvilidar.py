# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Silvilidar
                                 A QGIS plugin
Permite procesar datos LiDAR de una manera sencilla para obtener un diagnostico selvicola
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-01-29
        git sha              : $Format:%H$
        copyright            : (C) 2019 by javier diez
        email                : dierabfr@jcyl.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
# from PyQt5.QtGui import QIcon
# from PyQt5.QtWidgets import QAction

from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.gui import QgsMessageBar

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .silvilidar_dialog import SilvilidarDialog
from .config_dialog import ConfigDialog
from .project_dialog import ProjectDialog
from .salida_dialog import SalidaDialog
import os.path

# import para procesar
import platform
from qgis.analysis import QgsNativeAlgorithms
from qgis.core import QgsProject, QgsRasterLayer, QgsVectorLayer, QgsFeatureRequest, QgsField, QgsExpression, \
    QgsExpressionContext, QgsExpressionContextScope, QgsVectorFileWriter, QgsFillSymbol, QgsRendererCategory, \
    QgsCategorizedSymbolRenderer, QgsExpressionContextUtils, QgsApplication, QgsMapLayer, QgsPointXY, QgsGeometry, \
    QgsRaster, QgsCoordinateReferenceSystem
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
# from PyQt5.QtCore import QFileInfo
from qgis.PyQt.QtCore import QFileInfo
from qgis.analysis import QgsRasterCalculator, QgsRasterCalculatorEntry
import processing
import os
import glob
import re
import sys
# from qgis import *
import time
import webbrowser
import tempfile

import numpy as np
import matplotlib.pyplot as plt

tamano = 10
class Salida:
    def __init__(self, iface):
        self.dlg4 = SalidaDialog()


class Project:
    def __init__(self, iface):
        self.dlg3 = ProjectDialog()


class Config:
    def __init__(self, iface):
        self.dlg2 = ConfigDialog()



class Silvilidar:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        self.locale = QSettings().value('locale/userLocale')[0:2]
        self.locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Silvilidar_{}.qm'.format(self.locale))

        if os.path.exists(self.locale_path):
            self.translator = QTranslator()
            self.translator.load(self.locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)
        def dentro_de_jcyl():
            import socket
            import re
            # ojo esto es para que no FUNCIONE DE MOMENTO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO eliminarlo cuando queramos que sea interactivo, eliminar
            print("devuelvo false porque se supone que estoy fuera de jcyl")
            #ojo la siguiente linea es un atajo para que entienda siempre que estoy fuera de la junta
            #return False
            # ojo esto es para que no FUNCIONE DE MOMENTO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO eliminarlo cuando queramos que sea interactivo, eliminar
            try:
                dominio = socket.getfqdn()
                patron = re.compile(r'JMA\w{6,14}\.jcyl\.red')

                if patron.match(dominio):
                    print("dentro junta")
                    return True
            except Exception as e:
                print("fuera junta")
                # Manejar la excepción de manera adecuada
                pass

            return False


        self.dentro= dentro_de_jcyl()

        self.dlg = SilvilidarDialog()
        self.dlg2 = ConfigDialog()
        self.dlg3 = ProjectDialog()
        self.dlg4 = SalidaDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Silvilidar')

        self.toolbar = self.iface.addToolBar(u'Silvilidar')
        self.toolbar.setObjectName(u'Silvilidar')
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        if self.dentro == False:
            self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)
        self.dlg.help_button.clicked.connect(self.help_pressed)
        self.dlg.pushButton_parametros.clicked.connect(self.configurar_parametros)
        self.dlg.pushButton_proyectar.clicked.connect(self.proyectar_datos_lidar)
        self.dlg.pushButton_salida.clicked.connect(self.salida)
        self.dlg3.crecimiento.textChanged.connect(self.datosenlazados)

        self.dlg.pushButton_select_shp.clicked.connect(self.select_shp)
        if self.dentro:
            self.dlg.pushButton_select_shp_3.clicked.connect(self.select_shp_zona_trabajo)
            self.dlg.pushButton_select_shp_4.clicked.connect(self.select_shp_zona_trabajo_2)


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Silvilidar', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):

        # cambio el icon path para mi equipo.
        usuario = QgsApplication.qgisSettingsDirPath()
        icon_path = os.path.join(usuario, r"python\plugins\silvilidar\icon.png")

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)
            # self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/silvilidar/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Silvilidar'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def select_laz_folder(self):
        """seleciono la carpeta con los datos de entrada"""

        # self.dlg.carpetalaz.clear()
        carpeta = QFileDialog.getExistingDirectory(self.dlg, self.tr(u"Selecciona carpeta"))
        self.dlg.carpetalaz.setText(carpeta)
        print(carpeta)

    def help_pressed(self):
        print("abre la ayuda")
        help_file = 'file:' + os.path.dirname(__file__) + '/Ayuda_Silvilidar.pdf'
        webbrowser.open_new(help_file)

    def configurar_parametros(self):
        print("entro en configurar")
        self.dlg2.show()

    def proyectar_datos_lidar(self):
        print("entro en proyectar datos lidar")
        self.dlg3.show()

    def salida(self):
        print("entro en configurar salidas")
        self.dlg4.show()

    def datosenlazados(self):
        self.dlg3.crecimientofcc.setText(str(8 * float(self.dlg3.crecimiento.text())))

    def select_shp(self):
        global tamano
        """seleciono el shp con los datos con los poligonos que quiero buscar similares"""
        rutaarchivomuestra = QFileDialog.getOpenFileName(self.dlg, "Capa de polígonos con las zonas de muestra", None,
                                                         'SHP(*.shp)')
        self.dlg.ruta_muestra_similar.setText(rutaarchivomuestra[0])
        # capa vectorial
        layervectorial = QgsVectorLayer(rutaarchivomuestra[0], "Capa con zonas de muestra", "ogr")
        feats = [feat for feat in layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]
        # print(rutaarchivomuestra[0])
        #calculo la superficie media de los poligonos que se van a usar para buscar similares
        superficie = 0
        for feat in feats:
            superficie += feat.geometry().area()
        #superficie = superficie / 10000
        #saco el tamano de la ventana a usar para que sea proporcional a la superficie de los poligonos siendo un cuadrado
        tamano = round(np.sqrt(superficie)/10,0)
        print("tamano resultante de ventana",tamano)

        return rutaarchivomuestra[0], feats

    def select_shp_zona_trabajo(self):
        """seleciono el shp con los datos con las zonas de trabajo"""
        rutaarchivomuestra = QFileDialog.getOpenFileName(self.dlg, "Capa de polígonos con las zonas de trabajo", None,
                                                         'SHP(*.shp)')
        self.dlg.ruta_zona_de_trabajo.setText(rutaarchivomuestra[0])
        # capa vectorial
        layervectorial = QgsVectorLayer(rutaarchivomuestra[0], "Capa con zonas de trabajo", "ogr")
        feats = [feat for feat in layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]
        # print(rutaarchivomuestra[0])

        return rutaarchivomuestra[0], feats
    def select_shp_zona_trabajo_2(self):
        """seleciono el shp con los datos con las zonas de trabajo para trabajar con las zonas similares"""
        rutaarchivomuestra = QFileDialog.getOpenFileName(self.dlg, "Capa de polígonos con las zonas de trabajo", None,
                                                         'SHP(*.shp)')
        self.dlg.ruta_zona_de_trabajo_2.setText(rutaarchivomuestra[0])
        # capa vectorial
        layervectorial = QgsVectorLayer(rutaarchivomuestra[0], "Capa con zonas de trabajo", "ogr")
        feats = [feat for feat in layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]
        # print(rutaarchivomuestra[0])

        return rutaarchivomuestra[0], feats

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.iface.removePluginMenu(
                self.tr(u'&Sigmena'),
                action)

    def run(self):
        def lenguaje_informe():
            def lenguaje_equipo():
                # es = castellano
                import locale
                idioma = locale.getdefaultlocale()[0][0:2]
                return idioma

            def lenguaje_qgis():
                # es = castellano
                idioma = QSettings().value("locale/userLocale")[0:2]
                return idioma

            lenguaje_equipo = lenguaje_equipo()
            lenguaje_qgis = lenguaje_qgis()
            if lenguaje_equipo and lenguaje_qgis == "es":
                return "es"
            else:
                return "en"

        lenguaje_informe = lenguaje_informe()

        def version_fusion_4_40():
            """Para ver si ejecuto el profile area que solo esta a partir de esa version"""
            versiones_validas= ['4.40', '4.41', '4.42', '4.43', '4.44', '4.45', '4.46', '4.47', '4.48', '4.49', '4.50', '4.51', '5.52', '5.53', '5.54', '5.55']
            try:
                with open('c:/FUSION/fusionnotes.txt', 'r') as f:
                    primera_linea = f.readline()
                #if '4.40' in primera_linea or '4.41' in primera_linea or '4.42' in primera_linea or '4.43' in primera_linea:
                resultados = [expresion for expresion in versiones_validas if expresion in primera_linea]
                if resultados:

                    return True
                else:
                    return False
            except:
                with open('c:/FUSION/doc/fusionnotes.txt', 'r') as f:
                    primera_linea = f.readline()
                # if '4.40' in primera_linea or '4.41' in primera_linea or '4.42' in primera_linea or '4.43' in primera_linea:
                resultados = [expresion for expresion in versiones_validas if expresion in primera_linea]
                if resultados:

                    return True
                else:
                    return False

        def bits64():
            # para ver si ejecuto las funciones de 32 o 64 bits
            return platform.architecture()[0] == '64bit'

        # ojo, esto creo que da problemas
        def activar_processing_y_saga():
            # activo processing y saga porque los necesita para procesar.
            Processing.initialize()
            QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
            QgsApplication.processingRegistry().addProvider(QgsApplication.processingRegistry().providerById('saga'))

        # activar_processing_y_saga()
        def print2(objeto):
            filename = "c:/work/silvilidar.txt"
            if isinstance(objeto, str):
                with open(filename, "a") as file:
                    file.write(objeto)
                    file.write('\n')
            elif type(objeto) == dict:
                with open(filename, "a") as file:
                    for clave, valor in objeto.items():
                        file.write(str(clave) + " " + str(valor))
                    file.write('\n')
            elif type(objeto) == list:
                with open(filename, "a") as file:
                    for elemento in objeto:
                        file.write(elemento)
                    file.write('\n')
            else:
                with open(filename, "a") as file:
                    file.write("No se puede imprimir")
                    file.write('\n')

        # funcion que carga una capa y prepara la banda para operar con ella
        def StringToRaster(raster, banda):
            fileInfo = QFileInfo(raster)
            path = fileInfo.filePath()
            baseName = fileInfo.baseName()
            global layerglobal
            layerglobal = QgsRasterLayer(path, baseName)
            #print("ruta de global layer ",path)
            QgsProject.instance().addMapLayer(layerglobal)
            if layerglobal.isValid() is True:
                bandaref = str(banda) + '@1'
                # Define band1
                banda = QgsRasterCalculatorEntry()
                banda.ref = bandaref
                banda.raster = layerglobal
                banda.bandNumber = 1
                entries.append(banda)
            else:
                print("Unable to read basename and file path - Your string is probably invalid" + str(
                    baseName))

                # defino funcion para hacer calculo de capas raster

        # defino la funcion que busca los archivos las o laz que existan y le paso los parametros resultantes
        # del formulario
        def buscalidaryejecuta(carpeta, crecimiento, crecimientofcc,fccminarbolado , alturadesconocida,hmaxmontebravo ,  hmaxbajolatizal , rcminresalveoencinarlatizalpocodesarrollado ,fccmincompetenciaencinarlatizalpocodesarrollado , hmaxselvicolas ,  hbcpodabaja ,fccmincompetenciamasadiscontinua_fustalencinares ,rcminclara ,longitudcopaminclara,fcccompetenciaelevada ,hmaxsegundaclara ,hbcminclarasnormales ,fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado):
            print("empieza busca y ejecuta")
            print(carpeta)
            for base, dirs, files in os.walk(carpeta):
                carpetas_y_subcarpetas = base
                archivos = files
                for archivo in archivos:
                    a = list(os.path.splitext(archivo))
                    extension = a[1].lower()
                    if extension == ".laz" or extension == ".las":
                        if a[0][-5:] == '.copc':
                            if os.path.isfile(carpeta + '/' + a[0][:-5] + '.laz') == False:
                                las = os.path.join(a[0] + a[1])
                                exprimelidar(las, carpeta, crecimiento, crecimientofcc,fccminarbolado , alturadesconocida,hmaxmontebravo ,  hmaxbajolatizal , rcminresalveoencinarlatizalpocodesarrollado ,fccmincompetenciaencinarlatizalpocodesarrollado , hmaxselvicolas ,  hbcpodabaja  ,fccmincompetenciamasadiscontinua_fustalencinares ,rcminclara ,longitudcopaminclara,fcccompetenciaelevada ,hmaxsegundaclara ,hbcminclarasnormales ,fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado)
                        else:
                            las = os.path.join(a[0] + a[1])
                            exprimelidar(las, carpeta, crecimiento, crecimientofcc,fccminarbolado , alturadesconocida,hmaxmontebravo ,  hmaxbajolatizal , rcminresalveoencinarlatizalpocodesarrollado ,fccmincompetenciaencinarlatizalpocodesarrollado , hmaxselvicolas ,  hbcpodabaja  ,fccmincompetenciamasadiscontinua_fustalencinares ,rcminclara ,longitudcopaminclara,fcccompetenciaelevada ,hmaxsegundaclara ,hbcminclarasnormales ,fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado)

        # defino la funcion que lo hace todo con un archivo las o laz concreto
        def exprimelidar(las, carpeta, crecimiento, crecimientofcc,fccminarbolado , alturadesconocida,hmaxmontebravo ,  hmaxbajolatizal , rcminresalveoencinarlatizalpocodesarrollado ,fccmincompetenciaencinarlatizalpocodesarrollado , hmaxselvicolas ,  hbcpodabaja  ,fccmincompetenciamasadiscontinua_fustalencinares ,rcminclara ,longitudcopaminclara,fcccompetenciaelevada ,hmaxsegundaclara ,hbcminclarasnormales ,fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado):
            fcstring = ""

            # defino un par de variables con el nombre del archivo y su abreviatura. Pensado para la denominacion estandar de los archivos LiDAR del PNOA
            tronco = las[:-4]
            patron = re.compile(('\d{3}\_\d{4}|\d{3}\-\d{4}|\d{4}\_\d{1}\-\d{1}'))
            troncoresumido = patron.findall(las)[0].replace("-", "_")
            print("empieza exprime lidar con los archivos laz")
            # horaepiezaexprimelidar = time.time()
            # print(horaepiezaexprimelidar)
            #if self.dentro == False:
            # puesto tabulador de linea 407 a 659
            # definicion de parametros funciones y rutas
            funcion1 = "c:/fusion/groundfilter"  # 64
            funcion2 = "c:/fusion/gridsurfacecreate"  # 64
            funcion3 = "c:/fusion/gridmetrics"  # 64
            funcion6 = "c:/fusion/DTM2ASCII"  # 64
            funcion7 = "c:/Fusion/LDA2ASCII"  # 64
            funcion4 = "c:/fusion/csv2grid"
            if bits64() and version_fusion_4_40():
                funcion1 = funcion1 + "64"
                funcion2 = funcion2 + "64"
                funcion3 = funcion3 + "64"
                funcion6 = funcion6 + "64"
                funcion7 = funcion7 + "64"

            salida0 = os.path.join(carpeta, a[0] + ".las")
            salida00 = os.path.join(carpeta, "filt" + a[0] + ".las")
            salida1 = os.path.join(carpeta, "groundfilter_" + tronco + ".lda")
            salida2 = os.path.join(carpeta, "groundfilter_" + tronco + ".dtm")
            salida6 = os.path.join(carpeta, "groundfilter_" + tronco + ".las")
            salida3 = os.path.join(carpeta, "metric.csv")
            salida4 = os.path.join(carpeta, tronco + "_height_grid.asc")
            salida5 = os.path.join(carpeta, tronco + "_cover_grid.asc")
            salida7 = os.path.join(carpeta, tronco + "_height.txt")
            salida8 = os.path.join(carpeta, tronco + "_height_grid_original.asc")
            salida100 = os.path.join(carpeta, tronco + "_basecopa.asc")
            if version_fusion_4_40() == True:
                salida101 = os.path.join(carpeta, tronco + "_profile.txt")
            # salida102 = os.path.join(carpeta, tronco + "_skewness.txt")

            parametros1 = 10
            parametros1_0 = "/class:2"#""#"/median:3 /wparam:2.5 /aparam:4 /bparam:4"# con esto solo considerara los puntos clasificados como suelo "/class:2"  #
            parametros2 = "10 M M 0 0 0 0"

            # parametros3_1 = "/minht:2 /nointensity"
            # hcorte2="2"#parametro a variar en la gui con la altura minima de corte por abajo
            parametros3_1 = "/minht:2 /nointensity"  # "/minht:{hcorte} /nointensity".format(hcorte=hcorte2)
            parametros3_2 = "2 10"  # hcorte2 + " 10"  # "0.5 10"
            parametros4 = 7
            parametros5 = 49
            parametros6 = "/raster"
            parametro7 = 2
            parametros100 = 27  # percentil del 20 por ciento
            parametros104 = 37  # percentil del 95 por ciendto
            if version_fusion_4_40():
                parametros101 = 71  # 71 es el profile area desde la version 4.4 de fusion
            # parametros102 = 14  # 14 es el skweness

            entrada0 = os.path.join(carpeta, las)
            entrada1 = os.path.join(carpeta, las)
            entrada2 = os.path.join(carpeta, "groundfilter_" + tronco + ".las")
            entrada3_1 = salida2
            entrada3_2 = entrada1
            entrada4 = os.path.join(carpeta, "metric_all_returns_elevation_stats_" + tronco + ".csv")
            entrada6 = salida2
            print("voy a empezar el try")
            # try:  ## va con el except de antes de Run method that performs all the real work. Volverlo a poner en cuanto sea posible. Ahora falla en el stringtolayer por el qfile info.   ojojojojojoj
            # while True:   ojo ha cambiado en python3, lo quito
            print("empiezo el while true")
            # paso1 groundfilter
            total1 = funcion1 + " " + parametros1_0 + " " + salida1 + " " + str(parametros1) + " " + entrada1
            print(total1)
            os.system(total1)

            # paso2 grid del suelo
            total2 = funcion2 + " " + salida2 + " " + str(parametros2) + " " + entrada2
            os.system(total2)

            # paso3 saca los parametros de ese grid
            total3 = funcion3 + " " + str(parametros3_1) + " " + entrada3_1 + " " + str(
                parametros3_2) + " " + salida3 + " " + entrada3_2
            print("gridmetrics ............................", total3)
            os.system(total3)
            os.rename(carpeta + "/metric_all_returns_elevation_stats.csv",
                      carpeta + "/metric_all_returns_elevation_stats_" + tronco + ".csv")
            os.rename(carpeta + "/metric_all_returns_elevation_stats_ascii_header.txt",
                      carpeta + "/metric_all_returns_elevation_stats_" + tronco + "_ascii_header.txt")

            # paso4 genera un grid del csv anterior  de alturas
            total4 = funcion4 + " " + entrada4 + " " + str(parametros104) + " " + salida4
            os.system(total4)

            # paso100 percentil20
            total100 = funcion4 + " " + entrada4 + " " + str(parametros100) + " " + salida100
            os.system(total100)

            # paso5 genera un grid del csv anterior de fcc
            total5 = funcion4 + " " + entrada4 + " " + str(parametros5) + " " + salida5
            os.system(total5)

            # paso5 genera un grid de profile area solo funciona a partir de la version 4.4 de fusion
            if version_fusion_4_40():
                total101 = funcion4 + " " + entrada4 + " " + str(parametros101) + " " + salida101
                os.system(total101)

            # paso102 genera un grid de skewness
            # total102 = funcion4 + " " + entrada4 + " " + str(parametros102) + " " + salida102
            # os.system(total102)

            # paso6 convierto en ascii
            total6 = funcion6 + " " + str(parametros6) + " " + entrada6
            os.system(total6)

            # paso7  convierto en ascii
            total7 = funcion7 + " " + entrada1 + " " + salida7 + " " + str(parametro7)
            os.system(total7)

            # empieza lo nuevo para volver a calcular gridmetrics con otros parametros de corte para calcular el fcc total 0.5 de hmin
            # paso3 saca los parametros de ese grid
            # renombro el archivo  carpeta + "/metric_all_returns_elevation_stats_" + tronco + ".csv"
            #DESDE AQUI ESTABA COMENTADO OJO_________________________________________________________________________________________________________________________
            """os.rename(carpeta + "/metric_all_returns_elevation_stats_" + tronco + ".csv",
                      carpeta + "/metric_all_returns_elevation_stats_" + tronco + "_.csv")
            os.rename(carpeta + "/metric_all_returns_elevation_stats_" + tronco + "_ascii_header.txt",
                      carpeta + "/metric_all_returns_elevation_stats_" + tronco + "_ascii_header_.txt")
            parametros3_1_ = "/minht:2 /nointensity"  # "/minht:{hcorte} /nointensity".format(hcorte=hcorte2)#CAMBIADO 2 POR 0.5
            parametros3_2_ = "2 10"  # hcorte2 + " 10"  # "0.5 10" #CAMBIADO 2 POR 0.5
            salida3_ = os.path.join(carpeta, "metric.csv")
            salida5_ = os.path.join(carpeta, tronco + "_cover_grid_.asc")
            total3_ = funcion3 + " " + str(parametros3_1_) + " " + entrada3_1 + " " + str(
                parametros3_2_) + " " + salida3_ + " " + entrada3_2
            os.system(total3_)
            os.rename(carpeta + "/metric_all_returns_elevation_stats.csv",
                      carpeta + "/metric_all_returns_elevation_stats_" + tronco + ".csv")
            os.rename(carpeta + "/metric_all_returns_elevation_stats_ascii_header.txt",
                      carpeta + "/metric_all_returns_elevation_stats_" + tronco + "_ascii_header.txt")

            # paso5 genera un grid del csv anterior de fcc
            total5_ = funcion4 + " " + entrada4 + " " + str(parametros5) + " " + salida5_
            os.system(total5_)"""
            #HASTA AQUI ESTABA COMENTADO OJO----------------------------------------------------------------------------------------------------------------------------

            # empieza lo nuevo para calcular la fcc total
            # print2("voy a crear el matorral")
            """funcion_fcc = "c:/fusion/Cover"
            salida_fcc = os.path.join(carpeta, tronco + "_fcc.dtm")
            h_min = '0.5'
            total_fcc_ = funcion_fcc + " " + salida2 + " " + salida_fcc + " " + h_min + " " + parametros2 + " " + entrada1
            print("cover ............................",total_fcc_)
            print(total_fcc_)
            os.system(total_fcc_)
            salida_fcc_ascii_ = os.path.join(carpeta, tronco + "_fcc.asc")
            total_fcc2_ = "c:/fusion/DTM2ASCII /raster" + " " + salida_fcc + " " + salida_fcc_ascii_
            print(total_fcc2_)
            os.system(total_fcc2_)
            # cargo  raster fcc
            fileName = total_fcc2_
            Layer = QgsRasterLayer(fileName, "fcc")
            # QgsProject.instance().addMapLayers([Layer])
            # nuevo para convertir nodata a fcc de 0
            parametros = {'COPY_SUBDATASETS': False, 'DATA_TYPE': 0, 'EXTRA': '', 'INPUT': salida_fcc_ascii,
                          'NODATA': -1000, 'OPTIONS': '', 'OUTPUT': 'TEMPORARY_OUTPUT',
                          'TARGET_CRS': QgsProject.instance().crs().authid()}
            try:
                fcc = processing.run('gdal:translate', parametros)['OUTPUT']
                rlayer1 = QgsRasterLayer(fcc, "fcc")
                QgsProject.instance().addMapLayers([rlayer1])
                entries = []
                layer1 = QgsRasterCalculatorEntry()
                layer1.ref = 'layer1@1'
                layer1.raster = rlayer1
                layer1.bandNumber = 1
                entries.append(layer1)
                # mayor de umbral
                output_raster = carpeta + "/" + troncoresumido + '_fcc.tif'
                calc = QgsRasterCalculator('(layer1@1 < 0 ) * 0 +(layer1@1 >= 0 ) * layer1@1 ', output_raster,
                                           'GTiff', rlayer1.extent(),
                                           rlayer1.width(),
                                           rlayer1.height(), entries)
                calc.processCalculation()
                rlayer2 = QgsRasterLayer(output_raster, "fcc")
                # QgsProject.instance().addMapLayers([rlayer2])
                # HASTA AQUI EL NUEVO  FCC DE 0 COMO MINIMO, SIN NO DATA
                if not Layer:
                    print("fallo carga de capa")
            except:
                iface.messageBar().pushMessage("SILVILIDAR",
                                               "Es necesario tener activado el complemento procesos. Si se reinicia QGIS, se activará automáticamente.",
                                               duration=10)
                time.sleep(10)"""

            # nuevo matorral 0.5-2   OJO_____________________________________________________________________________________________________________
            # ____________________para que no pierda tiempo s solo lo crea si lo tienes puesto como salida.
            if self.dlg4.checkBox_matorral.isChecked():
                #print2("voy a crear el matorral")
                funcion_fcc = "c:/fusion/Cover"
                salida_fcc = os.path.join(carpeta, tronco + "_fcc_matorral.dtm")
                h_min_matorral = '0.5'#'0.5'  OJO DESHACER
                h_max_matorral = '2'#'2' OJO DESHACER
                config_upper = "/upper:{h_max_matorral}".format(h_max_matorral=h_max_matorral)
                total_fcc = funcion_fcc + " " + config_upper + " " + salida2 + " " + salida_fcc + " " + h_min_matorral + " " + parametros2 + " " + entrada1
                print(total_fcc)
                os.system(total_fcc)
                salida_fcc_ascii = os.path.join(carpeta, tronco + "_fcc_matorral.asc")
                total_fcc2 = "c:/fusion/DTM2ASCII /raster" + " " + salida_fcc + " " + salida_fcc_ascii
                print(total_fcc2)
                os.system(total_fcc2)
                # cargo  raster fcc
                fileName = total_fcc2
                Layer = QgsRasterLayer(fileName, "fcc_matorral")
                # QgsProject.instance().addMapLayers([Layer])
                # nuevo para convertir nodata a fcc de 0
                parametros = {'COPY_SUBDATASETS': False, 'DATA_TYPE': 0, 'EXTRA': '', 'INPUT': salida_fcc_ascii,
                              'NODATA': -1000, 'OPTIONS': '', 'OUTPUT': 'TEMPORARY_OUTPUT',
                              'TARGET_CRS': QgsProject.instance().crs().authid()}
                try:
                    fccmatorral = processing.run('gdal:translate', parametros)['OUTPUT']
                    rlayer1 = QgsRasterLayer(fccmatorral, "fccmatorral")
                    QgsProject.instance().addMapLayers([rlayer1])
                    entries = []
                    layer1 = QgsRasterCalculatorEntry()
                    layer1.ref = 'layer1@1'
                    layer1.raster = rlayer1
                    layer1.bandNumber = 1
                    entries.append(layer1)
                    # mayor de umbral
                    output_raster = carpeta + "/" + troncoresumido + '_FCC_Matorral.tif'
                    calc = QgsRasterCalculator('(layer1@1 < 0 ) * 0 +(layer1@1 >= 0 ) * layer1@1 ', output_raster,
                                               'GTiff', rlayer1.extent(),
                                               rlayer1.width(),
                                               rlayer1.height(), entries)
                    calc.processCalculation()
                    rlayer2 = QgsRasterLayer(output_raster, "fccmatorral")
                    # QgsProject.instance().addMapLayers([rlayer2])
                    # HASTA AQUI EL NUEVO MATORRAL CON FCC DE 0 COMO MINIMO, SIN NO DATA
                    if not Layer:
                        print("fallo carga de capa")
                except:
                    iface.messageBar().pushMessage("SILVILIDAR",
                                                   "Es necesario tener activado el complemento procesos. Si se reinicia QGIS, se activará automáticamente.",
                                                   duration=10)
                    time.sleep(10)

            # cargo  raster fcc
            fileName = salida5
            Layer = QgsRasterLayer(fileName, "fcc")
            QgsProject.instance().addMapLayers([Layer])
            if not Layer:
                print("fallo carga de capa")

                # creo lista vacia entries
            entries = []

            # cargo  raster fcc_
            """fileName = salida5_
            Layer = QgsRasterLayer(fileName, "fcc_")
            QgsProject.instance().addMapLayers([Layer])
            if not Layer:
                print("fallo carga de capa")

                # creo lista vacia entries
            entries = []"""
            entries = []
            # funcion que carga una capa y prepara la banda para operar con ella
            def StringToRaster(raster, banda):
                fileInfo = QFileInfo(raster)
                path = fileInfo.filePath()
                baseName = fileInfo.baseName()
                global layerglobal
                layerglobal = QgsRasterLayer(path, baseName)
                QgsProject.instance().addMapLayer(layerglobal)
                if layerglobal.isValid() is True:
                    bandaref = str(banda) + '@1'
                    # Define band1
                    banda = QgsRasterCalculatorEntry()
                    banda.ref = bandaref
                    banda.raster = layerglobal
                    banda.bandNumber = 1
                    entries.append(banda)
                else:
                    print("Unable to read basename and file path - Your string is probably invalid" + str(baseName))

            # defino funcion para hacer calculo de capas raster
            def calculo(expresion, capa):
                global layerglobal
                calc = QgsRasterCalculator(expresion,
                                           os.path.join(carpeta, troncoresumido + '_' + capa + '.tif'),
                                           'GTiff',
                                           layerglobal.extent(),
                                           layerglobal.width(),
                                           layerglobal.height(),
                                           entries)

                calc.processCalculation()
                del (calc)

            # defino funcion para crear una capa shape que generalice los datos de un raster    filtro es el nivel de generalizacion entre 0 y 1
            def agregado(rasterdeentrada, filtro):
                # filtro para rellenar huecos
                print("empieza agregado")
                # horaempiezaagregado = time.time()
                # suavizado
                input1 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '1.tif')
                output1 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.sdat')
                parametros = {'INPUT': input1, 'METHOD': 0, 'MODE': 1, 'RADIUS': 4, 'RESULT': output1}
                suavizado = processing.run('saga:simplefilter', parametros)['RESULT']
                rlayer1 = QgsRasterLayer(suavizado, "suavizado")
                StringToRaster(output1, 'rlayer1')

                # mayor de umbral
                output2 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '3.tif')
                calc = QgsRasterCalculator('(rlayer1@1 > 0.3 )', output2, 'GTiff', rlayer1.extent(), rlayer1.width(),
                                           rlayer1.height(), entries)
                calc.processCalculation()
                rlayer2 = QgsRasterLayer(output2, "suavizado_seleccionado")
                StringToRaster(output2, 'rlayer2')
                # time.sleep(0.5)
                # QgsProject.instance().addMapLayers([rlayer2])

                # suavizado2
                print(output2)
                output3 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '4.sdat')
                print(output3)
                parametros = {'INPUT': output2, 'METHOD': 0, 'MODE': 1, 'RADIUS': 2, 'RESULT': output3}
                suavizado2 = processing.run('saga:simplefilter', parametros)['RESULT']
                rlayer3 = QgsRasterLayer(suavizado2, "suavizado2")
                StringToRaster(output3, 'rlayer3')

                # mayor de umbral
                output4 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '5.tif')
                calc = QgsRasterCalculator('(rlayer3@1 > 0.55 )', output4, 'GTiff', rlayer3.extent(),
                                           rlayer3.width(),
                                           rlayer3.height(), entries)
                calc.processCalculation()
                rlayer4 = QgsRasterLayer(output4, "suavizado_seleccionado2")
                QgsProject.instance().addMapLayers([rlayer4])

                # lo vectorizo
                print("paso9 de agregado")
                parameters = {'INPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '5.tif'),
                              'BAND': 1, 'FIELD': "DN", 'EIGHT_CONNECTEDNESS': False,
                              'OUTPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '.shp')}
                processing.runAndLoadResults("gdal:polygonize", parameters)
                # processing.runalg("gdalogr:polygonize",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'7.tif'),"DN",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'))
                # seleciono lo que me interesa
                print("paso10 de agregado")
                lyr = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '.shp'),
                                     rasterdeentrada, "ogr")
                ##QgsProject.instance().addMapLayers([lyr]) #ojo no me hace falta cargarlo dos veces
                """selection = lyr.getFeatures(QgsFeatureRequest().setFilterExpression(u'"DN" = 1'))
                    ##selecionado = lyr.setSelectedFeatures([s.id() for s in selection])
                    selecionado = lyr.selectByIds([s.id() for s in selection])
                    nbrSelected=lyr.selectedFeatureCount()
                    print ("selecionados")
                    print (nbrSelected)
                    print ([s.id() for s in selection])"""

                # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces.
                layer = lyr  # iface.activeLayer()
                print("paso11 de agregado")
                expression = QgsExpression(u'"DN" = 1')
                print("paso12 de agregado")
                # Added / changed lines ##########
                context = QgsExpressionContext()
                scope = QgsExpressionContextScope()
                context.appendScope(scope)
                print("paso13 de agregado")
                layer = lyr
                feats = []
                ids = []
                for feat in layer.getFeatures():
                    scope.setFeature(feat)
                    result = expression.evaluate(context)
                    if result:
                        feats.append(feat)
                        ids.append(feat.id())
                        # areas.append(feat.geometry().area() )
                ################
                # horaacabaagregado0 = time.time()
                # print("tiempo agregado0")
                # print(horaempiezaagregado - horaacabaagregado0)
                if len(ids) > 0:
                    # print ("len feats")
                    # print( len( feats))
                    print("paso14 de agregado")

                    # prov.addFeatures(feats)
                    lyr.selectByIds(ids)
                    # lyr es la capa de entrada, la origen ue contiene todos los elementos
                    output_path = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.shp')
                    QgsVectorFileWriter.writeAsVectorFormat(lyr, output_path, "CP120", lyr.crs(), "ESRI Shapefile",
                                                            onlySelected=True)
                    lyr2 = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.shp'),
                                          rasterdeentrada + str("2"), "ogr")
                    QgsProject.instance().addMapLayer(lyr2)
                    print("en teoria ha hecho la seleccion")

                    # if nbrSelected > 0:
                    # guardo lo selecionado
                    """print ("pasa por aqui")
                        #params={ 'INPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'), 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                        params={ 'INPUT' : mem_layer, 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                        processing.run("qgis:saveselectedfeatures",params)"""

                    # calcula la superficie de esta capa pero no en todos los registros
                    layer = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.shp'),
                                           rasterdeentrada + str("2"), "ogr")
                    # layer=lyr2
                    provider = layer.dataProvider()
                    print("layer get features")
                    # for feat in layer.getFeatures():
                    # print ("feat")
                    # print (feat)
                    areas = [feat.geometry().area() for feat in layer.getFeatures()]
                    # print (areas)
                    indice = [feat.id() for feat in layer.getFeatures()]
                    # print (indice)
                    field = QgsField("area", QVariant.Int)
                    provider.addAttributes([field])
                    layer.updateFields()
                    # idx = layer.fieldNameIndex('area')
                    idx = layer.fields().indexFromName('area')  ###ojo aqui es donde da cero el indice
                    long = len(indice)
                    print("long")
                    print(long)
                    i = 0
                    print("pasa por aqui2")
                    while i < long:
                        new_values = {idx: float(areas[i])}
                        # print ("pasa por aqui3")
                        provider.changeAttributeValues({indice[i]: new_values})
                        # print ("pasa por aqui4")
                        i = i + 1
                    layer.updateFields()
                    print("pasa por aqui5")

                    # selecciono las teselas mayor de una superficie dada.
                    # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces.
                    # layer2 = layer #iface.activeLayer()
                    print("paso11 de agregado")
                    expression = QgsExpression(u'"area" > 2500')
                    print("paso12 de agregado")
                    # Added / changed lines ##########
                    context = QgsExpressionContext()
                    scope = QgsExpressionContextScope()
                    context.appendScope(scope)

                    feats = []
                    ids = []
                    for feat in layer.getFeatures():
                        scope.setFeature(feat)
                        result = expression.evaluate(context)
                        if result:
                            feats.append(feat)
                            ids.append(feat.id())
                            # areas.append(feat.geometry().area() )
                    ################
                    if len(ids) > 0:
                        # print ("len feats")
                        # print( len( feats))
                        print("paso14 de agregado")
                        # prov.addFeatures(feats)
                        lyr2.selectByIds(ids)
                        # lyr es la capa de entrada, la origen ue contiene todos los elementos
                        output_path = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '3.shp')
                        QgsVectorFileWriter.writeAsVectorFormat(lyr2, output_path, "CP120", lyr.crs(), "ESRI Shapefile",
                                                                onlySelected=True)
                        lyr3 = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '3.shp'),
                                              rasterdeentrada + str("3"), "ogr")
                        QgsProject.instance().addMapLayer(lyr3)
                        print("en teoria ha hecho la seleccion2")
                        # horaacabaagregado1 = time.time()
                        # print("tiempoacabaagregado1")
                        # print(horaacabaagregado1 - horaacabaagregado0)

                    # else:
                    #   print("pass en el agregado")
                    #  pass
                    # del(selection)
                    # del(selecionado)
            def agregado2(rasterdeentrada, radio, filtro):

                        # filtro para rellenar huecos
                        print("empieza agregado")
                        # horaempiezaagregado = time.time()
                        #A puntos
                        input1 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '1.tif')
                        output1 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '0.shp')
                        apuntos=processing.runAndLoadResults("native:pixelstopoints", {
                            'INPUT_RASTER': input1,
                            'RASTER_BAND': 1, 'FIELD_NAME': 'VALUE', 'OUTPUT': output1})['OUTPUT']
                        #mapa de calor
                        output2 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.tif')
                        mapacalor=processing.run("qgis:heatmapkerneldensityestimation", {
                            'INPUT': output1,
                            'RADIUS': radio, 'RADIUS_FIELD': '', 'PIXEL_SIZE': 2, 'WEIGHT_FIELD': 'VALUE', 'KERNEL': 3,
                            'DECAY': None, 'OUTPUT_VALUE': 0, 'OUTPUT': output2})['OUTPUT']
                        rlayer0 = QgsRasterLayer(mapacalor, "mapacalor")
                        StringToRaster(output2, 'rlayer0')

                        #mayor de 1
                        # mayor de umbral
                        output44 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '44.tif')
                        calc = QgsRasterCalculator('(rlayer0@1 > {} )'.format(filtro), output44, 'GTiff', rlayer0.extent(),
                                                   rlayer0.width(),
                                                   rlayer0.height(), entries)
                        calc.processCalculation()
                        rlayer44 = QgsRasterLayer(output44, "mapacalor_seleccionado")




                        # QgsProject.instance().addMapLayers([rlayer4])
                        # suavizado
                        #input1 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '1.tif')
                        #output1 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.tif')
                        #suavizado = processing.run("gdal:sieve",
                        #               {'INPUT': input1, 'THRESHOLD': 8,
                        #                'EIGHT_CONNECTEDNESS': True, 'NO_MASK': False, 'MASK_LAYER': None, 'EXTRA': '',
                        #                'OUTPUT': output1})['RESULT']
                        #print(suavizado)



                        #rlayer1 = QgsRasterLayer(suavizado, "suavizado")
                        #StringToRaster(output1, 'rlayer1')

                        # mayor de umbral
                        #output2 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '3.tif')
                        #calc = QgsRasterCalculator('(rlayer1@1 > 0.3 )', output2, 'GTiff', rlayer1.extent(),
                                                   #rlayer1.width(), rlayer1.height(), entries)
                        #calc.processCalculation()
                        #rlayer2 = QgsRasterLayer(output2, "suavizado_seleccionado")
                        #StringToRaster(output2, 'rlayer2')
                        # time.sleep(0.5)
                        # QgsProject.instance().addMapLayers([rlayer2])

                        # suavizado2
                        #print(output2)
                        #output3 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '4.sdat')
                        #print(output3)
                        #parametros = {'INPUT': output2, 'METHOD': 0, 'MODE': 1, 'RADIUS': 2, 'RESULT': output3}
                        #suavizado2 = processing.run('saga:simplefilter', parametros)['RESULT']
                        #rlayer3 = QgsRasterLayer(suavizado2, "suavizado2")
                        #StringToRaster(output3, 'rlayer3')

                        # mayor de umbral
                        #output4 = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '5.tif')
                        #calc = QgsRasterCalculator('(rlayer3@1 > 0.55 )', output4, 'GTiff', rlayer3.extent(),
                        #                           rlayer3.width(),
                        #                           rlayer3.height(), entries)
                        #calc.processCalculation()
                        #rlayer4 = QgsRasterLayer(output4, "suavizado_seleccionado2")
                        #QgsProject.instance().addMapLayers([rlayer4])

                        # lo vectorizo
                        print("paso9 de agregado")
                        parameters = {'INPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '44.tif'),
                                      'BAND': 1, 'FIELD': "DN", 'EIGHT_CONNECTEDNESS': True,
                                      'OUTPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '00.shp')}
                        processing.runAndLoadResults("gdal:polygonize", parameters)
                        # processing.runalg("gdalogr:polygonize",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'7.tif'),"DN",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'))
                        # seleciono lo que me interesa
                        print("paso10 de agregado")
                        lyr = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '00.shp'),
                                             rasterdeentrada, "ogr")

                        # delete holes
                        deleteholes = processing.runAndLoadResults("native:deleteholes", {
                            'INPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '00.shp'),
                            'MIN_AREA': 400, 'OUTPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '000.shp')})['OUTPUT']
                        lyr = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '000.shp'),
                                             rasterdeentrada, "ogr")

                        #SUAVIZA
                        processing.runAndLoadResults("native:smoothgeometry", {
                            'INPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '000.shp'),
                            'ITERATIONS': 2, 'OFFSET': 0.4, 'MAX_ANGLE': 180, 'OUTPUT': os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '.shp')})
                        lyr = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '.shp'),
                                             rasterdeentrada, "ogr")

                        ##QgsProject.instance().addMapLayers([lyr]) #ojo no me hace falta cargarlo dos veces
                        """selection = lyr.getFeatures(QgsFeatureRequest().setFilterExpression(u'"DN" = 1'))
                            ##selecionado = lyr.setSelectedFeatures([s.id() for s in selection])
                            selecionado = lyr.selectByIds([s.id() for s in selection])
                            nbrSelected=lyr.selectedFeatureCount()
                            print ("selecionados")
                            print (nbrSelected)
                            print ([s.id() for s in selection])"""

                        # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces.
                        layer = lyr  # iface.activeLayer()
                        print("paso11 de agregado")
                        expression = QgsExpression(u'"DN" = 1')
                        print("paso12 de agregado")
                        # Added / changed lines ##########
                        context = QgsExpressionContext()
                        scope = QgsExpressionContextScope()
                        context.appendScope(scope)
                        print("paso13 de agregado")
                        layer = lyr
                        feats = []
                        ids = []
                        for feat in layer.getFeatures():
                            scope.setFeature(feat)
                            result = expression.evaluate(context)
                            if result:
                                feats.append(feat)
                                ids.append(feat.id())
                                # areas.append(feat.geometry().area() )
                        ################
                        # horaacabaagregado0 = time.time()
                        # print("tiempo agregado0")
                        # print(horaempiezaagregado - horaacabaagregado0)
                        if len(ids) > 0:
                            # print ("len feats")
                            # print( len( feats))
                            print("paso14 de agregado")

                            # prov.addFeatures(feats)
                            lyr.selectByIds(ids)
                            # lyr es la capa de entrada, la origen ue contiene todos los elementos
                            output_path = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.shp')
                            QgsVectorFileWriter.writeAsVectorFormat(lyr, output_path, "CP120", lyr.crs(),
                                                                    "ESRI Shapefile",
                                                                    onlySelected=True)
                            lyr2 = QgsVectorLayer(
                                os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.shp'),
                                rasterdeentrada + str("2"), "ogr")
                            QgsProject.instance().addMapLayer(lyr2)
                            print("en teoria ha hecho la seleccion")

                            # if nbrSelected > 0:
                            # guardo lo selecionado
                            """print ("pasa por aqui")
                                #params={ 'INPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'), 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                                params={ 'INPUT' : mem_layer, 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                                processing.run("qgis:saveselectedfeatures",params)"""

                            # calcula la superficie de esta capa pero no en todos los registros
                            layer = QgsVectorLayer(
                                os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '2.shp'),
                                rasterdeentrada + str("2"), "ogr")
                            # layer=lyr2
                            provider = layer.dataProvider()
                            print("layer get features")
                            # for feat in layer.getFeatures():
                            # print ("feat")
                            # print (feat)
                            areas = [feat.geometry().area() for feat in layer.getFeatures()]
                            # print (areas)
                            indice = [feat.id() for feat in layer.getFeatures()]
                            # print (indice)
                            field = QgsField("area", QVariant.Int)
                            provider.addAttributes([field])
                            layer.updateFields()
                            # idx = layer.fieldNameIndex('area')
                            idx = layer.fields().indexFromName('area')  ###ojo aqui es donde da cero el indice
                            long = len(indice)
                            print("long")
                            print(long)
                            i = 0
                            print("pasa por aqui2")
                            while i < long:
                                new_values = {idx: float(areas[i])}
                                # print ("pasa por aqui3")
                                provider.changeAttributeValues({indice[i]: new_values})
                                # print ("pasa por aqui4")
                                i = i + 1
                            layer.updateFields()
                            print("pasa por aqui5")

                            # selecciono las teselas mayor de una superficie dada.
                            # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces.
                            # layer2 = layer #iface.activeLayer()
                            print("paso11 de agregado")
                            expression = QgsExpression(u'"area" > 2500')
                            print("paso12 de agregado")
                            # Added / changed lines ##########
                            context = QgsExpressionContext()
                            scope = QgsExpressionContextScope()
                            context.appendScope(scope)

                            feats = []
                            ids = []
                            for feat in layer.getFeatures():
                                scope.setFeature(feat)
                                result = expression.evaluate(context)
                                if result:
                                    feats.append(feat)
                                    ids.append(feat.id())
                                    # areas.append(feat.geometry().area() )
                            ################
                            if len(ids) > 0:
                                # print ("len feats")
                                # print( len( feats))
                                print("paso14 de agregado")
                                # prov.addFeatures(feats)
                                lyr2.selectByIds(ids)
                                # lyr es la capa de entrada, la origen ue contiene todos los elementos
                                output_path = os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '3.shp')
                                QgsVectorFileWriter.writeAsVectorFormat(lyr2, output_path, "CP120", lyr.crs(),
                                                                        "ESRI Shapefile",
                                                                        onlySelected=True)
                                lyr3 = QgsVectorLayer(
                                    os.path.join(carpeta, troncoresumido + '_' + rasterdeentrada + '3.shp'),
                                    rasterdeentrada + str("3"), "ogr")
                                QgsProject.instance().addMapLayer(lyr3)
                                print("en teoria ha hecho la seleccion2")
                                # horaacabaagregado1 = time.time()
                                # print("tiempoacabaagregado1")
                                # print(horaacabaagregado1 - horaacabaagregado0)

                    # else:
                    #   print("pass en el agregado")
                    #  pass
                    # del(selection)
                    # del(selecionado)
            # except:
            #   pass
            # calculo las variables basicas sin proyectar
            #if self.dentro == False:
            print("empieza calculo las variables basicas sin proyectar")
            # horaepiezacalculovariabesbasicas = time.time()
            print("horaepiezacalculovariabesbasicas")
            StringToRaster(salida5, "fcc")
            calculo('fcc@1', "fcc")
            #StringToRaster(salida5_, "fcc_")
            # calculo('fcc_@1', "fcc_")
            StringToRaster(salida4, "hm")
            calculo('hm@1', "hm")
            StringToRaster(salida100, "hbc")
            calculo('hbc@1', "hbc")
            calculo('100 * ( hm@1 - hbc@1 ) / hm@1', "rc")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_rc.tif'), "rc")
            calculo(' hm@1 - hbc@1 ', "lc")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_lc.tif'), "lc")

            if version_fusion_4_40():
                StringToRaster(salida101, "profile")
                calculo('profile@1', "profile")
            # StringToRaster(salida102, "skweness")
            # calculo('skweness@1', "skweness")

            #

                


            print("voy a proyectar")
            # genero una carpeta para los datos intermedios
            carpetap = os.path.join(carpeta, "p")
            carpeta = carpetap
            if not os.path.exists(carpetap):
                os.mkdir(carpetap)
            # proyecto la altura con el crecimiento
            calculo('(hm@1 < 6) * hm@1 + (hm@1 >= 6) * (hm@1 + ' + str(crecimiento) + ')', 'hmp')
            StringToRaster(os.path.join(carpeta, troncoresumido + '_hmp.tif'), "hmp")
            # proyecto la altura  de la base de la copa con el crecimiento
            calculo('(hm@1 < 7.5) * hbc@1 + (hm@1 >= 7.5) * (hbc@1 + ' + str(crecimiento) + ')', 'hbcp')
            StringToRaster(os.path.join(carpeta, troncoresumido + '_hbcp.tif'), "hbcp")
            # calculo  la razon de copa una vez proyectada la altura y la base de la copa
            calculo('100 * ( hmp@1   -  hbcp@1  ) / ( hmp@1 )', 'rcp')
            StringToRaster(os.path.join(carpeta, troncoresumido + '_rcp.tif'), "rcp")
            # proyecto la fraccion de cabida cubierta
            calculo('(' + str(crecimiento) + ' > 0) * (fcc@1  + ' + str(crecimientofcc) + ') + ( ' + str(
                crecimiento) + ' = 0) * (fcc@1 )', 'fccp')
            StringToRaster(os.path.join(carpeta, troncoresumido + '_fccp.tif'), "fccp")
            # proyecto la longitud de copa
            calculo('(hmp@1 - hbcp@1)', 'lcp')
            StringToRaster(os.path.join(carpeta, troncoresumido + '_lcp.tif'), "lcp")

            # introduzco los condicionantes para cada tipo de masa

            """calculo('(fccp@1 <= ' + str(fccbaja) + ') * 1 ', 'C1')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 < ' + str(hmontebravoe) + ')*2', 'C2')
            calculo('(fccp@1 >= ' + str(fccmedia) + ')*(hmp@1 >= ' + str(hmontebravoe) + ')*(hmp@1 < ' + str(
                hmontebravo) + ')*(rcp@1 <= ' + str(rcclaras) + ')*51', 'C3')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 >= ' + str(hmontebravoe) + ')*(hmp@1 < ' + str(
                hmontebravo) + ')*(rcp@1 <= ' + str(rcclaras) + ')*(fccp@1 < ' + str(fccmedia) + ')*61', 'C4')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 >= ' + str(hmontebravoe) + ')*(hmp@1 < ' + str(
                hmontebravo) + ')*(rcp@1 > ' + str(rcclaras) + ')*17', 'C5')
            calculo('(fccp@1 >= ' + str(fccalta) + ')*(hmp@1 >= ' + str(hmontebravo) + ')*(hmp@1 <= ' + str(
                hselvicolas) + ')*(rcp@1 <= ' + str(rcclaras) + ')*52', 'C8')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 >= ' + str(hmontebravo) + ')*(hmp@1 <= ' + str(
                hselvicolas) + ')*(rcp@1 <= ' + str(rcclaras) + ')*(fccp@1 < ' + str(fccalta) + ')*62', 'C9')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 >= ' + str(hmontebravo) + ')*(hmp@1 <= ' + str(
                hselvicolas) + ')*(rcp@1 > ' + str(rcclaras) + ')*(hbcp@1 <= ' + str(hbcminima) + ')*3', 'C6')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 >= ' + str(hmontebravo) + ')*(hmp@1 <= ' + str(
                hselvicolas) + ')*(rcp@1 > ' + str(rcclaras) + ')*(hbcp@1 > ' + str(hbcminima) + ')*4', 'C7')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 <= ' + str(hbcdesarrollado) + ')*7', 'C10')
            # formula terrazas
            formula = '(0.1167 * fccp@1 + 3.6667 ) * hmp@1 ^ 1.04328809 * ( hmp@1 - hbcp@1) ^ (-0.49505946)'
            calculo('(fccp@1 > ' + str(fccterrazas) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(rcclaras) + ')*(lcp@1 > ' + str(
                longitudcopaminima) + ')*(fccp@1 >= ' + str(formula) + ')*81', 'C11')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(
                rcclaras) + ')*(lcp@1 <= ' + str(longitudcopaminima) + ')*7', 'C12')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(rcclaras) + ')*(lcp@1 > ' + str(
                longitudcopaminima) + ')*(fccp@1 <= ' + str(fccterrazas) + ')*7', 'C13')
            calculo('(fccp@1 >= ' + str(fccalta) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(rcclaras) + ')*(lcp@1 > ' + str(
                longitudcopaminima) + ')*(fccp@1 < ' + str(formula) + ')*81', 'C15')
            calculo('(fccp@1 >= ' + str(fccterrazas) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(rcclaras) + ')*(lcp@1 > ' + str(
                longitudcopaminima) + ')*(fccp@1 < ' + str(formula) + ')*(fccp@1 < ' + str(fccalta) + ')*10', 'C16')
            calculo('(fccp@1 >= ' + str(fccalta) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 < ' + str(rcclaras) + ')*9', 'C14')
            calculo('(fccp@1 > 20)*(fccp@1 < ' + str(fccalta) + ')*(hmp@1 > ' + str(hselvicolas) + ')*(hmp@1 <= ' + str(
                hclaras) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 < ' + str(rcclaras) + ')*10', 'C17')
            calculo('(fccp@1 > 20)*(hmp@1 > ' + str(hclaras) + ')*(hmp@1 <= ' + str(hclaras2) + ')*(hbcp@1 <= ' + str(
                hbcdesarrollado) + ')*111', 'C18')
            calculo('(fccp@1 >= ' + str(fccterrazas) + ')*(hmp@1 > ' + str(hclaras) + ')*(hmp@1 <= ' + str(
                hclaras2) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(
                rcclaras) + ')*(lcp@1 > ' + str(longitudcopaminima) + ')*(fccp@1 > ' + str(formula) + ')*82', 'C19')
            calculo('(fccp@1 >= 20)*(hmp@1 > ' + str(hclaras) + ')*(hmp@1 <= ' + str(hclaras2) + ')*(hbcp@1 > ' + str(
                hbcdesarrollado) + ')*(rcp@1 >= ' + str(rcclaras) + ')*(lcp@1 <= ' + str(longitudcopaminima) + ')*111',
                    'C30')
            calculo('(fccp@1 >= 20)*(hmp@1 > ' + str(hclaras) + ')*(hmp@1 <= ' + str(hclaras2) + ')*(hbcp@1 > ' + str(
                hbcdesarrollado) + ')*(rcp@1 >= ' + str(rcclaras) + ')*(lcp@1 > ' + str(
                longitudcopaminima) + ')*(fccp@1 <=' + str(fccterrazas) + ')*111', 'C29')
            calculo('(fccp@1 >= ' + str(fccalta) + ')*(hmp@1 > ' + str(hclaras) + ')*(hmp@1 <= ' + str(
                hclaras2) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(
                rcclaras) + ')*(lcp@1 > ' + str(longitudcopaminima) + ')*(fccp@1 < ' + str(formula) + ')*82', 'C21')
            calculo('(fccp@1 > ' + str(fccterrazas) + ')*(hmp@1 > ' + str(hclaras) + ')*(hmp@1 <= ' + str(
                hclaras2) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 >= ' + str(
                rcclaras) + ')*(lcp@1 > ' + str(longitudcopaminima) + ')*(fccp@1 < ' + str(
                fccalta) + ')*(fccp@1 < ' + str(formula) + ')*111', 'C22')
            calculo('(fccp@1 >= ' + str(fccalta) + ')*(hmp@1 > ' + str(hclaras) + ')*(hmp@1 <= ' + str(
                hclaras2) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 < ' + str(rcclaras) + ')*121', 'C20')
            calculo('(fccp@1 > ' + str(fccbaja) + ')*(fccp@1 < ' + str(fccalta) + ')*(hmp@1 > ' + str(
                hclaras) + ')*(hmp@1 <= ' + str(hclaras2) + ')*(hbcp@1 > ' + str(hbcdesarrollado) + ')*(rcp@1 < ' + str(
                rcclaras) + ')*141', 'C23')
            calculo(
                '(fccp@1 >= ' + str(fccalta) + ')*(hmp@1 > ' + str(hclaras2) + ')*(rcp@1 <= ' + str(rcextremo) + ')*13',
                'C26')
            calculo('(fccp@1 < ' + str(fccalta) + ')*(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 > ' + str(
                hclaras2) + ')*(rcp@1 <= ' + str(rcextremo) + ')*15', 'C28')
            calculo('(fccp@1 >= ' + str(fccalta) + ')*(hmp@1 > ' + str(hclaras2) + ')*(rcp@1 > ' + str(
                rcextremo) + ')*(rcp@1 < ' + str(rcclaras) + ')*122', 'C25')
            calculo('(fccp@1 < ' + str(fccalta) + ')*(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 > ' + str(
                hclaras2) + ')*(rcp@1 > ' + str(rcextremo) + ')*(rcp@1 < ' + str(rcclaras) + ')*142', 'C27')
            calculo(
                '(fccp@1 > ' + str(fccbaja) + ')*(hmp@1 > ' + str(hclaras2) + ')*(rcp@1 >= ' + str(rcclaras) + ')*112',
                'C24')

            # primera aproximacion al volumen
            # calculo('((((11.2958099433282 * hmp@1 * fccp@1 / 100 ) + (1.01082625996345 * hbcp@1 * hbcp@1 ))/100) > 10 ) * 10 + ((((11.2958099433282 * hmp@1 * fccp@1 / 100 ) + (1.01082625996345 * hbcp@1 * hbcp@1 ))/100) < 10 ) * (((11.2958099433282 * hmp@1 * fccp@1 / 100 ) + (1.01082625996345 * hbcp@1 * hbcp@1 ))/100) ', 'V')
            # choperas, villar del rio reg
            # calculo('((((21.4317914 * hbcp@1 ) + (20.60721872 * lcp@1 )+(0.2518519 * rcp@1  )+(0.2518519 * fccp@1  )-187.189000655894))>0 ) * ((21.4317914 * hbcp@1 ) + (20.60721872 * lcp@1 )+(0.2518519 * rcp@1  )+(0.2518519 * fccp@1  )-187.189000655894)  / 100 ', 'V')
            # calculo('((((20.53178064 * hbcp@1 ) + (19.99289198 * lcp@1 )+(0 * rcp@1  )+(0.33353309 * fccp@1  )-173.66440197319645))>0 ) * ((20.53178064 * hbcp@1 ) + (19.99289198 * lcp@1 )+(0 * rcp@1  )+(0.33353309 * fccp@1  )-173.66440197319645)  / 100 ', 'V')
            calculo(
                '((((0.12252633 * hbcp@1 ) + (20.95164119 * hmp@1 )+(0 * rcp@1  )+(0.21333922 * fccp@1  )-177.824382869595))>0 ) * ((0.12252633 * hbcp@1 ) + (20.95164119 * hmp@1 )+(0 * rcp@1  )+(0.21333922 * fccp@1  )-177.824382869595)  / 100 ',
                'V')

            StringToRaster(os.path.join(carpeta, troncoresumido + '_V.tif'), "vol")

            # horaepiezacalculotiposdemasa = time.time()
            # print("tiempo en raster")
            # print(horaepiezacalculotiposdemasa - horaepiezacalculovariabesbasicas)
            # empiezo carga de capas c
            print("empieza cargadecapastipos")
            # horaepiezacargadecapastipos = time.time()
            # print(horaepiezacargadecapastipos)
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C1.tif'), "c1")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C2.tif'), "c2")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C3.tif'), "c3")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C4.tif'), "c4")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C5.tif'), "c5")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C6.tif'), "c6")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C7.tif'), "c7")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C8.tif'), "c8")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C9.tif'), "c9")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C10.tif'), "c10")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C11.tif'), "c11")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C12.tif'), "c12")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C13.tif'), "c13")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C14.tif'), "c14")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C15.tif'), "c15")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C16.tif'), "c16")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C17.tif'), "c17")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C18.tif'), "c18")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C19.tif'), "c19")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C20.tif'), "c20")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C21.tif'), "c21")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C22.tif'), "c22")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C23.tif'), "c23")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C24.tif'), "c24")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C25.tif'), "c25")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C26.tif'), "c26")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C27.tif'), "c27")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C28.tif'), "c28")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C29.tif'), "c29")
            StringToRaster(os.path.join(carpeta, troncoresumido + '_C30.tif'), "c30")
            # sumo todas las capas c
            calculo(
                'c1@1 + c2@1 + c3@1 + c4@1 + c5@1 + c6@1 + c7@1 + c8@1+ c9@1+ c10@1+ c11@1 + c12@1 + c13@1 + c14@1 + c15@1 + c16@1 + c17@1 + c18@1 + c19@1 + c20@1 + c21@1 + c22@1+ c23@1 + c24@1 + c25@1 + c26@1 + c27@1 + c28@1+ c29@1 + c30@1',
                'suma')
            StringToRaster(os.path.join(carpeta, troncoresumido + '_suma.tif'), "suma")

            # lo vectorizo
            parameters = {'INPUT': os.path.join(carpeta, troncoresumido + '_suma.tif'), 'BAND': 1, 'FIELD': "DN",
                          'EIGHT_CONNECTEDNESS': False, 'OUTPUT': os.path.join(carpeta,
                                                                             troncoresumido + '_suma.shp')}"""  # ojo mirar si hay que quitar el eight connectedness
            # METODO ALEJANDRO
            """fccminarbolado=str(10)
            alturadesconocida=str(2)
            hmaxmontebravo=str(3.5)
            hmaxbajolatizal=str(5)
            rcminresalveoencinarlatizalpocodesarrollado=str(40)
            fccmincompetenciaencinarlatizalpocodesarrollado=str(50)
            hmaxselvicolas=str(7.5)
            rcminresalveoencinarlatizaldesarrollado=str(50)
            hbcpodabaja=str(3)
            hbcdesconocido=str(5.5)
            rcminresalveoencinarfustal=str(60)
            fccmincompetenciamasadiscontinua_fustalencinares=str(57.5)
            rcminclara=str(35)
            longitudcopaminclara=str(3.25)
            fcccompetenciaelevada=str(95)
            hmaxsegundaclara=str(16.5)
            hbcminclarasnormales=str(5.5)
            fccmincompetenciaencinarlatizaldesarrollado=str(55)
            hmaxprimeraclara=str(12)
            rccoronado=str(17)"""

            #OJO PARA METER LA FORMULA PARA UNA VARIABLE
            #hmaxprimeraclara='hmaxprimeraclara+5'.replace('hmaxprimeraclara',str(hmaxprimeraclara))
            #if not isinstance(rcminresalveoencinarlatizalpocodesarrollado, (int, float)):
            #    rcminresalveoencinarlatizalpocodesarrollado=rcminresalveoencinarlatizalpocodesarrollado.replace('HM',str('hmp@1'))#-0, 485950210654347 * HM ^ 2 + 10, 9071549372235 * HM + 2, 62451053947642
            #hmaxprimeraclara=str(eval(cadena))

            #ojo posible version no actualizada
            print('if (fccp@1 <= 0, 0, if ( fccp@1 < '+fccminarbolado+', 1, if ( hmp@1 < '+alturadesconocida+', 11, if ( hmp@1 < '+hmaxmontebravo+', 2, if ( hmp@1 < '+hmaxbajolatizal+', if ( rcp@1 <= '+rcminresalveoencinarlatizalpocodesarrollado+', if ( fccp@1 > '+fccmincompetenciaencinarlatizalpocodesarrollado+', 51, 61), 17), if (hmp@1 <= '+hmaxselvicolas+', if ( rcp@1 <= '+rcminresalveoencinarlatizalpocodesarrollado+', if ( fccp@1 > '+fccmincompetenciaencinarlatizalpocodesarrollado+', 52, 62) , if ( hmp@1 - hmp@1 * rcp@1 / 100 <= '+hbcpodabaja+', 3, 4)), if ( hmp@1 <= '+hmaxprimeraclara+', if ( hmp@1 - hmp@1 * rcp@1 / 100 <='+hbcminclarasnormales+' , if ( rcp@1 <= '+rcminresalveoencinarlatizalpocodesarrollado+', if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', 77, 7), 7), if ( rcp@1 >= '+rcminclara+', if ( hmp@1 * rcp@1 / 100 > '+longitudcopaminclara+', if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', if ( fccp@1 >= (0.1167 * fccp@1 +3.6667) * ( hmp@1 ^ 1.04328809) * ( hmp@1 * rcp@1 / 100) ^ (-0.49505946), 81, if ( fccp@1 >= '+fcccompetenciaelevada+', 81, 10)), 7), 7), if ( fccp@1 >= '+fcccompetenciaelevada+', 9, if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', 77, 10)))), if ( hmp@1 <= '+hmaxsegundaclara+', if ( hmp@1 - hmp@1 * rcp@1 / 100 <= '+hbcminclarasnormales+', 111, if ( rcp@1 >= '+rcminclara+', if ( hmp@1 * rcp@1 / 100 > '+longitudcopaminclara+', if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', if ( fccp@1 >= (0.1167 * fccp@1 +3.6667) * ( hmp@1 ^ 1.04328809) * ( hmp@1 * rcp@1 / 100) ^ (-0.49505946), 82, if ( fccp@1 >= '+fcccompetenciaelevada+', 82, 111)), 111), 111), if ( fccp@1 >= '+fcccompetenciaelevada+', 121, 141))), if ( rcp@1 <= '+rccoronado+', if ( fccp@1 >= '+fcccompetenciaelevada+', 13, 15), if ( rcp@1 < '+rcminclara+', if ( fccp@1 >= '+fcccompetenciaelevada+', 122, 142), 112))))))))))')
            calculo( 'if (fccp@1 <= 0, 0, if ( fccp@1 < '+fccminarbolado+', 1, if ( hmp@1 < '+alturadesconocida+', 11, if ( hmp@1 < '+hmaxmontebravo+', 2, if ( hmp@1 < '+hmaxbajolatizal+', if ( rcp@1 <= '+rcminresalveoencinarlatizalpocodesarrollado+', if ( fccp@1 > '+fccmincompetenciaencinarlatizalpocodesarrollado+', 51, 61), 17), if (hmp@1 <= '+hmaxselvicolas+', if ( rcp@1 <= '+rcminresalveoencinarlatizalpocodesarrollado+', if ( fccp@1 > '+fccmincompetenciaencinarlatizalpocodesarrollado+', 52, 62) , if ( hmp@1 - hmp@1 * rcp@1 / 100 <= '+hbcpodabaja+', 3, 4)), if ( hmp@1 <= '+hmaxprimeraclara+', if ( hmp@1 - hmp@1 * rcp@1 / 100 <='+hbcminclarasnormales+' , if ( rcp@1 <= '+rcminresalveoencinarlatizalpocodesarrollado+', if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', 77, 7), 7), if ( rcp@1 >= '+rcminclara+', if ( hmp@1 * rcp@1 / 100 > '+longitudcopaminclara+', if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', if ( fccp@1 >= (0.1167 * fccp@1 +3.6667) * ( hmp@1 ^ 1.04328809) * ( hmp@1 * rcp@1 / 100) ^ (-0.49505946), 81, if ( fccp@1 >= '+fcccompetenciaelevada+', 81, 10)), 7), 7), if ( fccp@1 >= '+fcccompetenciaelevada+', 9, if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', 77, 10)))), if ( hmp@1 <= '+hmaxsegundaclara+', if ( hmp@1 - hmp@1 * rcp@1 / 100 <= '+hbcminclarasnormales+', 111, if ( rcp@1 >= '+rcminclara+', if ( hmp@1 * rcp@1 / 100 > '+longitudcopaminclara+', if ( fccp@1 > '+fccmincompetenciamasadiscontinua_fustalencinares+', if ( fccp@1 >= (0.1167 * fccp@1 +3.6667) * ( hmp@1 ^ 1.04328809) * ( hmp@1 * rcp@1 / 100) ^ (-0.49505946), 82, if ( fccp@1 >= '+fcccompetenciaelevada+', 82, 111)), 111), 111), if ( fccp@1 >= '+fcccompetenciaelevada+', 121, 141))), if ( rcp@1 <= '+rccoronado+', if ( fccp@1 >= '+fcccompetenciaelevada+', 13, 15), if ( rcp@1 < '+rcminclara+', if ( fccp@1 >= '+fcccompetenciaelevada+', 122, 142), 112))))))))))', 'suma')
            StringToRaster(os.path.join(carpeta, troncoresumido + '_suma.tif'), "suma")
            parameters = {'INPUT': os.path.join(carpeta, troncoresumido + '_suma.tif'), 'BAND': 1, 'FIELD': "DN",
                          'EIGHT_CONNECTEDNESS': False, 'OUTPUT': os.path.join(carpeta,
                                                                               troncoresumido + '_suma.shp')}
            try:
                processing.run("gdal:polygonize", parameters)
            except:
                iface.messageBar().pushMessage("SILVILIDAR",
                                               "Es necesario tener activado el complemento procesos. Si se reinicia QGIS, se activará automáticamente.",
                                               duration=10)
                time.sleep(10)
            # lyr = QgsVectorLayer(os.path.join(carpeta, troncoresumido + '_suma.shp'), "nombre", "ogr")
            # print2('vectorizado la suma de las capas c')
            # processing.run("gdalogr:polygonize",os.path.join(carpeta,troncoresumido+'_suma.tif'),"DN",os.path.join(carpeta,troncoresumido+'_suma.shp'))
            # sumashp=QgsVectorLayer(os.path.join(carpeta,troncoresumido+'_suma.shp'),"sumashp","ogr")
            # QgsMapLayerRegistry.instance().addMapLayer(sumashp)

            # filtro para quedarme con la clara
            if self.dlg4.checkBox_claras.isChecked():
                #"calculo(
                    #'c11@1 / 81 + c14@1 / 9  + c15@1 / 81 + c19@1 / 82 + c20@1 / 121 + c21@1 / 82 + c25@1 / 122 + c26@1 / 13',
                    #'clara1')
                calculo('("suma@1" = 81 OR "suma@1" = 9 OR "suma@1" = 82 OR "suma@1" = 121 OR "suma@1" = 122 OR "suma@1" = 13) * 1','clara1')  #ojo comprobar si sigue siendo así despues de lo de los encinares
                StringToRaster(os.path.join(carpeta, troncoresumido + '_clara1.tif'), "clara1")
                agregado2("clara", 20, 1)
            # filtro para quedarme con la regeneracion
            if self.dlg4.checkBox_regeneracion.isChecked():
                #calculo('c28@1 / 15 ', 'regeneracion1')
                #cual es el tamaño del pixel a emplear en calculo?, o lo que es lo mismo el numero de columnas y filas
                calculo(
                    '("suma@1" = 15 ) * 1', 'regeneracion1')
                StringToRaster(os.path.join(carpeta, troncoresumido + '_regeneracion1.tif'), "regeneracion1")
                agregado2("regeneracion", 40, 1)  # 10,1
            # filtro para quedarme con el resalveo
            if self.dlg4.checkBox_resalveo.isChecked():
                #calculo('c3@1 / 51 + c8@1 / 52', 'resalveo1')
                calculo('("suma@1" = 51 OR "suma@1" = 52 ) * 1','resalveo1')
                StringToRaster(os.path.join(carpeta, troncoresumido + '_resalveo1.tif'), "resalveo1")
                agregado2("resalveo", 20,1) #30, 0.85)




            # elimino las capas que he cargado durante el proceso
            capas = QgsProject.instance().mapLayers()
            for capa in capas:
                if capa not in capasoriginales:
                    QgsProject.instance().removeMapLayers([capa])

            print("deberia acabar el while true")
            # break  ojo iba con el while true
            print("pero no ha acabado el while true")
            # except:
            # print ("excepcion")
            # pass
            print("acaba exprime lidar")

        # defino una funcion que une en una capa el resultado de todas las hojas
        def juntoshapes(busca, salida):
            print("empieza juntoshapes")
            # horaepiezajuntoshapes = time.time()
            files = glob.glob(busca)
            out = os.path.join(carpeta, salida + ".shp")
            entradas = ";".join(files)
            # entrada=[]
            entrada = files
            print("entrada")
            print(entrada)
            print("entradas")
            print(entradas)
            params = {'LAYERS': entrada, 'OUTPUT': out, 'CRS': QgsProject.instance().crs().authid()}
            if len(files) > 100:
                lista1 = files[:len(files) / 2]
                lista2 = files[len(files) / 2:]
                out = os.path.join(carpeta, salida + "1.shp")
                entrada = ";".join(lista1)
                processing.run('native:mergevectorlayers', params)
                out = os.path.join(carpeta, salida + "2.shp")
                entrada = ";".join(lista2)
                processing.run('native:mergevectorlayers', params)
            elif len(files) > 1 and len(files) <= 100:
                processing.run('native:mergevectorlayers', params)

            elif len(
                    files) == 1:  #### metodo bueno de selecionar y guardar mirar tiempos para ver si esta es mejor a la que tengo en agregate
                layer2 = QgsVectorLayer(files[0], "entrada", "ogr")
                QgsProject.instance().addMapLayers([layer2])
                selection = layer2.getFeatures(QgsFeatureRequest().setFilterExpression(u'"DN" > 0'))
                selecionado = layer2.selectByIds([s.id() for s in selection])
                params = {'INPUT': files[0], 'OUTPUT': out}
                processing.run("native:saveselectedfeatures", params)

            else:
                pass
            del (out)
            del (entrada)
            del (files)
            # horaacabajuntoshapes = time.time()
            # print("tiempo junto shapes")
            # print(horaepiezajuntoshapes - horaacabajuntoshapes)

        # defino una funcion que une en una capa el resultado de todas las hojas raster, hace un grid de lo que encuentre con la cadena
        def juntarasters(cadena):
            busca = os.path.join(carpeta, "*_" + cadena + ".tif")
            files = glob.glob(busca)
            out = os.path.join(carpeta, cadena.upper() + ".vrt")
            params = {'INPUT': files, 'RESOLUTION': 0, 'SEPARATE': False, 'PROJ_DIFFERENCE': False, 'ADD_ALPHA': False,
                      'ASSIGN_CRS': QgsProject.instance().crs().authid(), 'RESAMPLING': 0, 'SRC_NODATA': '',
                      'EXTRA': '', 'OUTPUT': out}
            try:
                result = processing.run("gdal:buildvirtualraster", params)
                rutacapa = result['OUTPUT']
                layer = QgsRasterLayer(rutacapa, cadena.upper())
                QgsProject.instance().addMapLayer(layer)
                # coloreo
                layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/' + cadena + '.qml')
                layer.triggerRepaint()
                iface.layerTreeView().refreshLayerSymbology(layer.id())
            except:
                iface.messageBar().pushMessage("SILVILIDAR",
                                               "Es necesario tener activado el complemento procesos. Si se reinicia QGIS, se activará automáticamente.",
                                               duration=10)
                time.sleep(10)

        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            # self.dlg = SilvilidarDialog()
            # la siguiente linea inicia el boton de cargar carpetas, peta al cerrar el qgis, deberia poner algun close o algo
            # self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)
            print("inicio el boton en el gui")
            # self.dlg.pushButton_select_path.setEnabled(True)
            print("pone le boton como habilitado")

        # show the dialog
        self.dlg.show()

        # self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # compruebo que este activo el plugin de processing y saga
            QSettings().setValue('/PythonPlugins/processing', 'true')
            #QSettings().setValue('/PythonPlugins/sagaprovider', 'true')

            print("nombre_tab")
            # Obtener el índice de la pestaña seleccionada
            indice_seleccionado = self.dlg.tab.currentIndex()
            # Obtener el nombre de la pestaña seleccionada
            nombre_pestaña = self.dlg.tab.tabText(indice_seleccionado)
            print(f"La pestaña seleccionada es: {nombre_pestaña}")


            print("fin_nombre_tab")

            #index = self.dlg.tab.currentIndex()
            #if index == 0:
            if nombre_pestaña=='Ejecución de SILVILIDAR                                 ':
                print(self.tr(u'EMPEZAMOS'))
                # compruebo que capas estan cargadas en el proyecto al iniciar el script
                capasoriginales = QgsProject.instance().mapLayers()
                a = ["nombre de archivo", "extension"]

                # congelo la vista  para ahorrar memoria  #ojo lo descongelo de momento   ojo ojo
                canvas = iface.mapCanvas()
                # canvas.freeze(True)

                # meto aqui variables que luego deberan estar en la cajita   OJO

                crecimiento = self.dlg3.crecimiento.text()  ##displayText()1.5
                crecimientofcc = self.dlg3.crecimientofcc.text()  ##displayText()12.5
                # METODO ALEJANDRO

                fccminarbolado = self.dlg2.fccminarbolado.text()  # 10
                alturadesconocida = self.dlg2.alturadesconocida.text()  # 2
                hmaxmontebravo = self.dlg2.hmaxmontebravo.text()  # 3.5
                hmaxbajolatizal = self.dlg2.hmaxbajolatizal.text()  # 5
                rcminresalveoencinarlatizalpocodesarrollado = self.dlg2.rcminresalveoencinarlatizalpocodesarrollado.text()  # 40
                rcminresalveoencinarlatizalpocodesarrollado_2 = self.dlg2.rcminresalveoencinarlatizalpocodesarrollado_2.text()  # -0,485950210654347*HM^2+10,9071549372235*HM+2,62451053947642
                if not isinstance(rcminresalveoencinarlatizalpocodesarrollado, (int, float)):
                    rcminresalveoencinarlatizalpocodesarrollado = rcminresalveoencinarlatizalpocodesarrollado_2.replace(
                        'SI', 'if').replace('FCC', str('fccp@1')).replace('RC', str('rcp@1')).replace('HM',
                                                                                                      str('hmp@1')).replace(
                        ',', '.').replace(';', ',')  # -0,485950210654347*HM^2+10,9071549372235*HM+2,62451053947642

                fccmincompetenciaencinarlatizalpocodesarrollado = self.dlg2.fccmincompetenciaencinarlatizalpocodesarrollado.text()  # 50
                fccmincompetenciaencinarlatizalpocodesarrollado_2 = self.dlg2.fccmincompetenciaencinarlatizalpocodesarrollado_2.text()  # SI(FCC>46;SI(FCC>16/45,4150013475952/(1-RC/100)*100;52;62);62)
                if not isinstance(fccmincompetenciaencinarlatizalpocodesarrollado, (int, float)):
                    fccmincompetenciaencinarlatizalpocodesarrollado = fccmincompetenciaencinarlatizalpocodesarrollado_2.replace(
                        'SI', 'if').replace('FCC', str('fccp@1')).replace('RC', str('rcp@1')).replace('HM',
                                                                                                      str('hmp@1')).replace(
                        ',', '.').replace(';', ',')
                hmaxselvicolas = self.dlg2.hmaxselvicolas.text()  # 7.5
                # rcminresalveoencinarlatizaldesarrollado = self.dlg2.rcminresalveoencinarlatizaldesarrollado.text()  # 50
                hbcpodabaja = self.dlg2.hbcpodabaja.text()  # 3
                # rcminresalveoencinarfustal = self.dlg2.rcminresalveoencinarfustal.text()  # 60
                fccmincompetenciamasadiscontinua_fustalencinares = self.dlg2.fccmincompetenciamasadiscontinua_fustalencinares.text()  # 57.5
                rcminclara = self.dlg2.rcminclara.text()  # 35
                longitudcopaminclara = self.dlg2.longitudcopaminclara.text()  # 3.25
                fcccompetenciaelevada = self.dlg2.fcccompetenciaelevada.text()  # 95
                hmaxsegundaclara = self.dlg2.hmaxsegundaclara.text()  # 16.5
                hbcminclarasnormales = self.dlg2.hbcminclarasnormales.text()  # 5.5
                fccmincompetenciaencinarlatizaldesarrollado = self.dlg2.fccmincompetenciaencinarlatizaldesarrollado.text()  # 55
                hmaxprimeraclara = self.dlg2.hmaxprimeraclara.text()  # 12
                rccoronado = self.dlg2.rccoronado.text()  # 17
                # OJO AQUI PUEDE EMPEZAR EL CODIGO SI ESTAS DENTRO DE LA JUNTA
                if self.dentro:
                    global layerglobal
                    # defino lo que esta en los servidores de scayle
                    print("dentro de la junta")
                    entries = []
                    carpeta = os.path.dirname(self.dlg.ruta_zona_de_trabajo.text())
                    def crea_carpeta(carpeta, carpeta_nueva):
                        from datetime import datetime
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        carpeta_nueva = os.path.join(carpeta, f'Silvilidar_{timestamp}')
                        os.makedirs(carpeta_nueva, exist_ok=True)
                        print("creo carpeta nueva")
                        return carpeta_nueva

                    carpeta_nueva = carpeta + '/Silvilidar'
                    carpeta=crea_carpeta(carpeta, carpeta_nueva)


                    print("carpeta", carpeta)
                    ruta_zona_trabajo = self.dlg.ruta_zona_de_trabajo.text()
                    layervectorial = QgsVectorLayer(ruta_zona_trabajo, "zona de trabajo", "ogr")
                    #imprimo las los parametros con los que voy a ejecutar silvilidar.
                    print("PARAMETROS DE SILVILIDAR PARA ESTA EJECUCIÓN")
                    print(carpeta, crecimiento, crecimientofcc, fccminarbolado, alturadesconocida, hmaxmontebravo,
                          hmaxbajolatizal, rcminresalveoencinarlatizalpocodesarrollado,
                          fccmincompetenciaencinarlatizalpocodesarrollado, hmaxselvicolas, hbcpodabaja,
                          fccmincompetenciamasadiscontinua_fustalencinares, rcminclara, longitudcopaminclara,
                          fcccompetenciaelevada, hmaxsegundaclara, hbcminclarasnormales,
                          fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado)

                    def crear_texto(ruta_archivo):
                        # Definir variables fijas
                        fijas = ["ruta_zona_trabajo ","carpeta ", "crecimiento ", "crecimientofcc ", "fccminarbolado ", "alturadesconocida ", "hmaxmontebravo ",
                          "hmaxbajolatizal ", "rcminresalveoencinarlatizalpocodesarrollado ",
                          "fccmincompetenciaencinarlatizalpocodesarrollado ", "hmaxselvicolas ", "hbcpodabaja ",
                          "fccmincompetenciamasadiscontinua_fustalencinares ", "rcminclara ", "longitudcopaminclara ",
                          "fcccompetenciaelevada ", "hmaxsegundaclara ", "hbcminclarasnormales ",
                          "fccmincompetenciaencinarlatizaldesarrollado ", "hmaxprimeraclara ", "rccoronado "]

                        # Definir variables dinámicas (pueden cambiar)
                        valores = [ruta_zona_trabajo,carpeta, crecimiento, crecimientofcc, fccminarbolado, alturadesconocida, hmaxmontebravo,
                          hmaxbajolatizal, rcminresalveoencinarlatizalpocodesarrollado,
                          fccmincompetenciaencinarlatizalpocodesarrollado, hmaxselvicolas, hbcpodabaja,
                          fccmincompetenciamasadiscontinua_fustalencinares, rcminclara, longitudcopaminclara,
                          fcccompetenciaelevada, hmaxsegundaclara, hbcminclarasnormales,
                          fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado]

                        # Crear y escribir en el archivo
                        with open(ruta_archivo, "w", encoding="utf-8") as archivo:
                            archivo.write("PARAMETROS DE EJECUCIÓN DE SILVILIDAR\n")
                            for fija, valor in zip(fijas, valores):
                                archivo.write(f"{fija}: {valor}\n")

                        print(f"Archivo '{ruta_archivo}' creado con éxito.")

                    crear_texto(os.path.join(carpeta,"0_Parametros_SILVILIDAR.txt"))





                    # cargo el raster de la junta hm NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName =  r'C:\WORK\pruebas\v2\Alt95SobreMdf_prt_cut.tif'#r"\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\PNOA2_2017-2021\metricasLidar/Alt95_m_PNOA2.tif"#r"C:\WORK\pruebas\metricasEjemplo\532_4642\alt\h95red.tif"  #
                    Layer = QgsRasterLayer(fileName, "altura de red")
                    print("ok, layer de altura 95 de la red")
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                                             'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                                             'DATA_TYPE': 0, 'OUTPUT': os.path.join(carpeta, 'hm.tif')})[
                        'OUTPUT']
                    #la linea anterior da problemas si es muy grande por el tiempo que tarda. Hacer esperar un tiempo
                    #time.sleep(15)

                    #QgsProject.instance().addMapLayers([Layer])
                    layer2 = QgsRasterLayer(layer2, "altura de red")
                    #QgsProject.instance().addMapLayers([layer2])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    #print("comprobar si la capa es correcta ", layer2.isValid())
                    #StringToRaster(os.path.join(carpeta, 'Alt95_m_PNOA2.tif'),
                    StringToRaster(os.path.join(carpeta, 'hm.tif'),
                                   'hm')  # en teoria se sobre escribiria el raster hm@1
                    #print("creado el string to raster de h")

                    # cargo el raster de la junta hbc percentil 20 para calcular luego rc NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName = r'C:\WORK\pruebas\v2\Alt20SobreMdf_tlr_cut.tif'#r"C:\WORK\pruebas\metricasEjemplo\h20red.tif"  # r"R:\SIGMENA\prueba\2025\02\05\hbc_bengoa_malo.tif"viene de *_CeldasAlt20SobreMds_tlr_conUmbral2mSilvilidar
                    Layer = QgsRasterLayer(fileName, "altura de red")
                    #print("comprobar si la capa es correcta ", Layer.isValid())
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False,
                                             'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False, 'SET_RESOLUTION': False,
                                             'X_RESOLUTION': None, 'Y_RESOLUTION': None, 'DATA_TYPE': 0,
                                             'OUTPUT': os.path.join(carpeta, 'hbc.tif')})[
                        'OUTPUT']
                    #time.sleep(15)
                    #print("comprobar si la capa es correcta ", layer2.isValid())

                    layer2 = QgsRasterLayer(layer2, "base copa de red")
                    # QgsProject.instance().addMapLayers([Layer])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    StringToRaster(os.path.join(carpeta, 'hbc.tif'),
                                   'hbc')  # en teoria se sobre escribiria el raster hm@1
                    print("creado el string to raster de hbc")

                    # cargo el raster de la junta FCC NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName = r'C:\WORK\pruebas\v2/RptoAmdk_PrimeRets_MasDe0200_cut.tif'#r"//repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/dasoLidar/PNOA2_2017-2021/metricasLidar/Cob3m_PRT_PNOA2.tif"#r"C:\WORK\pruebas\metricasEjemplo\532_4642\alt/fccred.tif"
                    Layer = QgsRasterLayer(fileName, "FCC DE RED")
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False,
                                             'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False, 'SET_RESOLUTION': False,
                                             'X_RESOLUTION': None, 'Y_RESOLUTION': None, 'DATA_TYPE': 0,
                                             'OUTPUT': os.path.join(carpeta, 'fcc.tif')})[
                        'OUTPUT']
                    #time.sleep(15)
                    layer2 = QgsRasterLayer(layer2, "fcc de red")
                    # QgsProject.instance().addMapLayers([Layer])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    StringToRaster(os.path.join(carpeta, 'fcc.tif'),
                                   'fcc')  # en teoria se sobre escribiria el raster fcc@1
                    print("creado el string to raster de fcc")

                    #cargo el fcc de matorral
                    # cargo el raster de la junta FCC NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName = r"C:\WORK\pruebas\metricasEjemplo\532_4642\alt/fccmatred.tif"  ##r"//repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/dasoLidar/PNOA2_2017-2021/metricasLidar/Cob3m_PRT_PNOA2.tif"
                    Layer = QgsRasterLayer(fileName, "FCC MATORRAL DE RED")
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False,
                                             'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False, 'SET_RESOLUTION': False,
                                             'X_RESOLUTION': None, 'Y_RESOLUTION': None, 'DATA_TYPE': 0,
                                             'OUTPUT': os.path.join(carpeta, 'fcc_matorral.tif')})[
                        'OUTPUT']
                    time.sleep(5)
                    layer2 = QgsRasterLayer(layer2, "fcc de red")
                    # QgsProject.instance().addMapLayers([Layer])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    StringToRaster(os.path.join(carpeta, 'fcc_matorral.tif'),
                                   'fccmatorral')  # en teoria se sobre escribiria el raster fcc@1
                    print("creado el string to raster de fcc matorral")


                    def calculo(expresion, capa):
                        global layerglobal
                        calc = QgsRasterCalculator(expresion,
                                                   os.path.join(carpeta, capa + '.tif'),
                                                   'GTiff',
                                                   layerglobal.extent(),
                                                   layerglobal.width(),
                                                   layerglobal.height(),
                                                   entries)

                        calc.processCalculation()
                        del (calc)
                        #print("calculo ", capa, "layer global extent ", layerglobal.extent(), "layer global width ", layerglobal.width(), "layer global height ", layerglobal.height(), "layer global path ", layerglobal.source())

                    def agregado2(rasterdeentrada, radio, filtro):
                        # filtro para rellenar huecos
                        print("empieza agregado")
                        #compruebo la resolucion para ver si es diferente a 10x10
                        """if rasterdeentrada.rasterUnitsPerPixelX() != 10:
                            gdal.Warp(
                                os.path.join(carpeta, rasterdeentrada + '11.tif'),
                                rasterdeentrada.source(),
                                xRes=10,  # Tamaño de píxel en X
                                yRes=10,  # Tamaño de píxel en Y
                                resampleAlg="nearest"  # Algoritmo de remuestreo
                            )"""
                        # A puntos
                        input1 = os.path.join(carpeta, rasterdeentrada + '1.tif')
                        output1 = os.path.join(carpeta, rasterdeentrada + '0.shp')
                        apuntos = processing.runAndLoadResults("native:pixelstopoints", {
                            'INPUT_RASTER': input1,
                            'RASTER_BAND': 1, 'FIELD_NAME': 'VALUE', 'OUTPUT': output1})['OUTPUT']
                        # mapa de calor
                        output2 = os.path.join(carpeta,  rasterdeentrada + '2.tif')
                        mapacalor = processing.run("qgis:heatmapkerneldensityestimation", {
                            'INPUT': output1,
                            'RADIUS': radio, 'RADIUS_FIELD': '', 'PIXEL_SIZE': 2, 'WEIGHT_FIELD': 'VALUE', 'KERNEL': 3,
                            'DECAY': None, 'OUTPUT_VALUE': 0, 'OUTPUT': output2})['OUTPUT']
                        rlayer0 = QgsRasterLayer(mapacalor, "mapacalor")
                        StringToRaster(output2, 'rlayer0')

                        # mayor de 1
                        # mayor de umbral
                        output44 = os.path.join(carpeta, rasterdeentrada + '44.tif')
                        calc = QgsRasterCalculator('(rlayer0@1 > {} )'.format(filtro), output44, 'GTiff',
                                                   rlayer0.extent(),
                                                   rlayer0.width(),
                                                   rlayer0.height(), entries)
                        calc.processCalculation()
                        rlayer44 = QgsRasterLayer(output44, "mapacalor_seleccionado")

                        # lo vectorizo
                        #print("paso9 de agregado")
                        parameters = {'INPUT': os.path.join(carpeta,  rasterdeentrada + '44.tif'),
                                      'BAND': 1, 'FIELD': "DN", 'EIGHT_CONNECTEDNESS': True,
                                      'OUTPUT': os.path.join(carpeta, rasterdeentrada + '00.shp')}
                        processing.runAndLoadResults("gdal:polygonize", parameters)
                        # processing.runalg("gdalogr:polygonize",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'7.tif'),"DN",os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'))
                        # seleciono lo que me interesa
                        #print("paso10 de agregado")
                        lyr = QgsVectorLayer(os.path.join(carpeta,  rasterdeentrada + '00.shp'),
                                             rasterdeentrada, "ogr")

                        # delete holes
                        deleteholes = processing.runAndLoadResults("native:deleteholes", {
                            'INPUT': os.path.join(carpeta, rasterdeentrada + '00.shp'),
                            'MIN_AREA': 400,
                            'OUTPUT': os.path.join(carpeta, rasterdeentrada + '000.shp')})[
                            'OUTPUT']
                        lyr = QgsVectorLayer(os.path.join(carpeta,  rasterdeentrada + '000.shp'),
                                             rasterdeentrada, "ogr")

                        # SUAVIZA
                        processing.runAndLoadResults("native:smoothgeometry", {
                            'INPUT': os.path.join(carpeta,  rasterdeentrada + '000.shp'),
                            'ITERATIONS': 2, 'OFFSET': 0.4, 'MAX_ANGLE': 180,
                            'OUTPUT': os.path.join(carpeta, rasterdeentrada + '.shp')})
                        lyr = QgsVectorLayer(os.path.join(carpeta,  rasterdeentrada + '.shp'),
                                             rasterdeentrada, "ogr")



                        # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces.
                        layer = lyr  # iface.activeLayer()
                        #print("paso11 de agregado")
                        expression = QgsExpression(u'"DN" = 1')
                        #print("paso12 de agregado")
                        # Added / changed lines ##########
                        context = QgsExpressionContext()
                        scope = QgsExpressionContextScope()
                        context.appendScope(scope)
                        #print("paso13 de agregado")
                        layer = lyr
                        feats = []
                        ids = []
                        for feat in layer.getFeatures():
                            scope.setFeature(feat)
                            result = expression.evaluate(context)
                            if result:
                                feats.append(feat)
                                ids.append(feat.id())
                                # areas.append(feat.geometry().area() )
                        ################
                        # horaacabaagregado0 = time.time()
                        # print("tiempo agregado0")
                        # print(horaempiezaagregado - horaacabaagregado0)
                        if len(ids) > 0:
                            # print ("len feats")
                            # print( len( feats))
                            #print("paso14 de agregado")

                            # prov.addFeatures(feats)
                            lyr.selectByIds(ids)
                            # lyr es la capa de entrada, la origen ue contiene todos los elementos
                            output_path = os.path.join(carpeta, rasterdeentrada + '2.shp')
                            QgsVectorFileWriter.writeAsVectorFormat(lyr, output_path, "CP120", lyr.crs(),
                                                                    "ESRI Shapefile",
                                                                    onlySelected=True)
                            lyr2 = QgsVectorLayer(
                                os.path.join(carpeta,  rasterdeentrada + '2.shp'),
                                rasterdeentrada + str("2"), "ogr")
                            QgsProject.instance().addMapLayer(lyr2)
                            #print("en teoria ha hecho la seleccion")

                            # if nbrSelected > 0:
                            # guardo lo selecionado
                            """print ("pasa por aqui")
                                #params={ 'INPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'.shp'), 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                                params={ 'INPUT' : mem_layer, 'OUTPUT' : os.path.join(carpeta,troncoresumido+'_'+rasterdeentrada+'2.shp')}
                                processing.run("qgis:saveselectedfeatures",params)"""

                            # calcula la superficie de esta capa pero no en todos los registros
                            layer = QgsVectorLayer(
                                os.path.join(carpeta, rasterdeentrada + '2.shp'),
                                rasterdeentrada + str("2"), "ogr")
                            # layer=lyr2
                            provider = layer.dataProvider()
                            #print("layer get features")
                            # for feat in layer.getFeatures():
                            # print ("feat")
                            # print (feat)
                            areas = [feat.geometry().area() for feat in layer.getFeatures()]
                            # print (areas)
                            indice = [feat.id() for feat in layer.getFeatures()]
                            # print (indice)
                            field = QgsField("area", QVariant.Int)
                            provider.addAttributes([field])
                            layer.updateFields()
                            # idx = layer.fieldNameIndex('area')
                            idx = layer.fields().indexFromName('area')  ###ojo aqui es donde da cero el indice
                            long = len(indice)
                            #print("long")
                            #print(long)
                            i = 0
                            #print("pasa por aqui2")
                            while i < long:
                                new_values = {idx: float(areas[i])}
                                # print ("pasa por aqui3")
                                provider.changeAttributeValues({indice[i]: new_values})
                                # print ("pasa por aqui4")
                                i = i + 1
                            layer.updateFields()
                            #print("pasa por aqui5")

                            # selecciono las teselas mayor de una superficie dada.
                            # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces.
                            # layer2 = layer #iface.activeLayer()
                            #print("paso11 de agregado")
                            expression = QgsExpression(u'"area" > 2500')
                            #print("paso12 de agregado")
                            # Added / changed lines ##########
                            context = QgsExpressionContext()
                            scope = QgsExpressionContextScope()
                            context.appendScope(scope)

                            feats = []
                            ids = []
                            for feat in layer.getFeatures():
                                scope.setFeature(feat)
                                result = expression.evaluate(context)
                                if result:
                                    feats.append(feat)
                                    ids.append(feat.id())
                                    # areas.append(feat.geometry().area() )
                            ################
                            if len(ids) > 0:
                                # print ("len feats")
                                # print( len( feats))
                                #print("paso14 de agregado")
                                # prov.addFeatures(feats)
                                lyr2.selectByIds(ids)
                                # lyr es la capa de entrada, la origen ue contiene todos los elementos
                                output_path = os.path.join(carpeta,  rasterdeentrada + '3.shp')
                                QgsVectorFileWriter.writeAsVectorFormat(lyr2, output_path, "CP120", lyr.crs(),
                                                                        "ESRI Shapefile",
                                                                        onlySelected=True)
                                lyr3 = QgsVectorLayer(
                                    os.path.join(carpeta, rasterdeentrada + '3.shp'),
                                    rasterdeentrada + str("3"), "ogr")
                                QgsProject.instance().addMapLayer(lyr3)
                                #print("en teoria ha hecho la seleccion2")





                    #obtengo los parametros derivados
                    calculo('100 * ( (hm@1 / 100 )   -   (hbc@1 / 100 )  ) / ( (hm@1 / 100 ) )', 'rc') #ojo unidades ( hbc@1 / 100 ) divido por 100 por que la hbc viene en centimetros CM

                    StringToRaster(os.path.join(carpeta, 'rc.tif'), "rc")

                    #falta sacar la lc
                    calculo(' (hm@1 / 100 ) - (hbc@1 / 100 ) ', "lc")
                    StringToRaster(os.path.join(carpeta, 'lc.tif'), "lc")
                    #falta sacar la fccmatorral

                    #proyecto
                    # proyecto la altura con el crecimiento
                    calculo('( (hm@1 / 100 ) < 6) * ( hm@1 / 100 ) + ( ( hm@1 / 100 ) >= 6) * ( ( hm@1 / 100 ) + ' + str(crecimiento) + ')', 'hmp') #ojo unidades ( hm@1 / 100 ) divido por 100 por que la hm viene en centimetros CM
                    StringToRaster(os.path.join(carpeta, 'hmp.tif'), "hmp")
                    # proyecto la altura  de la base de la copa con el crecimiento
                    calculo('((hm@1 / 100 ) < 7.5) * (hbc@1 / 100 ) + ((hm@1 / 100 ) >= 7.5) * ((hbc@1 / 100 ) + ' + str(crecimiento) + ')', 'hbcp')
                    StringToRaster(os.path.join(carpeta, 'hbcp.tif'), "hbcp")
                    # calculo  la razon de copa una vez proyectada la altura y la base de la copa
                    calculo('100 * ( hmp@1   -  hbcp@1  ) / ( hmp@1 )', 'rcp')
                    StringToRaster(os.path.join(carpeta, 'rcp.tif'), "rcp")
                    # proyecto la fraccion de cabida cubierta
                    calculo('(' + str(crecimiento) + ' > 0) * (fcc@1  + ' + str(crecimientofcc) + ') + ( ' + str(
                        crecimiento) + ' = 0) * (fcc@1 )', 'fccp')
                    StringToRaster(os.path.join(carpeta, 'fccp.tif'), "fccp")
                    # proyecto la longitud de copa
                    calculo('(hmp@1 - hbcp@1)', 'lcp')
                    StringToRaster(os.path.join(carpeta,  'lcp.tif'), "lcp")
                    #saco teselas
                    calculo(
                        'if (fccp@1 <= 0, 0, if ( fccp@1 < ' + fccminarbolado + ', 1, if ( hmp@1 < ' + alturadesconocida + ', 11, if ( hmp@1 < ' + hmaxmontebravo + ', 2, if ( hmp@1 < ' + hmaxbajolatizal + ', if ( rcp@1 <= ' + rcminresalveoencinarlatizalpocodesarrollado + ', if ( fccp@1 > ' + fccmincompetenciaencinarlatizalpocodesarrollado + ', 51, 61), 17), if (hmp@1 <= ' + hmaxselvicolas + ', if ( rcp@1 <= ' + rcminresalveoencinarlatizalpocodesarrollado + ', if ( fccp@1 > ' + fccmincompetenciaencinarlatizalpocodesarrollado + ', 52, 62) , if ( hmp@1 - hmp@1 * rcp@1 / 100 <= ' + hbcpodabaja + ', 3, 4)), if ( hmp@1 <= ' + hmaxprimeraclara + ', if ( hmp@1 - hmp@1 * rcp@1 / 100 <=' + hbcminclarasnormales + ' , if ( rcp@1 <= ' + rcminresalveoencinarlatizalpocodesarrollado + ', if ( fccp@1 > ' + fccmincompetenciamasadiscontinua_fustalencinares + ', 77, 7), 7), if ( rcp@1 >= ' + rcminclara + ', if ( hmp@1 * rcp@1 / 100 > ' + longitudcopaminclara + ', if ( fccp@1 > ' + fccmincompetenciamasadiscontinua_fustalencinares + ', if ( fccp@1 >= (0.1167 * fccp@1 +3.6667) * ( hmp@1 ^ 1.04328809) * ( hmp@1 * rcp@1 / 100) ^ (-0.49505946), 81, if ( fccp@1 >= ' + fcccompetenciaelevada + ', 81, 10)), 7), 7), if ( fccp@1 >= ' + fcccompetenciaelevada + ', 9, if ( fccp@1 > ' + fccmincompetenciamasadiscontinua_fustalencinares + ', 77, 10)))), if ( hmp@1 <= ' + hmaxsegundaclara + ', if ( hmp@1 - hmp@1 * rcp@1 / 100 <= ' + hbcminclarasnormales + ', 111, if ( rcp@1 >= ' + rcminclara + ', if ( hmp@1 * rcp@1 / 100 > ' + longitudcopaminclara + ', if ( fccp@1 > ' + fccmincompetenciamasadiscontinua_fustalencinares + ', if ( fccp@1 >= (0.1167 * fccp@1 +3.6667) * ( hmp@1 ^ 1.04328809) * ( hmp@1 * rcp@1 / 100) ^ (-0.49505946), 82, if ( fccp@1 >= ' + fcccompetenciaelevada + ', 82, 111)), 111), 111), if ( fccp@1 >= ' + fcccompetenciaelevada + ', 121, 141))), if ( rcp@1 <= ' + rccoronado + ', if ( fccp@1 >= ' + fcccompetenciaelevada + ', 13, 15), if ( rcp@1 < ' + rcminclara + ', if ( fccp@1 >= ' + fcccompetenciaelevada + ', 122, 142), 112))))))))))',
                        'suma')
                    StringToRaster(os.path.join(carpeta, 'suma.tif'), "suma")
                    parameters = {'INPUT': os.path.join(carpeta, 'suma.tif'), 'BAND': 1,
                                  'FIELD': "DN",
                                  'EIGHT_CONNECTEDNESS': False, 'OUTPUT': os.path.join(carpeta,  'suma.shp')}
                    try:
                        processing.run("gdal:polygonize", parameters)
                    except:
                        iface.messageBar().pushMessage("SILVILIDAR",
                                                       "Es necesario tener activado el complemento procesos. Si se reinicia QGIS, se activará automáticamente.",
                                                       duration=10)
                        time.sleep(10)

                    def borrar_archivos(carpeta, rasterdeentrada):
                        import os
                        # Ruta de la carpeta donde están los archivos

                        capas_vectoriales_a_borrar = [rasterdeentrada, rasterdeentrada + '000', rasterdeentrada + '00',
                                                      rasterdeentrada + '0', rasterdeentrada + '2']
                        capas_raster_a_borrar = [rasterdeentrada + '1', rasterdeentrada + '2', rasterdeentrada + '44']

                        # Función para eliminar archivos
                        def eliminar_archivos(base_path, extensiones):
                            for ext in extensiones:
                                file_path = f"{base_path}{ext}"
                                if os.path.exists(file_path):
                                    os.remove(file_path)
                                    print(f"Eliminado: {file_path}")

                        # Lista de extensiones asociadas a SHP y TIF
                        extensiones_shp = [".shp", ".shx", ".dbf", ".prj", ".cpg"]
                        extensiones_tif = [".tif", ".tif.aux.xml"]

                        for nombre_base in capas_vectoriales_a_borrar:
                            # Eliminar archivos SHP
                            try:
                                eliminar_archivos(os.path.join(carpeta, nombre_base), extensiones_shp)
                            except:
                                pass
                        for nombre_base in capas_raster_a_borrar:
                            # Eliminar archivos TIFF
                            try:
                                eliminar_archivos(os.path.join(carpeta, nombre_base), extensiones_tif)
                            except:
                                pass


                    # filtro para quedarme con la clara
                    if self.dlg4.checkBox_claras.isChecked():
                        # "calculo(
                        # 'c11@1 / 81 + c14@1 / 9  + c15@1 / 81 + c19@1 / 82 + c20@1 / 121 + c21@1 / 82 + c25@1 / 122 + c26@1 / 13',
                        # 'clara1')
                        calculo(
                            '("suma@1" = 81 OR "suma@1" = 9 OR "suma@1" = 82 OR "suma@1" = 121 OR "suma@1" = 122 OR "suma@1" = 13) * 1',
                            'clara1')  # ojo comprobar si sigue siendo así despues de lo de los encinares
                        StringToRaster(os.path.join(carpeta, 'clara1.tif'), "clara1")

                        #print( "pixel claras ",QgsRasterLayer(os.path.join(carpeta, 'clara1.tif'), "Clara1").rasterUnitsPerPixelX())

                        agregado2("clara", 20, 1)
                        layerglobal = QgsRasterLayer(os.path.join(carpeta, 'clara1.tif'), "Clara1")

                        subtexto1 = "Clara"

                        clara = QgsVectorLayer(os.path.join(carpeta, 'Clara3.shp'), subtexto1, "ogr")



                        # filtro para quedarme con la regeneracion
                    if self.dlg4.checkBox_regeneracion.isChecked():
                        # calculo('c28@1 / 15 ', 'regeneracion1')
                        calculo(
                            '("suma@1" = 15 ) * 1', 'regeneracion1')
                        StringToRaster(os.path.join(carpeta, 'regeneracion1.tif'),
                                       "regeneracion1")
                        #print("pixel regeneracion ",QgsRasterLayer(os.path.join(carpeta, 'regeneracion1.tif'), "Regeneracion1").rasterUnitsPerPixelX())
                        agregado2("regeneracion", 40, 1)  # 40,1
                        layerglobal = QgsRasterLayer(os.path.join(carpeta, 'regeneracion1.tif'), "Regeneracion1")
                        subtexto2 = "Regeneración"

                        regeneracion = QgsVectorLayer(os.path.join(carpeta, 'Regeneracion3.shp'), subtexto2, "ogr")

                    # filtro para quedarme con el resalveo
                    if self.dlg4.checkBox_resalveo.isChecked():
                        # calculo('c3@1 / 51 + c8@1 / 52', 'resalveo1')
                        calculo('("suma@1" = 51 OR "suma@1" = 52 ) * 1', 'resalveo1')
                        StringToRaster(os.path.join(carpeta, 'resalveo1.tif'), "resalveo1")
                        #print("pixel resalveo ", QgsRasterLayer(os.path.join(carpeta, 'resalveo1.tif'), "Resalveo1").rasterUnitsPerPixelX())
                        agregado2("resalveo", 20, 1)#30,0.85
                        layerglobal = QgsRasterLayer(os.path.join(carpeta, 'resalveo1.tif'), "Resalveo1")
                        subtexto3 = "Resalveo"
                        resalveo = QgsVectorLayer(os.path.join(carpeta, 'Resalveo3.shp'), subtexto3, "ogr")
                    def join_tables(csv_path, layer_path):
                        res = processing.run("qgis:joinattributestable", { 'DISCARD_NONMATCHING' : False, 'FIELD' : 'DN', 'FIELDS_TO_COPY' : ['texto','foto','foto2'], 'FIELD_2' : 'cod', 'INPUT' : layer_path, 'INPUT_2' : csv_path+'|layername=Hoja1', 'METHOD' : 1, 'OUTPUT' : os.path.join(carpeta, "Teselas.shp"), 'PREFIX' : '' })
                        layer = QgsVectorLayer(res['OUTPUT'], "joined layer", "ogr")
                        QgsProject.instance().addMapLayer(layer)
                    print("intento hacer la union")
                    join_tables(os.path.dirname(__file__) + '/fotos/tabla.xlsx', os.path.join(carpeta, "suma.shp"))
                    print(" la union esta hecha")

                    # elimino las capas que he cargado durante el proceso
                    capas = QgsProject.instance().mapLayers()
                    for capa in capas:
                        if capa not in capasoriginales:
                            QgsProject.instance().removeMapLayers([capa])
                    del (capas)
                    import shutil
                    if self.dlg4.checkBox_altura.isChecked():
                        shutil.copy(os.path.dirname(__file__) + '/styles/hm.qml',
                                    os.path.join(carpeta, "HM.qml"))
                        layer = QgsRasterLayer(os.path.join(carpeta, 'hmp.tif'),"HM")
                        QgsProject.instance().addMapLayer(layer)
                        layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/'+ 'hm.qml')
                        layer.triggerRepaint()
                        iface.layerTreeView().refreshLayerSymbology(layer.id())
                    if self.dlg4.checkBox_fcc.isChecked():
                        layer = QgsRasterLayer(os.path.join(carpeta, 'fccp.tif'), "FCC")
                        shutil.copy(os.path.dirname(__file__) + '/styles/fcc.qml',
                                    os.path.join(carpeta, "FCC.qml"))
                        QgsProject.instance().addMapLayer(layer)
                        layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/' + 'fcc.qml')
                        layer.triggerRepaint()
                        iface.layerTreeView().refreshLayerSymbology(layer.id())
                    if self.dlg4.checkBox_rc.isChecked():
                        layer = QgsRasterLayer(os.path.join(carpeta, 'rcp.tif'), "RC")
                        shutil.copy(os.path.dirname(__file__) + '/styles/rc.qml',
                                    os.path.join(carpeta, "RC.qml"))
                        QgsProject.instance().addMapLayer(layer)
                        layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/' + 'rc.qml')
                        layer.triggerRepaint()
                        iface.layerTreeView().refreshLayerSymbology(layer.id())
                    if self.dlg4.checkBox_lc.isChecked():
                        layer = QgsRasterLayer(os.path.join(carpeta, 'lcp.tif'), "LC")
                        shutil.copy(os.path.dirname(__file__) + '/styles/lc.qml',
                                    os.path.join(carpeta, "LC.qml"))
                        QgsProject.instance().addMapLayer(layer)
                        layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/' + 'lc.qml')
                        layer.triggerRepaint()
                        iface.layerTreeView().refreshLayerSymbology(layer.id())
                    if self.dlg4.checkBox_hbc.isChecked():
                        layer = QgsRasterLayer(os.path.join(carpeta, 'hbcp.tif'), "HBC")
                        shutil.copy(os.path.dirname(__file__) + '/styles/hbc.qml',
                                    os.path.join(carpeta, "HBC.qml"))
                        QgsProject.instance().addMapLayer(layer)
                        layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/' + 'hbc.qml')
                        layer.triggerRepaint()
                        iface.layerTreeView().refreshLayerSymbology(layer.id())
                    if self.dlg4.checkBox_matorral.isChecked():
                        layer = QgsRasterLayer(os.path.join(carpeta, 'fcc_matorral.tif'), "FCC_MATORRAL")
                        shutil.copy(os.path.dirname(__file__) + '/styles/fcc_matorral.qml',
                                    os.path.join(carpeta, "FCC_MATORRAL.qml"))
                        QgsProject.instance().addMapLayer(layer)
                        layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/' + 'fcc_matorral.qml')
                        layer.triggerRepaint()
                        iface.layerTreeView().refreshLayerSymbology(layer.id())
                    if self.dlg4.checkBox_teselas.isChecked():
                        shutil.copytree(os.path.dirname(__file__) + '/fotos', carpeta + '/fotos')
                        shutil.copy(os.path.dirname(__file__) + '/styles/Teselas.qml',
                                    os.path.join(carpeta, "Teselas.qml"))
                        teselas = QgsVectorLayer(os.path.join(carpeta, 'Teselas.shp'), "Teselas", "ogr")
                        borrar_archivos(carpeta, "suma")
                        # aplicar estilo a las teselas cargando un qml con el mismo nombre que la capa
                        teselas.loadNamedStyle(os.path.dirname(__file__) + '/styles/Teselas.qml')
                        QgsProject.instance().addMapLayer(teselas)

                    if self.dlg4.checkBox_claras.isChecked():
                            borrar_archivos(carpeta, "clara")
                            subtexto1 = "Clara"
                            clara = QgsVectorLayer(os.path.join(carpeta, 'Clara3.shp'), subtexto1, "ogr")
                            # aplico simbologia a estas capas, si existen
                            try:
                                symbolsclara = clara.renderer().symbol()
                                sym = symbolsclara
                                sym.setColor(QColor.fromRgb(255, 0, 0))
                                QgsProject.instance().addMapLayer(clara)
                            except:
                                pass

                    if self.dlg4.checkBox_regeneracion.isChecked():
                        borrar_archivos(carpeta, "regeneracion")
                        subtexto2 = "Regeneración"
                        regeneracion = QgsVectorLayer(os.path.join(carpeta, 'Regeneracion3.shp'), subtexto2,  "ogr")
                        try:
                            symbolsregeneracion = regeneracion.renderer().symbol()
                            sym = symbolsregeneracion
                            sym.setColor(QColor.fromRgb(0, 255, 0))
                            QgsProject.instance().addMapLayer(regeneracion)
                        except:
                            pass



                    if self.dlg4.checkBox_resalveo.isChecked():
                        borrar_archivos(carpeta, "resalveo")
                        subtexto3 = "Resalveo"
                        resalveo = QgsVectorLayer(os.path.join(carpeta, 'Resalveo3.shp'), subtexto3, "ogr")
                        try:
                            symbolsresalveo = resalveo.renderer().symbol()
                            sym = symbolsresalveo
                            sym.setColor(QColor.fromRgb(0, 0, 255))
                            QgsProject.instance().addMapLayer(resalveo)
                        except:
                            pass




                else:
                    print("no esta dentro de la junta")
                    #fileName = r"\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\PNOA2_2017-2021\metricasLidar/Alt95_m_PNOA2.tif"
                    #Layer = QgsRasterLayer(fileName, "altura de red")
                    #QgsProject.instance().addMapLayers([Layer])
                    carpeta = self.dlg.carpetalaz.text()  # displayText()
                    # la carpeta la he cogido al pulsar el boton de la carpeta

                    # meto aqui variables que luego deberan estar en la cajita   OJO

                    #crecimiento = self.dlg3.crecimiento.text()  ##displayText()1.5
                    #crecimientofcc = self.dlg3.crecimientofcc.text()  ##displayText()12.5
                    #NUEVAS
                    # METODO ALEJANDRO
                    """fccminarbolado =self.dlg2.fccminarbolado.text()  # 10
                    alturadesconocida = self.dlg2.alturadesconocida.text()  # 2
                    hmaxmontebravo = self.dlg2.hmaxmontebravo.text()  # 3.5
                    hmaxbajolatizal = self.dlg2.hmaxbajolatizal.text()  # 5"""
                    """rcminresalveoencinarlatizalpocodesarrollado = self.dlg2.rcminresalveoencinarlatizalpocodesarrollado.text()  # 40
                    rcminresalveoencinarlatizalpocodesarrollado_2 = self.dlg2.rcminresalveoencinarlatizalpocodesarrollado_2.text()  # -0,485950210654347*HM^2+10,9071549372235*HM+2,62451053947642
                    if not isinstance(rcminresalveoencinarlatizalpocodesarrollado, (int, float)):
                        rcminresalveoencinarlatizalpocodesarrollado = rcminresalveoencinarlatizalpocodesarrollado_2.replace('SI','if').replace('FCC',str('fccp@1')).replace('RC',str('rcp@1')).replace('HM',str('hmp@1')).replace(',','.').replace(';',',')# -0,485950210654347*HM^2+10,9071549372235*HM+2,62451053947642

                    fccmincompetenciaencinarlatizalpocodesarrollado = self.dlg2.fccmincompetenciaencinarlatizalpocodesarrollado.text()  # 50
                    fccmincompetenciaencinarlatizalpocodesarrollado_2 = self.dlg2.fccmincompetenciaencinarlatizalpocodesarrollado_2.text() #SI(FCC>46;SI(FCC>16/45,4150013475952/(1-RC/100)*100;52;62);62)
                    if not isinstance(fccmincompetenciaencinarlatizalpocodesarrollado, (int, float)):
                        fccmincompetenciaencinarlatizalpocodesarrollado = fccmincompetenciaencinarlatizalpocodesarrollado_2.replace('SI','if').replace('FCC',str('fccp@1')).replace('RC',str('rcp@1')).replace('HM',str('hmp@1')).replace(',','.').replace(';',',')
                    hmaxselvicolas = self.dlg2.hmaxselvicolas.text()  # 7.5
                   #rcminresalveoencinarlatizaldesarrollado = self.dlg2.rcminresalveoencinarlatizaldesarrollado.text()  # 50
                    hbcpodabaja = self.dlg2.hbcpodabaja.text()  # 3
                    #rcminresalveoencinarfustal = self.dlg2.rcminresalveoencinarfustal.text()  # 60
                    fccmincompetenciamasadiscontinua_fustalencinares = self.dlg2.fccmincompetenciamasadiscontinua_fustalencinares.text()  # 57.5
                    rcminclara = self.dlg2.rcminclara.text()  # 35
                    longitudcopaminclara = self.dlg2.longitudcopaminclara.text()  # 3.25
                    fcccompetenciaelevada = self.dlg2.fcccompetenciaelevada.text()  # 95
                    hmaxsegundaclara = self.dlg2.hmaxsegundaclara.text()  # 16.5
                    hbcminclarasnormales = self.dlg2.hbcminclarasnormales.text()  # 5.5
                    fccmincompetenciaencinarlatizaldesarrollado = self.dlg2.fccmincompetenciaencinarlatizaldesarrollado.text()  # 55
                    hmaxprimeraclara = self.dlg2.hmaxprimeraclara.text()  # 12
                    rccoronado = self.dlg2.rccoronado.text()  """# 17


                    """# compruebo que capas estan cargadas en el proyecto al iniciar el script
                    capasoriginales = QgsProject.instance().mapLayers()
                    a = ["nombre de archivo", "extension"]

                    # congelo la vista  para ahorrar memoria  #ojo lo descongelo de momento   ojo ojo
                    canvas = iface.mapCanvas()
                    # canvas.freeze(True)"""

                    # ejecuto la busqueda de archivos las
                    buscalidaryejecuta(carpeta, crecimiento, crecimientofcc, fccminarbolado, alturadesconocida, hmaxmontebravo,  hmaxbajolatizal, rcminresalveoencinarlatizalpocodesarrollado, fccmincompetenciaencinarlatizalpocodesarrollado , hmaxselvicolas,  hbcpodabaja, fccmincompetenciamasadiscontinua_fustalencinares, rcminclara, longitudcopaminclara, fcccompetenciaelevada, hmaxsegundaclara, hbcminclarasnormales, fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado)

                    # uno en una capa todas las hojas de claras, regeneracion, resalveo y teselas
                    juntoshapes(os.path.join(carpeta, "p", "*clara3.shp"), "Clara_merged")
                    juntoshapes(os.path.join(carpeta, "p", "*regeneracion3.shp"), "Regeneracion_merged")
                    juntoshapes(os.path.join(carpeta, "p", "*resalveo3.shp"), "Resalveo_merged")
                    juntoshapes(os.path.join(carpeta, "p", "*suma.shp"), "Teselas_merged")

                    def join_tables(csv_path, layer_path):
                        res = processing.run("qgis:joinattributestable", { 'DISCARD_NONMATCHING' : False, 'FIELD' : 'DN', 'FIELDS_TO_COPY' : ['texto','foto','foto2'], 'FIELD_2' : 'cod', 'INPUT' : layer_path, 'INPUT_2' : csv_path+'|layername=Hoja1', 'METHOD' : 1, 'OUTPUT' : os.path.join(carpeta, "Teselas_merged_Final.shp"), 'PREFIX' : '' })
                        layer = QgsVectorLayer(res['OUTPUT'], "joined layer", "ogr")
                        QgsProject.instance().addMapLayer(layer)
                    print("intento hacer la union")
                    join_tables(os.path.dirname(__file__) + '/fotos/tabla.xlsx', os.path.join(carpeta, "Teselas_merged.shp"))
                    print(" la union esta hecha")
                    # elimino las capas que he cargado durante el proceso
                    capas = QgsProject.instance().mapLayers()
                    for capa in capas:
                        if capa not in capasoriginales:
                            QgsProject.instance().removeMapLayers([capa])
                    del (capas)
                    import shutil
                    # cargo los rasters virtuales si chekeado en la salidas
                    if self.dlg4.checkBox_altura.isChecked():
                        juntarasters("hm")
                        shutil.copy(os.path.dirname(__file__) + '/styles/hm.qml',
                                    os.path.join(carpeta, "HM.qml"))
                    if self.dlg4.checkBox_fcc.isChecked():
                        juntarasters("fcc")
                        shutil.copy(os.path.dirname(__file__) + '/styles/fcc.qml',
                                    os.path.join(carpeta, "FCC.qml"))
                    if self.dlg4.checkBox_rc.isChecked():
                        juntarasters("rc")
                        shutil.copy(os.path.dirname(__file__) + '/styles/rc.qml',
                                    os.path.join(carpeta, "RC.qml"))
                    if self.dlg4.checkBox_lc.isChecked():
                        juntarasters("lc")
                        shutil.copy(os.path.dirname(__file__) + '/styles/lc.qml',
                                    os.path.join(carpeta, "LC.qml"))
                    if self.dlg4.checkBox_hbc.isChecked():
                        juntarasters("hbc")
                        shutil.copy(os.path.dirname(__file__) + '/styles/hbc.qml',
                                    os.path.join(carpeta, "HBC.qml"))
                    if self.dlg4.checkBox_matorral.isChecked():
                        juntarasters("fcc_matorral")
                        shutil.copy(os.path.dirname(__file__) + '/styles/fcc_matorral.qml',
                                    os.path.join(carpeta, "FCC_MATORRAL.qml"))

                        if lenguaje_informe == "es":
                            pass
                        else:
                            # copio el fcc matorral y lo renombro como fcc_scrub

                            shutil.copy(os.path.join(carpeta, "FCC_MATORRAL.vrt"), os.path.join(carpeta, "FCC_SCRUB.vrt"))
                            # cargo la capa fcc_scrub
                            layer = QgsRasterLayer(os.path.join(carpeta, "fcc_scrub.vrt"), "FCC_SCRUB")
                            QgsProject.instance().addMapLayer(layer)
                            # coloreo
                            layer.loadNamedStyle(os.path.dirname(__file__) + '/styles/fcc_matorral.qml')
                            layer.triggerRepaint()
                            iface.layerTreeView().refreshLayerSymbology(layer.id())

                            # elimino de la vista la capa fcc_matorral
                            def remove_layer_by_name(name):
                                layers = QgsProject.instance().mapLayersByName(name)
                                if len(layers) > 0:
                                    layer = layers[0]
                                    QgsProject.instance().removeMapLayer(layer)

                            remove_layer_by_name('FCC_MATORRAL')

                    # cargo las capas finales vectoriales

                    if self.dlg4.checkBox_teselas.isChecked():
                        #ojojojojoj
                        import shutil
                        shutil.copytree(os.path.dirname(__file__) + '/fotos', carpeta+'/fotos')
                        shutil.copy(os.path.dirname(__file__) + '/styles/Teselas.qml', os.path.join(carpeta, "Teselas_merged_Final.qml"))
                        teselas = QgsVectorLayer(os.path.join(carpeta, 'Teselas_merged_Final.shp'), "Teselas", "ogr")
                        """teselas1 = QgsVectorLayer(os.path.join(carpeta, 'Teselas_merged_proyectado1.shp'),
                                                  "Teselas Proyectado1",
                                                  "ogr")
                        teselas2 = QgsVectorLayer(os.path.join(carpeta, 'Teselas_merged_proyectado2.shp'),
                                                  "Teselas Proyectado2",
                                                  "ogr")"""
                        #aplicar estilo a las teselas cargando un qml con el mismo nombre que la capa
                        teselas.loadNamedStyle(os.path.dirname(__file__) + '/styles/Teselas.qml')

                        """# coloresteselas={"1":("solid","255,255,204,255","Raso o Regenerado","001"),"2":("solid","255,255,0,255","Menor (Monte Bravo)","002"),"3":("vertical","255,192,0,255","Poda Baja (y Clareo) en Bajo Latizal (Posibilidad si C elevada)","004"),"4":("solid","255,204,153,255","Bajo Latizal Desarrollado","005"),"51":("b_diagonal","255,0,255,255","Resalveo en Latizal poco desarrollado","006"),"52":("f_diagonal","255,0,0,255","Resalveo en Latizal","007"),"61":("solid","255,153,255,255","Latizal poco desarrollado Tratado","008"),"62":("solid","255,124,128,255","Latizal Tratado","009"),"7":("solid","204,255,153,255","Alto Latizal Claro","010"),"81":("b_diagonal","146,208,80,255","Poda Alta y Clara Suave en Latizal","011"),"82":("b_diagonal","51,204,204,255","Poda Alta y Clara Suave en Monte Desarrollado","015"),"9":("f_diagonal","0,176,80,255","Primera Clara y Poda Alta","012"),"10":("solid","102,255,153,255","Alto Latizal Aclarado","013"),"111":("solid","102,255,255,255","Fustal Claro","014"),"112":("solid","139,139,232,255","Fustal Maduro Claro","018"),"121":("f_diagonal","0,176,255,240","Clara en Fustal","016"),"122":("b_diagonal","65,51,162,255","Clara en Fustal Maduro","019"),"13":("cross","0,112,192,255","Clara Urgente en Fustal Maduro","020"),"141":("solid","204,236,255,255","Fustal Aclarado","017"),"142":("solid","166,166,207,255","Fustal Maduro Aclarado","021"),"15":("horizontal","112,48,160,255","Posibilidad de Regeneracion","022"),"17":("solid","orange","Bajo Latizal No Concurrente o Latizal Encinar no Denso","003")}
    
                        # ordeno los elementos de teselas ojo ojo
                        # ordenados=coloresteselas.items()
                        # ordenados.sort(key=lambda clave: str(clave[1][3]))
                        # me salto el orden del diccionario
                        ordenados = [('1', ('solid', '255,255,204,255', 'Raso o Regenerado', '001')),
                                     ('2', ('solid', '255,255,0,255', 'Menor (Monte Bravo)', '002')),
                                     ('17',
                                      ('solid', 'orange', 'Bajo Latizal No Concurrente o Latizal Encinar no Denso', '003')),
                                     (
                                         '3', (
                                             'vertical', '255,192,0,255',
                                             'Poda Baja (y Clareo) en Bajo Latizal (Posibilidad si C elevada)',
                                             '004')),
                                     ('4', ('solid', '255,204,153,255', 'Bajo Latizal Desarrollado', '005')),
                                     (
                                         '51',
                                         ('b_diagonal', '255,0,255,255', 'Resalveo en Latizal poco desarrollado', '006')),
                                     ('52', ('f_diagonal', '255,0,0,255', 'Resalveo o clareo en Latizal', '007')),
                                     ('61', ('solid', '255,153,255,255', 'Latizal poco desarrollado Tratado', '008')),
                                     ('62', ('solid', '255,124,128,255', 'Latizal Tratado', '009')),
                                     ('7', ('solid', '204,255,153,255', 'Alto Latizal Claro', '010')),
                                     ('81', ('b_diagonal', '146,208,80,255', 'Poda Alta y Clara Suave en Latizal', '011')),
                                     ('9', ('f_diagonal', '0,176,80,255', 'Primera Clara y Poda Alta', '012')),
                                     ('10', ('solid', '102,255,153,255', 'Alto Latizal Aclarado', '013')),
                                     ('111', ('solid', '102,255,255,255', 'Fustal Claro', '014')), ('82', (
                                'b_diagonal', '51,204,204,255', 'Poda Alta y Clara Suave en Monte Desarrollado', '015')),
                                     ('121', ('f_diagonal', '0,176,255,240', 'Clara en Fustal', '016')),
                                     ('141', ('solid', '204,236,255,255', 'Fustal Aclarado', '017')),
                                     ('112', ('solid', '139,139,232,255', 'Fustal Maduro Claro', '018')),
                                     ('122', ('b_diagonal', '65,51,162,255', 'Clara en Fustal Maduro', '019')),
                                     ('13', ('cross', '0,112,192,255', 'Clara Urgente en Fustal Maduro', '020')),
                                     ('142', ('solid', '166,166,207,255', 'Fustal Maduro Aclarado', '021')),
                                     ('15', ('horizontal', '112,48,160,255', 'Posibilidad de Regeneracion', '022'))]
    
                        categorias = []
    
                        for clase, (relleno, color, etiqueta, orden) in ordenados:
                            props = {'style': relleno, 'color': color, 'style_border': 'no'}
                            sym = QgsFillSymbol.createSimple(props)
                            categoria = QgsRendererCategory(clase, sym, etiqueta)
                            categorias.append(categoria)
    
                        field = "DN"
                        renderer = QgsCategorizedSymbolRenderer(field, categorias)
                        teselas.setRenderer(renderer)
                        QgsProject.instance().addMapLayer(teselas)"""
                    QgsProject.instance().addMapLayer(teselas)
                    if lenguaje_informe == "es":
                        subtexto1 = "Clara"
                        subtexto2 = "Regeneración"
                        subtexto3 = "Resalveo"
                    else:
                        subtexto1 = "Thinning"
                        subtexto2 = "Regeneration"
                        subtexto3 = "Precommercial thinning"
                    clara = QgsVectorLayer(os.path.join(carpeta, 'Clara_merged.shp'), subtexto1, "ogr")
                    regeneracion = QgsVectorLayer(os.path.join(carpeta, 'Regeneracion_merged.shp'), subtexto2, "ogr")
                    resalveo = QgsVectorLayer(os.path.join(carpeta, 'Resalveo_merged.shp'), subtexto3, "ogr")
                    # aplico simbologia a estas capas, si existen
                    try:
                        symbolsclara = clara.renderer().symbol()
                        sym = symbolsclara
                        sym.setColor(QColor.fromRgb(255, 0, 0))
                        QgsProject.instance().addMapLayer(clara)
                    except:
                        pass

                    try:
                        symbolsregeneracion = regeneracion.renderer().symbol()
                        sym = symbolsregeneracion
                        sym.setColor(QColor.fromRgb(0, 255, 0))
                        QgsProject.instance().addMapLayer(regeneracion)
                    except:
                        pass

                    try:
                        symbolsresalveo = resalveo.renderer().symbol()
                        sym = symbolsresalveo
                        sym.setColor(QColor.fromRgb(0, 0, 255))
                        QgsProject.instance().addMapLayer(resalveo)
                    except:
                        pass

                    # repinto todo refrescando la vista
                    canvas.freeze(False)
                    canvas.refresh()
                    # self.dlg.pushButton_select_path.setEnabled(False)
                    # self.dlg.close()
                    # print (capasoriginales)

                    print(carpeta, crecimiento, crecimientofcc,fccminarbolado , alturadesconocida,hmaxmontebravo ,  hmaxbajolatizal , rcminresalveoencinarlatizalpocodesarrollado ,fccmincompetenciaencinarlatizalpocodesarrollado , hmaxselvicolas ,  hbcpodabaja ,fccmincompetenciamasadiscontinua_fustalencinares ,rcminclara ,longitudcopaminclara,fcccompetenciaelevada ,hmaxsegundaclara ,hbcminclarasnormales ,fccmincompetenciaencinarlatizaldesarrollado, hmaxprimeraclara, rccoronado)

                    pass

            # empiezo aqui con la segunda pestana, busca zonas similares  OJO
            #if index == 1:
            if nombre_pestaña == 'Busqueda de zonas similares a unas dadas':
                # Obtener el índice de la pestaña seleccionada
                indice_seleccionado2 = self.dlg.tab2.currentIndex()
                nombre_pestaña2 = self.dlg.tab2.widget(indice_seleccionado2).objectName()
                print('nombre_seleccionado2',nombre_pestaña2)
                import random
                # compruebo que capas estan cargadas en el proyecto al iniciar el script
                capasoriginales = QgsProject.instance().mapLayers()





                # para sacar las estadisticas de todos los poligonos juntos
                def simplificar_lista(lista):
                    listanueva = []
                    for elemento in lista:
                        if type(elemento) == list:
                            for element in elemento:
                                if type(element) == list:
                                    for elemen in element:
                                        if type(elemen) == list:
                                            pass
                                        else:
                                            listanueva.append(elemen)
                                else:
                                    listanueva.append(element)
                        else:
                            listanueva.append(elemento)
                    return listanueva

                def estadisticas_lista(lista, coeficiente):
                    estadisticos = [np.size(lista), np.mean(lista), np.std(lista)]
                    rango = [np.mean(lista) - coeficiente * np.std(lista),
                             np.mean(lista) + coeficiente * np.std(lista)]
                    """print('TOTAL-------N Pixels: {} Media: {:.2f} Desviacion Estandar: {:.2f}'.format(np.size(lista),
                     np.mean(lista), np.std(lista)))
                    print("Rango de valores objetivo entre ---------{:.2f} y {:.2f}---------".format(rango[0],rango[1]))"""
                    return rango, estadisticos

                def crea_tabla(datos):
                    if lenguaje_informe == "es":
                        subtexto1 = 'Datos de la muestra'
                        subtexto2 = 'Media'
                        subtexto3 = 'Desviación estandar'
                        subtexto4 = 'Polígono'
                        subtexto5 = 'Todos los polígonos'
                    else:
                        subtexto1 = 'Sample data'
                        subtexto2 = 'Mean'
                        subtexto3 = 'Standard deviation'
                        subtexto4 = 'Polygon'
                        subtexto5 = 'All polygons'
                    texto = '<table class="default">'
                    texto += ' <tr> \
                                    <th scope="row">' + subtexto1 + '</th> \
                                    <th>' + subtexto2 + '</th> \
                                    <th>' + subtexto3 + '</th> \
                                    </tr>'
                    n = 1
                    for dato in datos[1]:
                        texto += '<tr> \
                                                 <th > ' + subtexto4 + ' {} </th> \
                                                 <td > {} </' \
                                                                       'td> \
                                                                   <td > {} </td> \
                                                                   </tr >'.format(n, round(dato[0], 1), round(dato[1], 1))
                        n = n + 1
                    if len(datos[1]) > 0:
                        # print('meter los datos finales con la media y desviacion estandar total')
                        texto += '<tr> \
                                                         <th > ' + subtexto5 + ' </th> \
                                                         <td > {} </' \
                                                                               'td> \
                                                                           <td > {} </td> \
                                                                           </tr >'.format(
                            round(np.mean(simplificar_lista(datos[0])), 1),
                            round(np.std(simplificar_lista(datos[0])),
                                  1))  # meter la media y desviacion media del conjunto de datos.
                    texto += '</table>'
                    return texto

                def grafica_histograma(datos, intervalo_min, intervalo_max, nombre):
                    print("nombre ", nombre)
                    fig, ax = plt.subplots()
                    ax.hist(datos, 10)  # np.arange(0,np.amax(datos)))
                    ax.axvline(intervalo_min, color='red', linestyle='dashed', linewidth=1)
                    ax.axvline(intervalo_max, color='red', linestyle='dashed', linewidth=1)
                    #ojo nuevo empieza
                    if nombre in ['hm', 'hbc', 'lc']:
                        ax.set_xlabel('Metros')
                    elif nombre in ['fcc', 'rc']:
                        ax.set_xlabel('%')

                    ax.set_ylabel('Número de píxeles')
                    #ojo nuevo acaba
                    # plt.show()
                    plt.savefig(carpeta + '/' + nombre + '.png')
                    print(carpeta + '/' + nombre + '.png')
                    return carpeta + '/' + nombre + '.png'

                def crea_html(lista_elementos, lista_tablas, lista_graficas):
                    if lenguaje_informe == "es":
                        subtexto = 'DATOS DE LAS ZONAS DE REFERENCIA'
                    else:
                        subtexto = 'REFERENCE ZONE DATA'

                    texto = '<head> \
                                    <meta charset="UTF-8"> \
                                    <title>Estadísticos de la Muestra</title>\
                                     <meta name="keywords" content="EstadÃ­sticos de la muestra">\
                                     <meta name="description" content="Resumen de datos estadÃ­sticos de la muestra">\
                                     <meta name="Author" content="Javi">\
                                     <style>\
                                        table {\
                                        table-layout: fixed;\
                                        width: 80%s;\
                                        border-collapse: collapse;\
                                        border: 3px solid black;\
                                        }\
                                    thead th:nth-child(1) {\
                                    width: 30%;\
                                    }\
                                    thead th:nth-child(2) {\
                                    width: 20%;\
                                    }\
                                    thead th:nth-child(3) {\
                                    width: 15%;\
                                    }\
                                    thead th:nth-child(4) {\
                                    width: 35%;\
                                    }\
                                    th, td {\
                                    padding: 20px;\
                                    }\
                                    th, td {\
                                    width: 25%;\
                                    text-align: left;/\
                                    vertical-align: top;\
                                    border: 1px solid ;\
                                    border-collapse: collapse;\
                                    padding: 0.3em;\
                                    caption-side: bottom;\
                                    }\
                                    </style>\
                                    <script>\
                                    </script>\
                                    </head> \
                                    <body><h1>' + subtexto + '</h1>'

                    n = 0
                    if len(lista_elementos) > 0:
                        for i in range(0, len(lista_elementos)):
                            print(lista_elementos[i])
                            texto += '<h2>{} </h2> \
                                                     {}  \
                                                     <br>\
                                                     <img src={}>'.format(lista_elementos[i].replace('HM','Altura Lidar').replace('FCC','Fracción de Cabida Cubierta Lidar').replace('RC','Razón de Copa Lidar').replace('LC','Longitud de Copa Lidar').replace('_MATORRAL',' de Matorral'), lista_tablas[i],
                                                                          lista_graficas[i])
                            n = n + 1
                    texto += '</body></html>'
                    archivo_html = open(carpeta + "/Datos_Muestra.html", "w")
                    archivo_html.write(texto)
                    archivo_html.close()
                    webbrowser.open_new(carpeta + "/Datos_Muestra.html")
                    # return texto

                def compara_histogramas(data1, data2):
                    # OJO ESTARIA BIEN IMPRIMIR EN PANTALLA, O UN HTML EL HISTOGRAMA
                    import numpy as np
                    from scipy.spatial.distance import euclidean
                    from scipy.stats import pearsonr
                    import matplotlib.pyplot as plt

                    import random
                    # Crear dos conjuntos de datos con diferentes tamaños, de 0 a 10 o 12
                    # data1 = np.array([random.randint(0, 10) for _ in range(100)])  # np.random.exponential(scale=1.0, size=1000)
                    # data2 = np.array([random.randint(0, 12) for _ in range(50)])  # np.random.gamma(shape=2.0, scale=1.0, size=1500)
                    data1 = np.array(data1)
                    data2 = np.array(data2)
                    # Calcular los histogramas con los mismos bins, en 10 grupos   a masnumero de grupos mas tardara en hacerlo y sera mas preciso en el resultado
                    bins = np.linspace(0, max(np.max(data1), np.max(data2)),
                                       10)  # OJO 10 PODRIA SER UN PARAMETRO VARIABLE.
                    hist1, _ = np.histogram(data1, bins=bins)
                    hist2, _ = np.histogram(data2, bins=bins)

                    # Normalizar los histogramas
                    hist1 = hist1 / np.sum(hist1)
                    hist2 = hist2 / np.sum(hist2)

                    # Graficar los histogramas
                    plt.figure(figsize=(10, 6))
                    plt.hist(data1, bins=bins, alpha=0.5, label='Data 1', density=True)
                    plt.hist(data2, bins=bins, alpha=0.5, label='Data 2', density=True)
                    plt.legend(loc='upper right')
                    # plt.show()

                    # Calcular la distancia Euclidiana
                    dist_euclidiana = euclidean(hist1, hist2)
                    # print(f'Distancia Euclidiana: {dist_euclidiana}')

                    # Calcular el coeficiente de correlación de Pearson
                    coef_pearson, _ = pearsonr(hist1, hist2)
                    # print(f'Coeficiente de correlación de Pearson: {coef_pearson}')

                    # Definir umbrales para la similitud
                    umbral_dist_euclidiana = correlacion#0.10
                    umbral_coef_pearson = 0.80
                    #print("umbral_coef_pearson " , umbral_coef_pearson)

                    # Interpretación combinada
                    #son similares si la distancia euclidiana es menor que el umbral
                    #van en el mismo sentido si el coeficiente de pearson es mayor que el umbral
                    if dist_euclidiana < umbral_dist_euclidiana and coef_pearson > umbral_coef_pearson:
                        #print(                                    f"Los histogramas son similares: pequeñas diferencias absolutas y diferencias en el mismo sentido.{coef_pearson} ")

                        return True
                    #elif dist_euclidiana < umbral_dist_euclidiana and coef_pearson < -umbral_coef_pearson:
                    #print(                                    "Los histogramas son similares: pequeñas diferencias absolutas pero diferencias en sentido opuesto.")
                    #return False
                    #elif dist_euclidiana >= umbral_dist_euclidiana and coef_pearson > umbral_coef_pearson:
                    #print(                                    f"Los histogramas tienen grandes diferencias absolutas, pero las diferencias son en el mismo sentido.{coef_pearson} ")
                    #return False
                    else:
                        #print(                                    "Los histogramas tienen grandes diferencias absolutas y las diferencias son en sentido opuesto.")
                        return False

                def quemaventanas(raster_layer, lista_ventanas):
                    from qgis.core import QgsRasterLayer, QgsRectangle, QgsRaster, QgsRasterPipe, \
                        QgsRasterFileWriter, QgsRasterDataProvider, QgsProject
                    import numpy as np
                    from osgeo import gdal, osr
                    # Obtener la extensión de la capa
                    extent = raster_layer.extent()
                    # Obtener el nombre de la capa
                    nombre_raster = raster_layer.name()
                    xmin = extent.xMinimum()
                    xmax = extent.xMaximum()
                    ymin = extent.yMinimum()
                    ymax = extent.yMaximum()

                    # Crear la expresión de la extensión para el procesamiento
                    extent_str = f"{xmin},{xmax},{ymin},{ymax} [EPSG:25830]"
                    pixel_size = 10
                    miresultado = processing.run("native:createconstantrasterlayer", {
                        'EXTENT': extent_str,
                        'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:25830'), 'PIXEL_SIZE': pixel_size, 'NUMBER': 0,
                        'OUTPUT_TYPE': 5, 'OUTPUT': 'TEMPORARY_OUTPUT'})

                    # creo un shape con las ventanas
                    from qgis.core import (
                        QgsRectangle,
                        QgsVectorLayer,
                        QgsFeature,
                        QgsGeometry,
                        QgsField,
                        QgsFields,
                        QgsVectorFileWriter,
                        QgsProject
                    )
                    from qgis.PyQt.QtCore import QVariant
                    # Crear una capa vectorial temporal
                    vlayer = QgsVectorLayer('Polygon?crs=EPSG:25830', 'rectangle_layer', 'memory')
                    provider = vlayer.dataProvider()

                    # Definir campos (si es necesario)
                    fields = QgsFields()
                    fields.append(QgsField('id', QVariant.Int))
                    provider.addAttributes(fields)
                    vlayer.updateFields()

                    # Iterar sobre la lista de rectángulos y añadir cada uno como una característica
                    for i, rect in enumerate(lista_ventanas):
                        polygon = QgsGeometry.fromRect(rect)
                        feature = QgsFeature()
                        feature.setGeometry(polygon)
                        feature.setAttributes([1])  # Asignar un id único a cada polígono
                        provider.addFeature(feature)

                    # Asegurarse de que la capa vectorial se actualice
                    vlayer.updateExtents()
                    QgsProject.instance().addMapLayer(vlayer)
                    # convertir en raster vlayer y guardarlo en una ruta dada.
                    # Definir los parámetros de salida del ráster
                    output_raster = carpeta + f'/zonas_similares_{nombre_raster}.tif'  # f'c:/work/pruebas/zonas_similares_{nombre_raster}.tif'
                    anchura_pixel = 10  # Tamaño de celda en la dirección X
                    altura_pixel = 10  # Tamaño de celda en la dirección Y
                    ext = vlayer.extent()  # Obtener la extensión de la capa vectorial

                    # Ejecutar la rasterización con GDAL
                    params = {
                        'INPUT': vlayer,  # Capa vectorial de entrada

                        'UNITS': 1,  # Opción de unidades
                        'WIDTH': anchura_pixel,  # Tamaño de pixel X
                        'HEIGHT': altura_pixel,  # Tamaño de pixel Y
                        'EXTENT': ext,  # Extensión de la capa vectorial
                        'NODATA': -9999,  # Valor para píxeles sin datos
                        'OUTPUT': output_raster,  # Ruta de salida para el ráster generado
                        'BURN': 1,
                        'DATA_TYPE': 1

                    }

                    # Ejecutar el proceso de rasterización
                    processing.run("gdal:rasterize", params)

                    # Guardar la capa vectorial como un shapefile, OJO ESTE PASO PUEDO ELIMINARLO Y HACERLO SOLO PARA EL RESULTANTE
                    # OJO HAY QUE MIRAR QUE DEVOLVEMOS DE ESTA FUNCION CON UN RETURN. SUPONGO QUE O EL RASTER O SU RUTA.
                    output_path = carpeta + f"/similares_{nombre_raster}.shp"  # 'c:/work/pruebas/similares.shp'  # Reemplaza con la ruta deseada
                    QgsVectorFileWriter.writeAsVectorFormat(vlayer, output_path, 'UTF-8', vlayer.crs(),
                                                            'ESRI Shapefile')

                    # Añadir la capa al proyecto actual (opcional)
                    QgsProject.instance().addMapLayer(vlayer)
                def crea_carpeta(carpeta, carpeta_nueva):
                    from datetime import datetime
                    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                    carpeta_nueva = os.path.join(carpeta, f'Busca_similar_{timestamp}')
                    os.makedirs(carpeta_nueva, exist_ok=True)
                    print("creo carpeta nueva")
                    return carpeta_nueva
                def recorre_raster_ventanas(nombre_raster):
                    #creo que se usa dentro y fuera.
                    global tamano
                    # print("tamano",tamano)
                    from qgis.core import QgsRectangle

                    if self.dentro:
                        raster_layer = QgsRasterLayer(carpeta + '/' + nombre_raster + '.tif', nombre_raster)
                        print(carpeta + '/' + nombre_raster + '.tif')
                    else:
                        raster_layer = QgsRasterLayer(carpeta[:-29] + '/' + nombre_raster + '.vrt', nombre_raster)
                        # Obtener el proveedor de datos del raster
                        print(carpeta[:-29] + '/' + nombre_raster + '.vrt')
                    provider = raster_layer.dataProvider()
                    # Inicializar la lista de ventanas
                    ventanas = []
                    # Obtener el tamaño de píxel del raster
                    pixel_width = raster_layer.rasterUnitsPerPixelX()
                    pixel_height = raster_layer.rasterUnitsPerPixelY()
                    # para que haya solape entre cuadriculas
                    step = int(tamano // solape)#2
                    print("step ", step)
                    # Extraer las ventanas de tamano x tamano
                    for i in range(0, raster_layer.height(), step):
                        for j in range(0, raster_layer.width(), step):
                            # Asegurarse de que la ventana no exceda los límites del raster
                            if i + int(tamano) <= raster_layer.height() and j + int(tamano) <= raster_layer.width():
                                # Calcular las coordenadas de la ventana
                                x_min = raster_layer.extent().xMinimum() + j * round(pixel_width)
                                y_max = raster_layer.extent().yMaximum() - i * round(pixel_height)
                                x_max = x_min + int(tamano) * pixel_width
                                y_min = y_max - int(tamano) * pixel_height

                                # Definir la ventana de tamano x tamano
                                window_extent = QgsRectangle(x_min, y_min, x_max, y_max)
                                window = provider.block(1, window_extent, int(tamano), int(tamano))
                                # Convertir la ventana a una lista, añadiendo la extensión de la ventana
                                ventana_list = [
                                    [window.value(k, l) for k in range(int(tamano)) for l in range(int(tamano))],
                                    window_extent]
                                ventanas.append(ventana_list)
                    print('numero de ventanas ', len(ventanas))
                    listabuena = []
                    # nombre_raster2 = nombre_raster.lower()
                    # nombre_raster3 = f"resultado_{nombre_raster2}_simplificado"
                    # print(nombre_raster3)
                    if nombre_raster == 'HM':
                        resultado = resultado_hm_simplificado
                    if nombre_raster == 'FCC':
                        resultado = resultado_fcc_simplificado
                    if nombre_raster == 'HBC':
                        resultado = resultado_hbc_simplificado
                    if nombre_raster == 'LC':
                        resultado = resultado_lc_simplificado
                    if nombre_raster == 'RC':
                        resultado = resultado_rc_simplificado

                    # print(resultado_hm_simplificado)
                    # print(eval(nombre_raster3))
                    for idx, ventana in enumerate(ventanas):
                        try:
                            nuevo2 = compara_histogramas(resultado, np.array(
                                ventana[0]))  # (resultado_hm_simplificado, np.array(ventana[0]))
                            # print("no ha petado")
                            if nuevo2 == True:
                                print("es similar")
                                print(f"Ventana {idx + 1}:")
                                print(ventana[1])
                                listabuena.append(ventana[1])


                        except:
                            pass

                    # print(ventanas)
                    quemaventanas(raster_layer, listabuena)  # [elemento[1] for elemento in ventanas])

                def filtro_raster_intervalo(nombre_raster, intervalo):
                    if self.dentro:
                        rlayer = QgsRasterLayer(carpeta + '/' + nombre_raster + '.tif', nombre_raster)
                        print(carpeta + '/' + nombre_raster + '.tif')
                    else:
                        rlayer = QgsRasterLayer(carpeta[:-29] + '/' + nombre_raster + '.vrt', nombre_raster)
                        print(carpeta[:-29] + '/' + nombre_raster + '.vrt')
                    # QgsProject.instance().addMapLayer(rlayer)
                    minimo = intervalo[0]
                    maximo = intervalo[1]
                    entries = []
                    input_raster = rlayer
                    output_raster = carpeta + '/' + nombre_raster + "filtro.tif"
                    # Define band1
                    layer1 = QgsRasterCalculatorEntry()
                    layer1.ref = 'layer1@1'
                    layer1.raster = rlayer
                    layer1.bandNumber = 1
                    entries.append(layer1)

                    calc = QgsRasterCalculator(
                        '(layer1@1 > ' + str(minimo) + ' AND layer1@1 < ' + str(maximo) + ') ',
                        output_raster,
                        'GTiff',
                        rlayer.extent(),
                        rlayer.width(),
                        rlayer.height(),
                        entries)

                    calc.processCalculation()
                    nuevalayer = QgsRasterLayer(output_raster, nombre_raster.lower() + "_filtro")
                    return nuevalayer.source()

                def multiplica_rasters(suffix_input):
                    output_raster = carpeta + "/multilpicado.tif"
                    expr = ''
                    rasters = []
                    for i, suffix in enumerate(suffix_input):
                        inputrasterfile = QgsRasterLayer(suffix, suffix)
                        rasters.append(inputrasterfile)

                        expr = expr + '"{}@1"*'.format(suffix)

                    expr = expr.rstrip('*')
                    # print(rasters[0].source())
                    alg_params = {
                        'CELLSIZE': 0,
                        'CRS': QgsProject.instance().crs().authid(),
                        'EXPRESSION': expr,
                        'EXTENT': rasters[0].extent(),  # rasters[0].extent(),
                        'LAYERS': rasters,
                        'OUTPUT': output_raster
                    }

                    result = processing.run('qgis:rastercalculator', alg_params)
                    # QgsProject.instance().addRasterLayer(output_raster)

                    nuevalayer = QgsRasterLayer(output_raster, "Pixels similares")
                    # cargo el raster de pendientes
                    # nuevalayer.renderer().setOpacity(0.2)
                    nuevalayer.loadNamedStyle(os.path.dirname(__file__) + '/styles/similar.qml')
                    QgsProject.instance().addMapLayers([nuevalayer])
                    return nuevalayer

                """def vectorizar(raster, salida):
                    parameters = {'INPUT': raster.source(), 'BAND': 1, 'EXTRA': '', 'FIELD': "DN",
                                  'EIGHT_CONNECTEDNESS': False,
                                  'OUTPUT': carpeta + '/vectorizado.shp'}
                    processing.run("gdal:polygonize",
                                   parameters)  # .runAndLoadResults("gdal:polygonize",parameters)
                    # seleciono lo que me interesa
                    lyr = QgsVectorLayer(carpeta + '/vectorizado.shp', "nombre", "ogr")
                    # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva
                    # ojo deberia hacer una funcion para emplearlo mas veces.
                    layer = lyr  # iface.activeLayer()
                    expression = QgsExpression(u'"DN" = 1')
                    context = QgsExpressionContext()
                    scope = QgsExpressionContextScope()
                    context.appendScope(scope)
                    layer = lyr
                    feats = []
                    ids = []
                    for feat in layer.getFeatures():
                        scope.setFeature(feat)
                        result = expression.evaluate(context)
                        if result:
                            feats.append(feat)
                            ids.append(feat.id())
                            # areas.append(feat.geometry().area() )
                    if len(ids) > 0:
                        # exporto la seleccion
                        layer.selectByIds(ids)
                        output_path = carpeta + "/vectorial2.shp"

                        QgsVectorFileWriter.writeAsVectorFormat(layer, output_path, "CP120", layer.crs(),
                                                                "ESRI Shapefile",
                                                                onlySelected=True)
                        lyr2 = QgsVectorLayer(output_path, "vectorial2", "ogr")
                        # QgsProject.instance().addMapLayer(lyr2)
                        # simplifico
                        # calcula la superficie de esta capa pero no la refresca.
                        layer = QgsVectorLayer(output_path, "poligonos", "ogr")
                        provider = layer.dataProvider()
                        areas = [feat.geometry().area() for feat in layer.getFeatures()]
                        indice = [feat.id() for feat in layer.getFeatures()]
                        field = QgsField("area", QVariant.Int)
                        provider.addAttributes([field])
                        layer.updateFields()
                        idx = layer.fields().indexFromName('area')
                        long = len(indice)
                        i = 0
                        while i < long:
                            new_values = {idx: float(areas[i])}
                            provider.changeAttributeValues({indice[i]: new_values})
                            i = i + 1
                        layer.updateFields()

                        # selecciono las teselas mayor de una superficie dada.
                        # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva
                        # ojo deberia hacer una funcion para emplearlo mas veces.
                        expression = QgsExpression(u'"area" > 1000')
                        context = QgsExpressionContext()
                        scope = QgsExpressionContextScope()
                        context.appendScope(scope)
                        feats = []
                        ids = []
                        for feat in layer.getFeatures():
                            scope.setFeature(feat)
                            result = expression.evaluate(context)
                            if result:
                                feats.append(feat)
                                ids.append(feat.id())
                                # areas.append(feat.geometry().area() )
                        if len(ids) > 0:
                            lyr2.selectByIds(ids)
                            ruta_vectorial3 = carpeta + "/vectorial3.shp"
                            output_path = ruta_vectorial3
                            QgsVectorFileWriter.writeAsVectorFormat(lyr2, output_path, "CP120", lyr.crs(),
                                                                    "ESRI Shapefile",
                                                                    onlySelected=True)
                            lyr3 = QgsVectorLayer(ruta_vectorial3, "Zonas similares", "ogr")
                            lyr3.loadNamedStyle(os.path.dirname(__file__) + '/styles/similar3.qml')
                            QgsProject.instance().addMapLayer(lyr3)
                    if len(ids) == 0:
                        print('no hay nada seleccionado')"""

                def vectorizar(raster, salida):
                    parameters = {'INPUT': raster.source(), 'BAND': 1, 'EXTRA': '', 'FIELD': "DN",
                                  'EIGHT_CONNECTEDNESS': False,
                                  'OUTPUT': carpeta + '/vectorizado.shp'}
                    processing.run("gdal:polygonize",
                                   parameters)  # .runAndLoadResults("gdal:polygonize",parameters)
                    # seleciono lo que me interesa
                    lyr = QgsVectorLayer(carpeta + '/vectorizado.shp', "nombre", "ogr")
                    # delete holes
                    deleteholes = processing.run("native:deleteholes", {
                        'INPUT': os.path.join(carpeta, 'vectorizado' + '.shp'),
                        'MIN_AREA': 800,
                        'OUTPUT': os.path.join(carpeta, 'vectorizado' + '000.shp')})['OUTPUT']
                    lyr = QgsVectorLayer(os.path.join(carpeta, 'vectorizado' + '000.shp'),
                                         'rasterdeentrada', "ogr")

                    # SUAVIZA
                    processing.run("native:smoothgeometry", {
                        'INPUT': os.path.join(carpeta, 'vectorizado' + '000.shp'),
                        'ITERATIONS': 2, 'OFFSET': 0.4, 'MAX_ANGLE': 180,
                        'OUTPUT': os.path.join(carpeta, 'vectorizado99' + '.shp')})
                    lyr = QgsVectorLayer(os.path.join(carpeta, 'vectorizado99' + '.shp'),
                                         'rasterdeentrada', "ogr")

                    # hago una selecion de los elementos con dn=1, anado la informacion a la tabla y creo una capa nueva  ojo deberia hacer una funcion para emplearlo mas veces.
                    layer = lyr  # iface.activeLayer()
                    print("paso11 de agregado")
                    expression = QgsExpression(u'"DN" = 1')
                    print("paso12 de agregado")
                    # Added / changed lines ##########
                    context = QgsExpressionContext()
                    scope = QgsExpressionContextScope()
                    context.appendScope(scope)
                    print("paso13 de agregado")
                    layer = lyr
                    feats = []
                    ids = []
                    for feat in layer.getFeatures():
                        scope.setFeature(feat)
                        result = expression.evaluate(context)
                        if result:
                            feats.append(feat)
                            ids.append(feat.id())
                            # areas.append(feat.geometry().area() )

                    if len(ids) > 0:

                        print("paso14 de agregado")

                        lyr.selectByIds(ids)
                        # lyr es la capa de entrada, la origen ue contiene todos los elementos
                        output_path = os.path.join(carpeta, 'vectorizado' + '2.shp')
                        QgsVectorFileWriter.writeAsVectorFormat(lyr, output_path, "CP120", lyr.crs(),
                                                                "ESRI Shapefile",
                                                                onlySelected=True)
                        lyr2 = QgsVectorLayer(
                            os.path.join(carpeta, 'vectorizado' + '2.shp'),
                            'rasterdeentrada' + str("2"), "ogr")
                        #QgsProject.instance().addMapLayer(lyr2)
                        print("en teoria ha hecho la seleccion")

                        # calcula la superficie de esta capa pero no en todos los registros
                        layer = QgsVectorLayer(
                            os.path.join(carpeta, 'vectorizado' + '2.shp'),
                            'rasterdeentrada' + str("2"), "ogr")
                        # layer=lyr2
                        provider = layer.dataProvider()
                        print("layer get features")
                        areas = [feat.geometry().area() for feat in layer.getFeatures()]
                        indice = [feat.id() for feat in layer.getFeatures()]
                        # print (indice)
                        field = QgsField("area", QVariant.Int)
                        provider.addAttributes([field])
                        layer.updateFields()
                        idx = layer.fields().indexFromName('area')  ###ojo aqui es donde da cero el indice
                        long = len(indice)
                        print("long")
                        print(long)
                        i = 0
                        print("pasa por aqui2")
                        while i < long:
                            new_values = {idx: float(areas[i])}
                            # print ("pasa por aqui3")
                            provider.changeAttributeValues({indice[i]: new_values})
                            # print ("pasa por aqui4")
                            i = i + 1
                        layer.updateFields()
                        print("pasa por aqui5")

                        # selecciono las teselas mayor de una superficie dada.

                        print("paso11 de agregado")
                        expression = QgsExpression(u'"area" > 2500')
                        print("paso12 de agregado")
                        context = QgsExpressionContext()
                        scope = QgsExpressionContextScope()
                        context.appendScope(scope)

                        feats = []
                        ids = []
                        for feat in layer.getFeatures():
                            scope.setFeature(feat)
                            result = expression.evaluate(context)
                            if result:
                                feats.append(feat)
                                ids.append(feat.id())
                                # areas.append(feat.geometry().area() )

                        if len(ids) > 0:
                            # print ("len feats")
                            # print( len( feats))
                            print("paso14 de agregado")
                            # prov.addFeatures(feats)
                            lyr2.selectByIds(ids)
                            # lyr es la capa de entrada, la origen ue contiene todos los elementos
                            output_path = os.path.join(carpeta, 'vectorial' + '3.shp')
                            QgsVectorFileWriter.writeAsVectorFormat(lyr2, output_path, "CP120", lyr.crs(),
                                                                    "ESRI Shapefile",
                                                                    onlySelected=True)

                            #QgsProject.instance().addMapLayer(lyr3)
                            print("en teoria ha hecho la seleccion2")









                    #ESTO ES EL RESULTADO DE VECTORIAL .
                            ruta_vectorial3=os.path.join(carpeta, 'vectorial' + '3.shp')
                            lyr3 = QgsVectorLayer(ruta_vectorial3, "Zonas similares", "ogr")
                            lyr3.loadNamedStyle(os.path.dirname(__file__) + '/styles/similar3.qml')
                            QgsProject.instance().addMapLayer(lyr3)
                    if len(ids) == 0:
                        print('no hay nada seleccionado')

                def agrega(rlayer):

                    # suavizado
                    parametros = {'INPUT': rlayer.source(), 'METHOD': 0, 'MODE': 1, 'RADIUS': 4,
                                  'RESULT': carpeta + "/suavizado.sdat"}
                    suavizado = processing.run('saga:simplefilter', parametros)['RESULT']
                    rlayer1 = QgsRasterLayer(suavizado, "suavizado")
                    # QgsProject.instance().addMapLayers([rlayer1])
                    # filtrado
                    entries = []
                    layer1 = QgsRasterCalculatorEntry()
                    layer1.ref = 'layer1@1'
                    layer1.raster = rlayer1
                    layer1.bandNumber = 1
                    entries.append(layer1)
                    # mayor de umbral
                    output_raster = carpeta + "/suavizado_seleccionado.tif"
                    calc = QgsRasterCalculator('(layer1@1 > 0.2 )', output_raster, 'GTiff', rlayer1.extent(),
                                               rlayer1.width(),
                                               rlayer1.height(), entries)
                    calc.processCalculation()
                    rlayer2 = QgsRasterLayer(output_raster, "suavizado_seleccionado")
                    # QgsProject.instance().addMapLayers([rlayer2])
                    # suavizado2
                    parametros = {'INPUT': rlayer2.source(), 'METHOD': 0, 'MODE': 1, 'RADIUS': 2,
                                  'RESULT': carpeta + "/suavizado2.sdat"}
                    suavizado2 = processing.run('saga:simplefilter', parametros)['RESULT']
                    rlayer3 = QgsRasterLayer(suavizado2, "suavizado2")
                    # QgsProject.instance().addMapLayers([rlayer3])
                    # filtrado2
                    entries = []
                    layer2 = QgsRasterCalculatorEntry()
                    layer2.ref = 'layer2@1'
                    layer2.raster = rlayer3
                    layer2.bandNumber = 1
                    entries.append(layer2)
                    # mayor de umbral
                    output_raster = carpeta + "/suavizado_seleccionado2.tif"
                    calc = QgsRasterCalculator('(layer2@1 > 0.5 )', output_raster, 'GTiff', rlayer3.extent(),
                                               rlayer3.width(),
                                               rlayer3.height(), entries)
                    calc.processCalculation()
                    rlayer4 = QgsRasterLayer(output_raster, "suavizado_seleccionado2")
                    # QgsProject.instance().addMapLayers([rlayer4])
                    return rlayer4

                def agrega2(rlayer, radio, filtro):
                    # filtro para rellenar huecos
                    print("empieza agregado")
                    # horaempiezaagregado = time.time()
                    # A puntos
                    input1 = rlayer.source()
                    output1 = carpeta + "/suavizado.shp"
                    apuntos = processing.run("native:pixelstopoints", {
                        'INPUT_RASTER': input1,
                        'RASTER_BAND': 1, 'FIELD_NAME': 'VALUE', 'OUTPUT': output1})['OUTPUT']
                    # mapa de calor
                    output2 = os.path.join(carpeta, "suavizado_seleccionado.tif")
                    mapacalor = processing.run("qgis:heatmapkerneldensityestimation", {
                        'INPUT': output1,
                        'RADIUS': radio, 'RADIUS_FIELD': '', 'PIXEL_SIZE': 2, 'WEIGHT_FIELD': 'VALUE', 'KERNEL': 3,
                        'DECAY': None, 'OUTPUT_VALUE': 0, 'OUTPUT': output2})['OUTPUT']
                    rlayer0 = QgsRasterLayer(mapacalor, "mapacalor")

                    entries = []
                    layer5 = QgsRasterCalculatorEntry()
                    layer5.ref = 'layer5@1'
                    layer5.raster = rlayer0
                    layer5.bandNumber = 1
                    entries.append(layer5)
                    # mayor de 1
                    # mayor de umbral
                    output44 = os.path.join(carpeta, "suavizado_seleccionado1.tif")
                    calc = QgsRasterCalculator('(layer5@1 > {} )'.format(filtro), output44, 'GTiff', rlayer0.extent(),
                                               rlayer0.width(),
                                               rlayer0.height(), entries)
                    calc.processCalculation()
                    rlayer44 = QgsRasterLayer(output44, "mapacalor_seleccionado")
                    return rlayer44

                    """# suavizado
                    parametros = {'INPUT': rlayer.source(), 'METHOD': 0, 'MODE': 1, 'RADIUS': 4,
                                  'RESULT': carpeta + "/suavizado.sdat"}
                    suavizado = processing.run('saga:simplefilter', parametros)['RESULT']
                    rlayer1 = QgsRasterLayer(suavizado, "suavizado")
                    # QgsProject.instance().addMapLayers([rlayer1])
                    # filtrado
                    entries = []
                    layer1 = QgsRasterCalculatorEntry()
                    layer1.ref = 'layer1@1'
                    layer1.raster = rlayer1
                    layer1.bandNumber = 1
                    entries.append(layer1)
                    # mayor de umbral
                    output_raster = carpeta + "/suavizado_seleccionado.tif"
                    calc = QgsRasterCalculator('(layer1@1 > 0.2 )', output_raster, 'GTiff', rlayer1.extent(),
                                               rlayer1.width(),
                                               rlayer1.height(), entries)
                    calc.processCalculation()
                    rlayer2 = QgsRasterLayer(output_raster, "suavizado_seleccionado")
                    # QgsProject.instance().addMapLayers([rlayer2])
                    # suavizado2
                    parametros = {'INPUT': rlayer2.source(), 'METHOD': 0, 'MODE': 1, 'RADIUS': 2,
                                  'RESULT': carpeta + "/suavizado2.sdat"}
                    suavizado2 = processing.run('saga:simplefilter', parametros)['RESULT']
                    rlayer3 = QgsRasterLayer(suavizado2, "suavizado2")
                    # QgsProject.instance().addMapLayers([rlayer3])
                    # filtrado2
                    entries = []
                    layer2 = QgsRasterCalculatorEntry()
                    layer2.ref = 'layer2@1'
                    layer2.raster = rlayer3
                    layer2.bandNumber = 1
                    entries.append(layer2)
                    # mayor de umbral
                    output_raster = carpeta + "/suavizado_seleccionado2.tif"
                    calc = QgsRasterCalculator('(layer2@1 > 0.5 )', output_raster, 'GTiff', rlayer3.extent(),
                                               rlayer3.width(),
                                               rlayer3.height(), entries)
                    calc.processCalculation()
                    rlayer4 = QgsRasterLayer(output_raster, "suavizado_seleccionado2")
                    # QgsProject.instance().addMapLayers([rlayer4])
                    return rlayer4"""

                def saca_valores_raster(nombre_raster, feats):
                    print('empiezo saca valores raster')
                    global tamano
                    # print("tamano ",tamano)
                    resultado = []  # lista con todos los valores
                    resumen = []  # lista con la media y desviacion de cada parcela.
                    if self.dentro:
                        rlayer=QgsRasterLayer(carpeta + '/' + nombre_raster + '.tif', nombre_raster)
                        print(carpeta + '/' + nombre_raster + '.tif')
                    else:
                        rlayer = QgsRasterLayer(carpeta[:-29] + '/' + nombre_raster + '.vrt', nombre_raster)
                        print(carpeta[:-29] + '/' + nombre_raster + '.vrt')
                    QgsProject.instance().addMapLayer(rlayer)
                    # for layer in QgsProject.instance().mapLayers().values():
                    # print(layer.name())
                    # print(layer.source())
                    # if layer.type() == QgsMapLayer.RasterLayer and layer.name() == nombre_raster:
                    # rlayer = layer
                    # saco puntos
                    xsize = rlayer.rasterUnitsPerPixelX()
                    ysize = rlayer.rasterUnitsPerPixelY()
                    provider = rlayer.dataProvider()
                    points = []
                    values = [[] for i in range(len(feats))]
                    # print(" ")
                    # print("Sacando Datos...")
                    # print(nombre_raster)
                    for k, feat in enumerate(feats):
                        extent = feat.geometry().boundingBox()
                        xmin = extent.xMinimum()
                        ymax = extent.yMaximum()
                        xmax = extent.xMaximum()
                        ymin = extent.yMinimum()

                        rows = int((ymax - ymin) / ysize)
                        cols = int((xmax - xmin) / xsize)
                        # print(rows)
                        # print(cols)

                        x = xmin
                        y = ymax

                        geom_feat = feat.geometry()

                        for i in range(rows + 1):
                            for j in range(cols + 1):
                                pt = QgsPointXY(x, y)
                                tmp_pt = QgsGeometry.fromPointXY(pt)
                                if tmp_pt.within(geom_feat):
                                    value = provider.identify(pt, QgsRaster.IdentifyFormatValue).results()[1]
                                    # print(value)
                                    if value == None:
                                        pass
                                    else:
                                        values[k].append(value)
                                        points.append(tmp_pt.asPoint())

                                x += xsize
                            x = xmin
                            y -= ysize
                    resultado.append(values)
                    for value in values:
                        resumen.append([np.mean(value), np.std(value)])
                        print('   Parcela-----N Pixels: {} Media: {:.2f} Desviacion Estandar: {:.2f}'.
                              format(np.size(value), np.mean(value), np.std(value)))
                    return resultado, resumen

                if self.dentro:
                    print('dentro de la junta')

                    def crea_carpeta(carpeta, carpeta_nueva):
                        from datetime import datetime
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        carpeta_nueva = os.path.join(carpeta, f'{carpeta_nueva}_{timestamp}')
                        os.makedirs(carpeta_nueva, exist_ok=True)
                        print("creo carpeta nueva")
                        return carpeta_nueva

                    def calculo(expresion, capa):
                        global layerglobal
                        calc = QgsRasterCalculator(expresion,
                                                   os.path.join(carpeta, capa + '.tif'),
                                                   'GTiff',
                                                   layerglobal.extent(),
                                                   layerglobal.width(),
                                                   layerglobal.height(),
                                                   entries)

                        calc.processCalculation()
                        del (calc)
                    print(nombre_pestaña2)
                    # compruebo que las capas necesarias estan cargadas
                    #como no existen las tengo que crear en tiempo real cada vez (OJO mirar si merece la pena buscar si ya existen para no tenerlo que rehacer)
                    #creo las capas mediante recorte de las capas de la red.
                    #hay que crear carpeta que no existe
                    entries = []
                    carpeta = os.path.dirname(self.dlg.ruta_zona_de_trabajo_2.text())
                    print('carpeta1 ',carpeta)

                    carpeta_nueva = carpeta + '/Silvilidar'
                    carpeta = crea_carpeta(carpeta, 'Silvilidar')

                    print("carpeta2 ", carpeta)
                    ruta_zona_trabajo = self.dlg.ruta_zona_de_trabajo_2.text()
                    layervectorial = QgsVectorLayer(ruta_zona_trabajo, "zona de trabajo", "ogr")
                    contenido = os.listdir(carpeta)
                    #carpeta_nueva = carpeta + '/Busca_similar'
                    carpeta2 = crea_carpeta(carpeta,'Busca_similar' )
                    print('carpeta3 ',carpeta2)

                    #debo crear las capas raster dentro de la carpeta
                    # cargo el raster de la junta hm NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName = r"\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\PNOA2_2017-2021\metricasLidar/Alt95_m_PNOA2.tif"  # r"C:\WORK\pruebas\metricasEjemplo\532_4642\alt\h95red.tif"  #
                    Layer = QgsRasterLayer(fileName, "altura de red")
                    print("ok, layer de altura 95 de la red")
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                                             'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                                             'DATA_TYPE': 0, 'OUTPUT': os.path.join(carpeta, 'hm.tif')})[
                        'OUTPUT']

                    # QgsProject.instance().addMapLayers([Layer])
                    layer2 = QgsRasterLayer(layer2, "altura de red")
                    # QgsProject.instance().addMapLayers([layer2])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    # StringToRaster(os.path.join(carpeta, 'Alt95_m_PNOA2.tif'),
                    StringToRaster(os.path.join(carpeta, 'hm.tif'),
                                   'hm')  # en teoria se sobre escribiria el raster hm@1
                    # print("creado el string to raster de h")

                    # cargo el raster de la junta hbc percentil 20 para calcular luego rc NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName = r'C:\WORK\pruebas\v2\Alt20SobreMdf_tlr_cut.tif'#r"C:\WORK\pruebas\metricasEjemplo\h20red.tif"  # r"R:\SIGMENA\prueba\2025\02\05\hbc_bengoa_malo.tif"viene de *_CeldasAlt20SobreMds_tlr_conUmbral2mSilvilidar
                    Layer = QgsRasterLayer(fileName, "altura de red")
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False,
                                             'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                                             'SET_RESOLUTION': False,
                                             'X_RESOLUTION': None, 'Y_RESOLUTION': None, 'DATA_TYPE': 0,
                                             'OUTPUT': os.path.join(carpeta, 'hbc.tif')})[
                        'OUTPUT']
                    layer2 = QgsRasterLayer(layer2, "base copa de red")
                    # QgsProject.instance().addMapLayers([Layer])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    StringToRaster(os.path.join(carpeta, 'hbc.tif'),
                                   'hbc')  # en teoria se sobre escribiria el raster hm@1
                    print("creado el string to raster de hbc")

                    # cargo el raster de la junta FCC NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName = r"//repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/dasoLidar/PNOA2_2017-2021/metricasLidar/Cob3m_PRT_PNOA2.tif"  # r"C:\WORK\pruebas\metricasEjemplo\532_4642\alt/fccred.tif"
                    Layer = QgsRasterLayer(fileName, "FCC DE RED")
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False,
                                             'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                                             'SET_RESOLUTION': False,
                                             'X_RESOLUTION': None, 'Y_RESOLUTION': None, 'DATA_TYPE': 0,
                                             'OUTPUT': os.path.join(carpeta, 'fcc.tif')})[
                        'OUTPUT']
                    layer2 = QgsRasterLayer(layer2, "fcc de red")
                    # QgsProject.instance().addMapLayers([Layer])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    StringToRaster(os.path.join(carpeta, 'fcc.tif'),
                                   'fcc')  # en teoria se sobre escribiria el raster fcc@1
                    print("creado el string to raster de fcc")

                    # cargo el fcc de matorral
                    # cargo el raster de la junta FCC NO BUENO OJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJOJO
                    fileName = r"C:\WORK\pruebas\metricasEjemplo\532_4642\alt/fccmatred.tif"  ##r"//repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/dasoLidar/PNOA2_2017-2021/metricasLidar/Cob3m_PRT_PNOA2.tif"
                    Layer = QgsRasterLayer(fileName, "FCC MATORRAL DE RED")
                    # recortar raster con el shape
                    layer2 = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT': Layer, 'MASK': layervectorial, 'NODATA': None,
                                             'ALPHA_BAND': False,
                                             'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                                             'SET_RESOLUTION': False,
                                             'X_RESOLUTION': None, 'Y_RESOLUTION': None, 'DATA_TYPE': 0,
                                             'OUTPUT': os.path.join(carpeta, 'fcc_matorral.tif')})[
                        'OUTPUT']
                    layer2 = QgsRasterLayer(layer2, "fcc de red")
                    # QgsProject.instance().addMapLayers([Layer])
                    print(layer2)
                    print("cargado el raster recortado de la junta")
                    StringToRaster(os.path.join(carpeta, 'fcc_matorral.tif'),
                                   'fccmatorral')  # en teoria se sobre escribiria el raster fcc@1


                    print("creado el string to raster de fcc matorral")
                    calculo('100 * (  hm@1    -  ( hbc@1 / 100 ) ) /   hm@1  ', 'rc')

                    StringToRaster(os.path.join(carpeta, 'rc.tif'), "rc")

                    # falta sacar la lc
                    calculo('  hm@1  - ( hbc@1 / 100 ) ', "lc")
                    StringToRaster(os.path.join(carpeta, 'lc.tif'), "lc")

                    #hasta aqui común para todos

                    if nombre_pestaña2 == 'pixel_a_pixel':
                        print("empiezo pixel a pixel dentro de la junta")
                        coef_hm = float(self.dlg.coef_hm1.text().replace(',', '.'))
                        coef_hbc = float(self.dlg.coef_hbc1.text().replace(',', '.'))
                        coef_rc = float(self.dlg.coef_rc1.text().replace(',', '.'))
                        coef_lc = float(self.dlg.coef_lc1.text().replace(',', '.'))
                        coef_fcc = float(self.dlg.coef_fcc1.text().replace(',', '.'))
                        coef_fcc_m = float(self.dlg.coef_matorral1.text().replace(',', '.'))
                        ruta_muestra = self.dlg.ruta_muestra_similar.text()
                        capas_raster_de_interes = [] #para comparacion de pixeles

                        if self.dlg.checkBox_hm1.isChecked():
                            capas_raster_de_interes.append('HM')
                        if self.dlg.checkBox_hbc1.isChecked():
                            capas_raster_de_interes.append('HBC')
                        if self.dlg.checkBox_lc1.isChecked():
                            capas_raster_de_interes.append('LC')
                        if self.dlg.checkBox_rc1.isChecked():
                            capas_raster_de_interes.append('RC')
                        if self.dlg.checkBox_fcc1.isChecked():
                            capas_raster_de_interes.append('FCC')
                        if self.dlg.checkBox_matorral1.isChecked():
                            capas_raster_de_interes.append('FCC_MATORRAL')
                        print(capas_raster_de_interes)
                        mapcanvas = iface.mapCanvas()
                        # capa vectorial
                        layers = mapcanvas.layers()
                        layervectorial = QgsVectorLayer(ruta_muestra, "muestra", "ogr")
                        feats = [feat for feat in
                                 layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]

                        """def lenguaje_informe():
                            def lenguaje_equipo():
                                # es = castellano
                                import locale
                                idioma = locale.getdefaultlocale()[0][0:2]
                                return idioma

                            def lenguaje_qgis():
                                # es = castellano
                                idioma = QSettings().value("locale/userLocale")[0:2]
                                return idioma

                            lenguaje_equipo = lenguaje_equipo()
                            lenguaje_qgis = lenguaje_qgis()
                            if lenguaje_equipo and lenguaje_qgis == "es":
                                return "es"
                            else:
                                return "en"
                        lenguaje_informe= lenguaje_informe()"""

                        tablas_de_interes = []
                        graficas_de_interes = []
                        filtrado_de_interes = []  # pixeles similares

                        for nombre in capas_raster_de_interes:
                            if nombre == 'HM':
                                resultado_hm = saca_valores_raster(nombre, feats)
                                resultado_hm_simplificado = simplificar_lista(resultado_hm[0])
                                print("he sacado los valores de HM simplificado")
                                tabla_hm = crea_tabla(resultado_hm)
                                tablas_de_interes.append(tabla_hm)
                                grafica_hm = grafica_histograma(resultado_hm_simplificado,
                                                                estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                    0][0],
                                                                estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                    0][1], "hm")
                                graficas_de_interes.append(grafica_hm)
                                filtrado_hm = filtro_raster_intervalo(nombre,
                                                                      estadisticas_lista(resultado_hm_simplificado,
                                                                                         coef_hm)[0])
                                filtrado_de_interes.append(filtrado_hm)
                                # comparable=np.array([6,7,8,8,8,10,10,10,10,10,11,11,11,11])
                                # nuevo=compara_histogramas(resultado_hm_simplificado,comparable)
                                print("Analisis de histogramas de HM")
                            if nombre == 'HBC':
                                resultado_hbc = saca_valores_raster(nombre, feats)
                                resultado_hbc_simplificado = simplificar_lista(resultado_hbc[0])
                                tabla_hbc = crea_tabla(resultado_hbc)
                                tablas_de_interes.append(tabla_hbc)
                                grafica_hbc = grafica_histograma(resultado_hbc_simplificado,
                                                                 estadisticas_lista(resultado_hbc_simplificado,
                                                                                    coef_hbc)[0][0],
                                                                 estadisticas_lista(resultado_hbc_simplificado,
                                                                                    coef_hbc)[0][1], "hbc")
                                graficas_de_interes.append(grafica_hbc)
                                filtrado_hbc = filtro_raster_intervalo(nombre,
                                                                       estadisticas_lista(resultado_hbc_simplificado,
                                                                                          coef_hbc)[0])
                                filtrado_de_interes.append(filtrado_hbc)
                                print("Analisis de histogramas de HBC")
                                # recorre_raster_ventanas(nombre)
                            if nombre == 'LC':
                                resultado_lc = saca_valores_raster(nombre, feats)
                                resultado_lc_simplificado = simplificar_lista(resultado_lc[0])
                                tabla_lc = crea_tabla(resultado_lc)
                                tablas_de_interes.append(tabla_lc)
                                grafica_lc = grafica_histograma(resultado_lc_simplificado,
                                                                estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                    0][0],
                                                                estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                    0][1], "lc")
                                graficas_de_interes.append(grafica_lc)
                                filtrado_lc = filtro_raster_intervalo(nombre,
                                                                      estadisticas_lista(resultado_lc_simplificado,
                                                                                         coef_lc)[0])
                                filtrado_de_interes.append(filtrado_lc)
                                print("Analisis de histogramas de LC")
                                # recorre_raster_ventanas(nombre)
                            if nombre == 'RC':
                                resultado_rc = saca_valores_raster(nombre, feats)
                                resultado_rc_simplificado = simplificar_lista(resultado_rc[0])
                                tabla_rc = crea_tabla(resultado_rc)
                                tablas_de_interes.append(tabla_rc)
                                grafica_rc = grafica_histograma(resultado_rc_simplificado,
                                                                estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                    0][0],
                                                                estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                    0][1], "rc")
                                graficas_de_interes.append(grafica_rc)
                                filtrado_rc = filtro_raster_intervalo(nombre,
                                                                      estadisticas_lista(resultado_rc_simplificado,
                                                                                         coef_rc)[0])
                                filtrado_de_interes.append(filtrado_rc)
                                print("Analisis de histogramas de LC")
                                # recorre_raster_ventanas(nombre)
                            if nombre == 'FCC':
                                resultado_fcc = saca_valores_raster(nombre, feats)
                                resultado_fcc_simplificado = simplificar_lista(resultado_fcc[0])
                                tabla_fcc = crea_tabla(resultado_fcc)
                                tablas_de_interes.append(tabla_fcc)
                                grafica_fcc = grafica_histograma(resultado_fcc_simplificado,
                                                                 estadisticas_lista(resultado_fcc_simplificado,
                                                                                    coef_fcc)[0][0],
                                                                 estadisticas_lista(resultado_fcc_simplificado,
                                                                                    coef_fcc)[0][1], "fcc")
                                graficas_de_interes.append(grafica_fcc)
                                filtrado_fcc = filtro_raster_intervalo(nombre,
                                                                       estadisticas_lista(resultado_fcc_simplificado,
                                                                                          coef_fcc)[0])
                                filtrado_de_interes.append(filtrado_fcc)
                                print("Analisis de histogramas de FCC")
                                # recorre_raster_ventanas(nombre)
                            if nombre == 'FCC_MATORRAL':
                                resultado_fcc_m = saca_valores_raster(nombre, feats)
                                resultado_fcc_m_simplificado = simplificar_lista(resultado_fcc_m[0])
                                tabla_fcc_m = crea_tabla(resultado_fcc_m)
                                tablas_de_interes.append(tabla_fcc_m)
                                grafica_fcc_m = grafica_histograma(resultado_fcc_m_simplificado,
                                                                   estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                      coef_fcc)[0][0],
                                                                   estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                      coef_fcc)[0][1], "fcc_m")
                                graficas_de_interes.append(grafica_fcc_m)
                                filtrado_fcc_m = filtro_raster_intervalo(nombre,
                                                                         estadisticas_lista(
                                                                             resultado_fcc_m_simplificado, coef_fcc_m)[
                                                                             0])
                                filtrado_de_interes.append(filtrado_fcc_m)
                                print("Analisis de histogramas de FCC_MATORRAL")
                                # recorre_raster_ventanas(nombre)
                        print(capas_raster_de_interes)
                        print(filtrado_de_interes)
                        crea_html(capas_raster_de_interes, tablas_de_interes,
                                  graficas_de_interes)

                        # print(resultado)
                        # epsg = layervectorial.crs().postgisSrid()
                        # elimino las capas que he cargado durante el proceso
                        capas = QgsProject.instance().mapLayers()
                        for capa in capas:
                            if capa not in capasoriginales:
                                QgsProject.instance().removeMapLayers([capa])

                        # busca las celdas que encuentran lo anterior (multiplica)
                        multiplicado = multiplica_rasters(filtrado_de_interes)
                        # raster = agrega(multiplicado)

                        # ojo deshacer si falla el agregado de buscar cosas similares. son 2 lineas.
                        raster = agrega2(multiplicado, 30, 1)  # 10,0.49)
                        vectorizar(raster, carpeta + "similar3.shp")

                        # lo mismo pero para las zonas similares segun histogramas
                        # busca las celdas que encuentran lo anterior (multiplica)
                        # multiplicado = multiplica_rasters(filtrado_de_interes2)

                    if nombre_pestaña2 == 'por_zonas':

                        print("llego a por zonas")
                        print(nombre_pestaña2)
                        # compruebo que las capas necesarias estan cargadas
                        # contenido = os.listdir(carpeta)
                        """if 'Teselas_merged.shp' not in contenido:
                            iface.messageBar().pushMessage("Error",
                                                           "Antes de buscar zonas similares hay que ejecutar la primera pestaña de Silvilidar",
                                                           duration=15)"""
                        # else:
                        #carpeta_nueva = carpeta + '/Busca_similar'

                        #carpeta = crea_carpeta(carpeta, carpeta_nueva)
                        print(carpeta)
                        # lo quito porque aqui no hay coeficientes, me servira despues para configurar el grado de similitud
                        coef_hm = 1  # float(self.dlg.coef_hm2.text().replace(',', '.'))
                        coef_hbc = 1  # float(self.dlg.coef_hbc2.text().replace(',', '.'))
                        coef_rc = 1  # float(self.dlg.coef_rc2.text().replace(',', '.'))
                        coef_lc = 1  # float(self.dlg.coef_lc2.text().replace(',', '.'))
                        coef_fcc = 1  # float(self.dlg.coef_fcc2.text().replace(',', '.'))
                        coef_fcc_m = 1  # float(self.dlg.coef_matorral2.text().replace(',', '.'))
                        ruta_muestra = self.dlg.ruta_muestra_similar.text()
                        correlacion = float(self.dlg.coeficiente_correlacion.text().replace(',', '.'))
                        solape = float(self.dlg.solape.text().replace(',', '.'))
                        capas_raster_de_interes2 = []  # para comparacion de pixeles
                        if self.dlg.checkBox_hm2.isChecked():
                            capas_raster_de_interes2.append('HM')
                        if self.dlg.checkBox_hbc2.isChecked():
                            capas_raster_de_interes2.append('HBC')
                        if self.dlg.checkBox_lc2.isChecked():
                            capas_raster_de_interes2.append('LC')
                        if self.dlg.checkBox_rc2.isChecked():
                            capas_raster_de_interes2.append('RC')
                        if self.dlg.checkBox_fcc2.isChecked():
                            capas_raster_de_interes2.append('FCC')
                        if self.dlg.checkBox_matorral2.isChecked():
                            capas_raster_de_interes2.append('FCC_MATORRAL')
                        mapcanvas = iface.mapCanvas()
                        """# capa vectorial
                        layers = mapcanvas.layers()
                        # layervectorial = qgis.utils.iface.activeLayer() # si trabajas interactivamente
                        layervectorial = QgsVectorLayer(ruta_muestra, "muestra", "ogr")
                        feats = [feat for feat in
                                 layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]"""
                        mapcanvas = iface.mapCanvas()
                        # capa vectorial
                        layers = mapcanvas.layers()
                        # layervectorial = qgis.utils.iface.activeLayer() # si trabajas interactivamente
                        layervectorial = QgsVectorLayer(ruta_muestra, "muestra", "ogr")
                        feats = [feat for feat in
                                 layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]

                        print('capas_raster_de_interes2 ', capas_raster_de_interes2)
                        print(nombre_pestaña2)
                        print(capas_raster_de_interes2)
                        # ojo de aqui en adelante modificar
                        tablas_de_interes2 = []
                        graficas_de_interes2 = []
                        filtrado_de_interes2 = []  # pixeles similares
                        for nombre in capas_raster_de_interes2:
                            if nombre == 'HM':
                                resultado_hm = saca_valores_raster(nombre, feats)
                                resultado_hm_simplificado = simplificar_lista(resultado_hm[0])
                                print("he sacado los valores de HM simplificado")
                                tabla_hm = crea_tabla(resultado_hm)
                                tablas_de_interes2.append(tabla_hm)
                                grafica_hm = grafica_histograma(resultado_hm_simplificado,
                                                                estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                    0][0],
                                                                estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                    0][1], "hm")
                                graficas_de_interes2.append(grafica_hm)
                                filtrado_hm = filtro_raster_intervalo(nombre,
                                                                      estadisticas_lista(resultado_hm_simplificado,
                                                                                         coef_hm)[0])
                                filtrado_de_interes2.append(filtrado_hm)
                                # comparable=np.array([6,7,8,8,8,10,10,10,10,10,11,11,11,11])
                                # nuevo=compara_histogramas(resultado_hm_simplificado,comparable)
                                print("Analisis de histogramas de HM")
                                recorre_raster_ventanas(
                                    nombre)  # , 12)#a mayor numero menos numero de ventanas. es el tamano de las ventanas en numero de pixeles

                            if nombre == 'HBC':
                                resultado_hbc = saca_valores_raster(nombre, feats)
                                resultado_hbc_simplificado = simplificar_lista(resultado_hbc[0])
                                tabla_hbc = crea_tabla(resultado_hbc)
                                tablas_de_interes2.append(tabla_hbc)
                                grafica_hbc = grafica_histograma(resultado_hbc_simplificado,
                                                                 estadisticas_lista(resultado_hbc_simplificado,
                                                                                    coef_hbc)[0][0],
                                                                 estadisticas_lista(resultado_hbc_simplificado,
                                                                                    coef_hbc)[0][1], "hbc")
                                graficas_de_interes2.append(grafica_hbc)
                                filtrado_hbc = filtro_raster_intervalo(nombre,
                                                                       estadisticas_lista(resultado_hbc_simplificado,
                                                                                          coef_hbc)[0])
                                filtrado_de_interes2.append(filtrado_hbc)
                                print("Analisis de histogramas de HBC")
                                recorre_raster_ventanas(nombre)
                            if nombre == 'LC':
                                resultado_lc = saca_valores_raster(nombre, feats)
                                resultado_lc_simplificado = simplificar_lista(resultado_lc[0])
                                tabla_lc = crea_tabla(resultado_lc)
                                tablas_de_interes2.append(tabla_lc)
                                grafica_lc = grafica_histograma(resultado_lc_simplificado,
                                                                estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                    0][0],
                                                                estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                    0][1], "lc")
                                graficas_de_interes2.append(grafica_lc)
                                filtrado_lc = filtro_raster_intervalo(nombre,
                                                                      estadisticas_lista(resultado_lc_simplificado,
                                                                                         coef_lc)[0])
                                filtrado_de_interes2.append(filtrado_lc)
                                print("Analisis de histogramas de LC")
                                recorre_raster_ventanas(nombre)
                            if nombre == 'RC':
                                resultado_rc = saca_valores_raster(nombre, feats)
                                resultado_rc_simplificado = simplificar_lista(resultado_rc[0])
                                tabla_rc = crea_tabla(resultado_rc)
                                tablas_de_interes2.append(tabla_rc)
                                grafica_rc = grafica_histograma(resultado_rc_simplificado,
                                                                estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                    0][0],
                                                                estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                    0][1], "rc")
                                graficas_de_interes2.append(grafica_rc)
                                filtrado_rc = filtro_raster_intervalo(nombre,
                                                                      estadisticas_lista(resultado_rc_simplificado,
                                                                                         coef_rc)[0])
                                filtrado_de_interes2.append(filtrado_rc)
                                print("Analisis de histogramas de LC")
                                recorre_raster_ventanas(nombre)
                            if nombre == 'FCC':
                                resultado_fcc = saca_valores_raster(nombre, feats)
                                resultado_fcc_simplificado = simplificar_lista(resultado_fcc[0])
                                tabla_fcc = crea_tabla(resultado_fcc)
                                tablas_de_interes2.append(tabla_fcc)
                                grafica_fcc = grafica_histograma(resultado_fcc_simplificado,
                                                                 estadisticas_lista(resultado_fcc_simplificado,
                                                                                    coef_fcc)[0][0],
                                                                 estadisticas_lista(resultado_fcc_simplificado,
                                                                                    coef_fcc)[0][1], "fcc")
                                graficas_de_interes2.append(grafica_fcc)
                                filtrado_fcc = filtro_raster_intervalo(nombre,
                                                                       estadisticas_lista(resultado_fcc_simplificado,
                                                                                          coef_fcc)[0])
                                filtrado_de_interes2.append(filtrado_fcc)
                                print("Analisis de histogramas de FCC")
                                recorre_raster_ventanas(nombre)
                            if nombre == 'FCC_MATORRAL':
                                resultado_fcc_m = saca_valores_raster(nombre, feats)
                                resultado_fcc_m_simplificado = simplificar_lista(resultado_fcc_m[0])
                                tabla_fcc_m = crea_tabla(resultado_fcc_m)
                                tablas_de_interes2.append(tabla_fcc_m)
                                grafica_fcc_m = grafica_histograma(resultado_fcc_m_simplificado,
                                                                   estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                      coef_fcc)[0][0],
                                                                   estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                      coef_fcc)[0][1], "fcc_m")
                                graficas_de_interes2.append(grafica_fcc_m)
                                filtrado_fcc_m = filtro_raster_intervalo(nombre,
                                                                         estadisticas_lista(
                                                                             resultado_fcc_m_simplificado, coef_fcc_m)[
                                                                             0])
                                filtrado_de_interes2.append(filtrado_fcc_m)
                                print("Analisis de histogramas de FCC_MATORRAL")
                                recorre_raster_ventanas(nombre)
                        print(capas_raster_de_interes2)
                        print(filtrado_de_interes2)
                        crea_html(capas_raster_de_interes2, tablas_de_interes2,
                                  graficas_de_interes2)  # igual hay que hacer una modificacion para que no pinte los rangos en rojo, porque en este caso no tiene sentido

                        # print(resultado)
                        # epsg = layervectorial.crs().postgisSrid()

                        # busca las celdas que encuentran lo anterior (multiplica)
                        multiplicado = multiplica_rasters(filtrado_de_interes2)
                        # elimino las capas que he cargado durante el proceso
                        capas = QgsProject.instance().mapLayers()
                        for capa in capas:
                            if capa not in capasoriginales:
                                QgsProject.instance().removeMapLayers([capa])
                        # cargo la capa de poligonos con las zonas similares

                        # vlayer = QgsVectorLayer(os.path.join(carpeta, 'similares.shp'), 'Zonas con histograma similar', "ogr")

                        # Añadir la capa al proyecto actual (opcional)
                        # QgsProject.instance().addMapLayer(vlayer)
                        # raster = agrega(multiplicado)
                        # raster = agrega2(multiplicado,10,0.49)
                        # vectorizar(raster, carpeta + "similar3.shp")

                        # miro que capas vectoriales he creado y no estan vacias y hago la interseccion entre ellas. El resultado despues lo disuelvo.
                        rutas_capas_salida = []
                        for nombre_raster in capas_raster_de_interes2:
                            ruta = carpeta + f"/similares_{nombre_raster}.shp"
                            rutas_capas_salida.append(ruta)
                        if len(rutas_capas_salida) == 0:
                            print("no hay nada que intersectar")
                        if len(rutas_capas_salida) == 1:
                            print("no hago intersecccion, solo hay una capa y es lo que devuelvo")
                            print(rutas_capas_salida[0])

                            resultado0 = QgsVectorLayer(rutas_capas_salida[0], "Zonas similares por histograma", "ogr")

                            disuelto = processing.run("native:dissolve",
                                                      {'INPUT': resultado0,
                                                       'FIELD': ['DN'],
                                                       'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                            QgsVectorFileWriter.writeAsVectorFormat(disuelto,
                                                                    carpeta + '/Zonas_similares_por_histograma.shp',
                                                                    "CP120", disuelto.crs(),
                                                                    "ESRI Shapefile")
                            resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp',
                                                       "Zonas similares por histograma", "ogr")
                        if len(rutas_capas_salida) == 2:
                            print("hago interseccion de dos capas")
                            capa1 = QgsVectorLayer(rutas_capas_salida[0], "capa1", "ogr")
                            capa2 = QgsVectorLayer(rutas_capas_salida[1], "capa2", "ogr")

                            interseccion = processing.run("native:intersection",
                                                          {'INPUT': capa1,
                                                           'OVERLAY': capa2,
                                                           'OUTPUT': 'TEMPORARY_OUTPUT'})
                            print('interseccion', interseccion['OUTPUT'])

                            disuelto = processing.run("native:dissolve",
                                                      {'INPUT': interseccion['OUTPUT'],
                                                       'FIELD': ['DN'],
                                                       'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                            QgsVectorFileWriter.writeAsVectorFormat(disuelto,
                                                                    carpeta + '/Zonas_similares_por_histograma.shp',
                                                                    "CP120", capa1.crs(),
                                                                    "ESRI Shapefile")
                            resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp',
                                                       "Zonas similares por histograma", "ogr")
                        """if len(rutas_capas_salida)==3:
                            print("hago interseccion de tres capas")
                            capa1 = QgsVectorLayer(rutas_capas_salida[0], "capa1", "ogr")
                            capa2 = QgsVectorLayer(rutas_capas_salida[1], "capa2", "ogr")
                            capa3 = QgsVectorLayer(rutas_capas_salida[2], "capa3", "ogr")

                            interseccion0 = processing.run("native:intersection",
                                {'INPUT': capa1,
                                'OVERLAY': capa2,
                                'OUTPUT': 'TEMPORARY_OUTPUT'})
                            print('interseccion',interseccion0['OUTPUT'])
                            interseccion = processing.run("native:intersection",
                                                           {'INPUT': interseccion0['OUTPUT'],
                                                            'OVERLAY': capa3,
                                                            'OUTPUT': 'TEMPORARY_OUTPUT'})
                            disuelto = processing.run("native:dissolve",
                                {'INPUT': interseccion['OUTPUT'],
                                'FIELD': ['DN'],
                                'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                            QgsVectorFileWriter.writeAsVectorFormat(disuelto, carpeta + '/Zonas_similares_por_histograma.shp', "CP120", capa1.crs(),
                                                                    "ESRI Shapefile")
                            resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp', "Zonas similares por histograma", "ogr")"""
                        if 3 <= len(rutas_capas_salida) <= 6:
                            print(f"hago interseccion de {len(rutas_capas_salida)} capas")
                            capas = [QgsVectorLayer(ruta, f"capa{i + 1}", "ogr") for i, ruta in
                                     enumerate(rutas_capas_salida)]

                            interseccion = capas[0]
                            for i in range(1, len(capas)):
                                interseccion = processing.run("native:intersection", {
                                    'INPUT': interseccion,
                                    'OVERLAY': capas[i],
                                    'OUTPUT': 'TEMPORARY_OUTPUT'
                                })['OUTPUT']

                            disuelto = processing.run("native:dissolve", {
                                'INPUT': interseccion,
                                'FIELD': ['DN'],
                                'OUTPUT': 'TEMPORARY_OUTPUT'
                            })['OUTPUT']

                            QgsVectorFileWriter.writeAsVectorFormat(disuelto,
                                                                    carpeta + '/Zonas_similares_por_histograma.shp',
                                                                    "CP120", capas[0].crs(), "ESRI Shapefile")
                            resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp',
                                                       "Zonas similares por histograma", "ogr")

                            # lyr = QgsVectorLayer(carpeta + '/disuelto.shp', "Zonas similares", "ogr")
                        #print("voy a aplicar la simbologia en linea 3893")
                        #resultado.loadNamedStyle(os.path.dirname(__file__) + '/styles/similar3.qml')
                        QgsProject.instance().addMapLayer(resultado)
                        #print("capa cargada")
                else:
                    print('FUERA de la junta')
                    carpeta = self.dlg.carpetalaz.text()






                    if carpeta == '':
                        iface.messageBar().pushMessage("Error",
                                                       "Debe seleccionar la carpeta con los datos LiDAR ya procesados",
                                                       duration=15)
                    else:
                        if nombre_pestaña2 == 'pixel_a_pixel':
                            print(nombre_pestaña2)
                            # compruebo que las capas necesarias estan cargadas
                            """contenido = os.listdir(carpeta)
                            if 'Teselas_merged.shp' not in contenido:
                                iface.messageBar().pushMessage("Error",
                                                               "Antes de buscar zonas similares hay que ejecutar la primera pestaña de Silvilidar",
                                                               duration=15)
                            else:"""

                            carpeta_nueva = carpeta + '/Busca_similar'



                            carpeta = crea_carpeta(carpeta, carpeta_nueva)
                            print(carpeta)

                            coef_hm = float(self.dlg.coef_hm1.text().replace(',', '.'))
                            coef_hbc = float(self.dlg.coef_hbc1.text().replace(',', '.'))
                            coef_rc = float(self.dlg.coef_rc1.text().replace(',', '.'))
                            coef_lc = float(self.dlg.coef_lc1.text().replace(',', '.'))
                            coef_fcc = float(self.dlg.coef_fcc1.text().replace(',', '.'))
                            coef_fcc_m = float(self.dlg.coef_matorral1.text().replace(',', '.'))
                            ruta_muestra = self.dlg.ruta_muestra_similar.text()
                            capas_raster_de_interes = [] #para comparacion de pixeles

                            if self.dlg.checkBox_hm1.isChecked():
                                capas_raster_de_interes.append('HM')
                            if self.dlg.checkBox_hbc1.isChecked():
                                capas_raster_de_interes.append('HBC')
                            if self.dlg.checkBox_lc1.isChecked():
                                capas_raster_de_interes.append('LC')
                            if self.dlg.checkBox_rc1.isChecked():
                                capas_raster_de_interes.append('RC')
                            if self.dlg.checkBox_fcc1.isChecked():
                                capas_raster_de_interes.append('FCC')
                            if self.dlg.checkBox_matorral1.isChecked():
                                capas_raster_de_interes.append('FCC_MATORRAL')
                            print(capas_raster_de_interes)


                            mapcanvas = iface.mapCanvas()
                            # capa vectorial
                            layers = mapcanvas.layers()
                            # layervectorial = qgis.utils.iface.activeLayer() # si trabajas interactivamente
                            layervectorial = QgsVectorLayer(ruta_muestra, "muestra", "ogr")
                            feats = [feat for feat in
                                     layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]




                            """def lenguaje_informe():
                                def lenguaje_equipo():
                                    # es = castellano
                                    import locale
                                    idioma = locale.getdefaultlocale()[0][0:2]
                                    return idioma
    
                                def lenguaje_qgis():
                                    # es = castellano
                                    idioma = QSettings().value("locale/userLocale")[0:2]
                                    return idioma
    
                                lenguaje_equipo = lenguaje_equipo()
                                lenguaje_qgis = lenguaje_qgis()
                                if lenguaje_equipo and lenguaje_qgis == "es":
                                    return "es"
                                else:
                                    return "en"
                            lenguaje_informe= lenguaje_informe()"""



                            tablas_de_interes = []
                            graficas_de_interes = []
                            filtrado_de_interes = []#pixeles similares

                            for nombre in capas_raster_de_interes:
                                if nombre == 'HM':
                                    resultado_hm = saca_valores_raster(nombre, feats)
                                    resultado_hm_simplificado = simplificar_lista(resultado_hm[0])
                                    print("he sacado los valores de HM simplificado")
                                    tabla_hm = crea_tabla(resultado_hm)
                                    tablas_de_interes.append(tabla_hm)
                                    grafica_hm = grafica_histograma(resultado_hm_simplificado,
                                                                    estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                        0][0],
                                                                    estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                        0][1], "hm")
                                    graficas_de_interes.append(grafica_hm)
                                    filtrado_hm = filtro_raster_intervalo(nombre,
                                                                          estadisticas_lista(resultado_hm_simplificado,
                                                                                             coef_hm)[0])
                                    filtrado_de_interes.append(filtrado_hm)
                                    #comparable=np.array([6,7,8,8,8,10,10,10,10,10,11,11,11,11])
                                    #nuevo=compara_histogramas(resultado_hm_simplificado,comparable)
                                    print("Analisis de histogramas de HM")
                                    #recorre_raster_ventanas(nombre)#, 12)#a mayor numero menos numero de ventanas. es el tamano de las ventanas en numero de pixeles

                                if nombre == 'HBC':
                                    resultado_hbc = saca_valores_raster(nombre, feats)
                                    resultado_hbc_simplificado = simplificar_lista(resultado_hbc[0])
                                    tabla_hbc = crea_tabla(resultado_hbc)
                                    tablas_de_interes.append(tabla_hbc)
                                    grafica_hbc = grafica_histograma(resultado_hbc_simplificado,
                                                                     estadisticas_lista(resultado_hbc_simplificado,
                                                                                        coef_hbc)[0][0],
                                                                     estadisticas_lista(resultado_hbc_simplificado,
                                                                                        coef_hbc)[0][1], "hbc")
                                    graficas_de_interes.append(grafica_hbc)
                                    filtrado_hbc = filtro_raster_intervalo(nombre,
                                                                           estadisticas_lista(resultado_hbc_simplificado,
                                                                                              coef_hbc)[0])
                                    filtrado_de_interes.append(filtrado_hbc)
                                    print("Analisis de histogramas de HBC")
                                    #recorre_raster_ventanas(nombre)
                                if nombre == 'LC':
                                    resultado_lc = saca_valores_raster(nombre, feats)
                                    resultado_lc_simplificado = simplificar_lista(resultado_lc[0])
                                    tabla_lc = crea_tabla(resultado_lc)
                                    tablas_de_interes.append(tabla_lc)
                                    grafica_lc = grafica_histograma(resultado_lc_simplificado,
                                                                    estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                        0][0],
                                                                    estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                        0][1], "lc")
                                    graficas_de_interes.append(grafica_lc)
                                    filtrado_lc = filtro_raster_intervalo(nombre,
                                                                          estadisticas_lista(resultado_lc_simplificado,
                                                                                             coef_lc)[0])
                                    filtrado_de_interes.append(filtrado_lc)
                                    print("Analisis de histogramas de LC")
                                    #recorre_raster_ventanas(nombre)
                                if nombre == 'RC':
                                    resultado_rc = saca_valores_raster(nombre, feats)
                                    resultado_rc_simplificado = simplificar_lista(resultado_rc[0])
                                    tabla_rc = crea_tabla(resultado_rc)
                                    tablas_de_interes.append(tabla_rc)
                                    grafica_rc = grafica_histograma(resultado_rc_simplificado,
                                                                    estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                        0][0],
                                                                    estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                        0][1], "rc")
                                    graficas_de_interes.append(grafica_rc)
                                    filtrado_rc = filtro_raster_intervalo(nombre,
                                                                          estadisticas_lista(resultado_rc_simplificado,
                                                                                             coef_rc)[0])
                                    filtrado_de_interes.append(filtrado_rc)
                                    print("Analisis de histogramas de LC")
                                    #recorre_raster_ventanas(nombre)
                                if nombre == 'FCC':
                                    resultado_fcc = saca_valores_raster(nombre, feats)
                                    resultado_fcc_simplificado = simplificar_lista(resultado_fcc[0])
                                    tabla_fcc = crea_tabla(resultado_fcc)
                                    tablas_de_interes.append(tabla_fcc)
                                    grafica_fcc = grafica_histograma(resultado_fcc_simplificado,
                                                                     estadisticas_lista(resultado_fcc_simplificado,
                                                                                        coef_fcc)[0][0],
                                                                     estadisticas_lista(resultado_fcc_simplificado,
                                                                                        coef_fcc)[0][1], "fcc")
                                    graficas_de_interes.append(grafica_fcc)
                                    filtrado_fcc = filtro_raster_intervalo(nombre,
                                                                           estadisticas_lista(resultado_fcc_simplificado,
                                                                                              coef_fcc)[0])
                                    filtrado_de_interes.append(filtrado_fcc)
                                    print("Analisis de histogramas de FCC")
                                    #recorre_raster_ventanas(nombre)
                                if nombre == 'FCC_MATORRAL':
                                    resultado_fcc_m = saca_valores_raster(nombre, feats)
                                    resultado_fcc_m_simplificado = simplificar_lista(resultado_fcc_m[0])
                                    tabla_fcc_m = crea_tabla(resultado_fcc_m)
                                    tablas_de_interes.append(tabla_fcc_m)
                                    grafica_fcc_m = grafica_histograma(resultado_fcc_m_simplificado,
                                                                       estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                          coef_fcc)[0][0],
                                                                       estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                          coef_fcc)[0][1], "fcc_m")
                                    graficas_de_interes.append(grafica_fcc_m)
                                    filtrado_fcc_m = filtro_raster_intervalo(nombre,
                                                                             estadisticas_lista(
                                                                                 resultado_fcc_m_simplificado, coef_fcc_m)[
                                                                                 0])
                                    filtrado_de_interes.append(filtrado_fcc_m)
                                    print("Analisis de histogramas de FCC_MATORRAL")
                                    #recorre_raster_ventanas(nombre)
                            print(capas_raster_de_interes)
                            print(filtrado_de_interes)
                            crea_html(capas_raster_de_interes, tablas_de_interes,
                                      graficas_de_interes)

                            # print(resultado)
                            # epsg = layervectorial.crs().postgisSrid()
                            # elimino las capas que he cargado durante el proceso
                            capas = QgsProject.instance().mapLayers()
                            for capa in capas:
                                if capa not in capasoriginales:
                                    QgsProject.instance().removeMapLayers([capa])

                            # busca las celdas que encuentran lo anterior (multiplica)
                            multiplicado = multiplica_rasters(filtrado_de_interes)
                            #raster = agrega(multiplicado)

                            #ojo deshacer si falla el agregado de buscar cosas similares. son 2 lineas.
                            raster = agrega2(multiplicado,30,1)#10,0.49)
                            vectorizar(raster, carpeta + "similar3.shp")

                            #lo mismo pero para las zonas similares segun histogramas
                            # busca las celdas que encuentran lo anterior (multiplica)
                            #multiplicado = multiplica_rasters(filtrado_de_interes2)
                        print(nombre_pestaña2)
                        if nombre_pestaña2 == 'por_zonas':

                                print("llego a por zonas")
                                print(nombre_pestaña2)
                                # compruebo que las capas necesarias estan cargadas
                                #contenido = os.listdir(carpeta)
                                """if 'Teselas_merged.shp' not in contenido:
                                    iface.messageBar().pushMessage("Error",
                                                                   "Antes de buscar zonas similares hay que ejecutar la primera pestaña de Silvilidar",
                                                                   duration=15)"""
                                #else:
                                carpeta_nueva = carpeta + '/Busca_similar'

                                carpeta = crea_carpeta(carpeta, carpeta_nueva)
                                print(carpeta)
                                #lo quito porque aqui no hay coeficientes, me servira despues para configurar el grado de similitud
                                coef_hm = 1#float(self.dlg.coef_hm2.text().replace(',', '.'))
                                coef_hbc = 1#float(self.dlg.coef_hbc2.text().replace(',', '.'))
                                coef_rc = 1#float(self.dlg.coef_rc2.text().replace(',', '.'))
                                coef_lc = 1#float(self.dlg.coef_lc2.text().replace(',', '.'))
                                coef_fcc = 1#float(self.dlg.coef_fcc2.text().replace(',', '.'))
                                coef_fcc_m = 1#float(self.dlg.coef_matorral2.text().replace(',', '.'))
                                ruta_muestra = self.dlg.ruta_muestra_similar.text()
                                correlacion=float(self.dlg.coeficiente_correlacion.text().replace(',', '.'))
                                solape=float(self.dlg.solape.text().replace(',', '.'))
                                capas_raster_de_interes2 = []  # para comparacion de pixeles
                                if self.dlg.checkBox_hm2.isChecked():
                                    capas_raster_de_interes2.append('HM')
                                if self.dlg.checkBox_hbc2.isChecked():
                                    capas_raster_de_interes2.append('HBC')
                                if self.dlg.checkBox_lc2.isChecked():
                                    capas_raster_de_interes2.append('LC')
                                if self.dlg.checkBox_rc2.isChecked():
                                    capas_raster_de_interes2.append('RC')
                                if self.dlg.checkBox_fcc2.isChecked():
                                    capas_raster_de_interes2.append('FCC')
                                if self.dlg.checkBox_matorral2.isChecked():
                                    capas_raster_de_interes2.append('FCC_MATORRAL')
                                mapcanvas = iface.mapCanvas()
                                """# capa vectorial
                                layers = mapcanvas.layers()
                                # layervectorial = qgis.utils.iface.activeLayer() # si trabajas interactivamente
                                layervectorial = QgsVectorLayer(ruta_muestra, "muestra", "ogr")
                                feats = [feat for feat in
                                         layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]"""
                                mapcanvas = iface.mapCanvas()
                                # capa vectorial
                                layers = mapcanvas.layers()
                                # layervectorial = qgis.utils.iface.activeLayer() # si trabajas interactivamente
                                layervectorial = QgsVectorLayer(ruta_muestra, "muestra", "ogr")
                                feats = [feat for feat in
                                         layervectorial.getFeatures()]  # [ feat for feat in layers[0].getFeatures() ]

                                print('capas_raster_de_interes2 ',capas_raster_de_interes2)
                                print(nombre_pestaña2)
                                print(capas_raster_de_interes2)
                                #ojo de aqui en adelante modificar
                                tablas_de_interes2 = []
                                graficas_de_interes2 = []
                                filtrado_de_interes2 = []  # pixeles similares
                                for nombre in capas_raster_de_interes2:
                                  if nombre == 'HM':
                                    resultado_hm = saca_valores_raster(nombre, feats)
                                    resultado_hm_simplificado = simplificar_lista(resultado_hm[0])
                                    print("he sacado los valores de HM simplificado")
                                    tabla_hm = crea_tabla(resultado_hm)
                                    tablas_de_interes2.append(tabla_hm)
                                    grafica_hm = grafica_histograma(resultado_hm_simplificado,
                                                                    estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                        0][0],
                                                                    estadisticas_lista(resultado_hm_simplificado, coef_hm)[
                                                                        0][1], "hm")
                                    graficas_de_interes2.append(grafica_hm)
                                    filtrado_hm = filtro_raster_intervalo(nombre,
                                                                          estadisticas_lista(resultado_hm_simplificado,
                                                                                             coef_hm)[0])
                                    filtrado_de_interes2.append(filtrado_hm)
                                    #comparable=np.array([6,7,8,8,8,10,10,10,10,10,11,11,11,11])
                                    #nuevo=compara_histogramas(resultado_hm_simplificado,comparable)
                                    print("Analisis de histogramas de HM")
                                    recorre_raster_ventanas(nombre)#, 12)#a mayor numero menos numero de ventanas. es el tamano de las ventanas en numero de pixeles

                                  if nombre == 'HBC':
                                    resultado_hbc = saca_valores_raster(nombre, feats)
                                    resultado_hbc_simplificado = simplificar_lista(resultado_hbc[0])
                                    tabla_hbc = crea_tabla(resultado_hbc)
                                    tablas_de_interes2.append(tabla_hbc)
                                    grafica_hbc = grafica_histograma(resultado_hbc_simplificado,
                                                                     estadisticas_lista(resultado_hbc_simplificado,
                                                                                        coef_hbc)[0][0],
                                                                     estadisticas_lista(resultado_hbc_simplificado,
                                                                                        coef_hbc)[0][1], "hbc")
                                    graficas_de_interes2.append(grafica_hbc)
                                    filtrado_hbc = filtro_raster_intervalo(nombre,
                                                                           estadisticas_lista(resultado_hbc_simplificado,
                                                                                              coef_hbc)[0])
                                    filtrado_de_interes2.append(filtrado_hbc)
                                    print("Analisis de histogramas de HBC")
                                    recorre_raster_ventanas(nombre)
                                  if nombre == 'LC':
                                    resultado_lc = saca_valores_raster(nombre, feats)
                                    resultado_lc_simplificado = simplificar_lista(resultado_lc[0])
                                    tabla_lc = crea_tabla(resultado_lc)
                                    tablas_de_interes2.append(tabla_lc)
                                    grafica_lc = grafica_histograma(resultado_lc_simplificado,
                                                                    estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                        0][0],
                                                                    estadisticas_lista(resultado_lc_simplificado, coef_lc)[
                                                                        0][1], "lc")
                                    graficas_de_interes2.append(grafica_lc)
                                    filtrado_lc = filtro_raster_intervalo(nombre,
                                                                          estadisticas_lista(resultado_lc_simplificado,
                                                                                             coef_lc)[0])
                                    filtrado_de_interes2.append(filtrado_lc)
                                    print("Analisis de histogramas de LC")
                                    recorre_raster_ventanas(nombre)
                                  if nombre == 'RC':
                                    resultado_rc = saca_valores_raster(nombre, feats)
                                    resultado_rc_simplificado = simplificar_lista(resultado_rc[0])
                                    tabla_rc = crea_tabla(resultado_rc)
                                    tablas_de_interes2.append(tabla_rc)
                                    grafica_rc = grafica_histograma(resultado_rc_simplificado,
                                                                    estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                        0][0],
                                                                    estadisticas_lista(resultado_rc_simplificado, coef_rc)[
                                                                        0][1], "rc")
                                    graficas_de_interes2.append(grafica_rc)
                                    filtrado_rc = filtro_raster_intervalo(nombre,
                                                                          estadisticas_lista(resultado_rc_simplificado,
                                                                                             coef_rc)[0])
                                    filtrado_de_interes2.append(filtrado_rc)
                                    print("Analisis de histogramas de LC")
                                    recorre_raster_ventanas(nombre)
                                  if nombre == 'FCC':
                                    resultado_fcc = saca_valores_raster(nombre, feats)
                                    resultado_fcc_simplificado = simplificar_lista(resultado_fcc[0])
                                    tabla_fcc = crea_tabla(resultado_fcc)
                                    tablas_de_interes2.append(tabla_fcc)
                                    grafica_fcc = grafica_histograma(resultado_fcc_simplificado,
                                                                     estadisticas_lista(resultado_fcc_simplificado,
                                                                                        coef_fcc)[0][0],
                                                                     estadisticas_lista(resultado_fcc_simplificado,
                                                                                        coef_fcc)[0][1], "fcc")
                                    graficas_de_interes2.append(grafica_fcc)
                                    filtrado_fcc = filtro_raster_intervalo(nombre,
                                                                           estadisticas_lista(resultado_fcc_simplificado,
                                                                                              coef_fcc)[0])
                                    filtrado_de_interes2.append(filtrado_fcc)
                                    print("Analisis de histogramas de FCC")
                                    recorre_raster_ventanas(nombre)
                                  if nombre == 'FCC_MATORRAL':
                                    resultado_fcc_m = saca_valores_raster(nombre, feats)
                                    resultado_fcc_m_simplificado = simplificar_lista(resultado_fcc_m[0])
                                    tabla_fcc_m = crea_tabla(resultado_fcc_m)
                                    tablas_de_interes2.append(tabla_fcc_m)
                                    grafica_fcc_m = grafica_histograma(resultado_fcc_m_simplificado,
                                                                       estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                          coef_fcc)[0][0],
                                                                       estadisticas_lista(resultado_fcc_m_simplificado,
                                                                                          coef_fcc)[0][1], "fcc_m")
                                    graficas_de_interes2.append(grafica_fcc_m)
                                    filtrado_fcc_m = filtro_raster_intervalo(nombre,
                                                                             estadisticas_lista(
                                                                                 resultado_fcc_m_simplificado, coef_fcc_m)[
                                                                                 0])
                                    filtrado_de_interes2.append(filtrado_fcc_m)
                                    print("Analisis de histogramas de FCC_MATORRAL")
                                    recorre_raster_ventanas(nombre)
                                print(capas_raster_de_interes2)
                                print(filtrado_de_interes2)
                                crea_html(capas_raster_de_interes2, tablas_de_interes2,
                                          graficas_de_interes2)#igual hay que hacer una modificacion para que no pinte los rangos en rojo, porque en este caso no tiene sentido

                                # print(resultado)
                                # epsg = layervectorial.crs().postgisSrid()


                                # busca las celdas que encuentran lo anterior (multiplica)
                                multiplicado = multiplica_rasters(filtrado_de_interes2)
                                # elimino las capas que he cargado durante el proceso
                                capas = QgsProject.instance().mapLayers()
                                for capa in capas:
                                    if capa not in capasoriginales:
                                        QgsProject.instance().removeMapLayers([capa])
                                #cargo la capa de poligonos con las zonas similares

                                #vlayer = QgsVectorLayer(os.path.join(carpeta, 'similares.shp'), 'Zonas con histograma similar', "ogr")

                                # Añadir la capa al proyecto actual (opcional)
                                #QgsProject.instance().addMapLayer(vlayer)
                                #raster = agrega(multiplicado)
                                #raster = agrega2(multiplicado,10,0.49)
                                #vectorizar(raster, carpeta + "similar3.shp")

                                #miro que capas vectoriales he creado y no estan vacias y hago la interseccion entre ellas. El resultado despues lo disuelvo.
                                rutas_capas_salida=[]
                                for nombre_raster in capas_raster_de_interes2:
                                    ruta = carpeta + f"/similares_{nombre_raster}.shp"
                                    rutas_capas_salida.append(ruta)
                                if len(rutas_capas_salida)==0:
                                    print("no hay nada que intersectar")
                                if len(rutas_capas_salida)==1:
                                    print("no hago intersecccion, solo hay una capa y es lo que devuelvo")
                                    print(rutas_capas_salida[0])

                                    resultado0 = QgsVectorLayer(rutas_capas_salida[0], "Zonas similares por histograma", "ogr")

                                    disuelto = processing.run("native:dissolve",
                                                              {'INPUT': resultado0,
                                                               'FIELD': ['DN'],
                                                               'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                                    QgsVectorFileWriter.writeAsVectorFormat(disuelto,
                                                                            carpeta + '/Zonas_similares_por_histograma.shp',
                                                                            "CP120", disuelto.crs(),
                                                                            "ESRI Shapefile")
                                    resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp',
                                                               "Zonas similares por histograma", "ogr")
                                if len(rutas_capas_salida)==2:
                                    print("hago interseccion de dos capas")
                                    capa1 = QgsVectorLayer(rutas_capas_salida[0], "capa1", "ogr")
                                    capa2 = QgsVectorLayer(rutas_capas_salida[1], "capa2", "ogr")

                                    interseccion = processing.run("native:intersection",
                                        {'INPUT': capa1,
                                        'OVERLAY': capa2,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})
                                    print('interseccion',interseccion['OUTPUT'])

                                    disuelto = processing.run("native:dissolve",
                                        {'INPUT': interseccion['OUTPUT'],
                                        'FIELD': ['DN'],
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                                    QgsVectorFileWriter.writeAsVectorFormat(disuelto, carpeta + '/Zonas_similares_por_histograma.shp', "CP120", capa1.crs(),
                                                                            "ESRI Shapefile")
                                    resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp',
                                                               "Zonas similares por histograma", "ogr")
                                """if len(rutas_capas_salida)==3:
                                    print("hago interseccion de tres capas")
                                    capa1 = QgsVectorLayer(rutas_capas_salida[0], "capa1", "ogr")
                                    capa2 = QgsVectorLayer(rutas_capas_salida[1], "capa2", "ogr")
                                    capa3 = QgsVectorLayer(rutas_capas_salida[2], "capa3", "ogr")
    
                                    interseccion0 = processing.run("native:intersection",
                                        {'INPUT': capa1,
                                        'OVERLAY': capa2,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})
                                    print('interseccion',interseccion0['OUTPUT'])
                                    interseccion = processing.run("native:intersection",
                                                                   {'INPUT': interseccion0['OUTPUT'],
                                                                    'OVERLAY': capa3,
                                                                    'OUTPUT': 'TEMPORARY_OUTPUT'})
                                    disuelto = processing.run("native:dissolve",
                                        {'INPUT': interseccion['OUTPUT'],
                                        'FIELD': ['DN'],
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                                    QgsVectorFileWriter.writeAsVectorFormat(disuelto, carpeta + '/Zonas_similares_por_histograma.shp', "CP120", capa1.crs(),
                                                                            "ESRI Shapefile")
                                    resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp', "Zonas similares por histograma", "ogr")"""
                                if 3 <= len(rutas_capas_salida) <= 6:
                                    print(f"hago interseccion de {len(rutas_capas_salida)} capas")
                                    capas = [QgsVectorLayer(ruta, f"capa{i + 1}", "ogr") for i, ruta in
                                             enumerate(rutas_capas_salida)]

                                    interseccion = capas[0]
                                    for i in range(1, len(capas)):
                                        interseccion = processing.run("native:intersection", {
                                            'INPUT': interseccion,
                                            'OVERLAY': capas[i],
                                            'OUTPUT': 'TEMPORARY_OUTPUT'
                                        })['OUTPUT']

                                    disuelto = processing.run("native:dissolve", {
                                        'INPUT': interseccion,
                                        'FIELD': ['DN'],
                                        'OUTPUT': 'TEMPORARY_OUTPUT'
                                    })['OUTPUT']

                                    QgsVectorFileWriter.writeAsVectorFormat(disuelto,
                                                                            carpeta + '/Zonas_similares_por_histograma.shp',
                                                                            "CP120", capas[0].crs(), "ESRI Shapefile")
                                    resultado = QgsVectorLayer(carpeta + '/Zonas_similares_por_histograma.shp',
                                                               "Zonas similares por histograma", "ogr")



                                    #lyr = QgsVectorLayer(carpeta + '/disuelto.shp', "Zonas similares", "ogr")
                                resultado.loadNamedStyle(os.path.dirname(__file__) + '/styles/similar3.qml')
                                print("voy a aplicar la simbologia en linea 4409")
                                QgsProject.instance().addMapLayer(resultado)





