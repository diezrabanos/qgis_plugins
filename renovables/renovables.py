# -*- coding: utf-8 -*-
"""
/***************************************************************************
 renovables
                                 A QGIS plugin
 esto es lo que hace renovables
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-29
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Javier Diez Rabanos
        email                : fjavier.diez@jcyl.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
#from PyQt5.QtGui import QIcon
#from PyQt5.QtWidgets import QAction

from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication#,QFileInfo
from qgis.PyQt.QtGui import QIcon, QColor,QFont
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QInputDialog
from PyQt5.QtWidgets import QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .renovables_dialog import RenovablesDialog
from .config_dialog import ConfigDialog
from .xy_dialog import XYDialog
import os.path

#import para procesar
import qgis.core as qgisCore
from qgis.core import QgsProject, QgsVectorLayer,QgsField,QgsExpression,QgsExpressionContext,QgsExpressionContextScope,QgsVectorFileWriter, QgsMarkerSymbol,QgsRendererCategory,QgsCategorizedSymbolRenderer,QgsPointXY, QgsPoint,QgsFeature,QgsGeometry,QgsLineSymbol,QgsExpressionContextUtils,QgsPalLayerSettings,QgsTextFormat,QgsVectorLayerSimpleLabeling,QgsExpressionContextUtils,QgsApplication, QgsTextBufferSettings,QgsLayoutExporter
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
#from PyQt5.QtWidgets import QMessageBox
#from PyQt5.QtCore import QFileInfo
#from qgis.PyQt.QtCore import QFileInfo

import processing
import os
import glob
import re
import sys
#from qgis import *

import math
import time

import webbrowser

import tempfile

import pyproj

from .configurar_capas import parcelas,nucleos,bic,sensifoto,sensieo,regadios


class Renovables:
    """QGIS Plugin Implementation."""
    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Renovables_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        self.dlg = RenovablesDialog()
        

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sigmena')
        
        #self.toolbar = self.iface.addToolBar(u'Sigmena')             #creo que no hace nada
        #self.toolbar.setObjectName(u'Sigmena')            #creo que no hace nada
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        #abre la nueva ventana de configuracion
        
        self.dlg.pushButton_ruta_capa_zona.clicked.connect(self.select_file2)
        self.dlg.help_button.clicked.connect(self.help_pressed)

        self.dlg.radioButtonSolar.toggled.connect(self.solar)
        self.dlg.radioButtonEolica.toggled.connect(self.eolica)
        self.afecciones=[]
        
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Renovables', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """


        
        #cambio el icon path para mi equipo.
        usuario=QgsApplication.qgisSettingsDirPath()
        icon_path=os.path.join(usuario,r"python\plugins\renovables\icon.png")
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)
            #self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/renovables/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Renovables'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        
        
        
            
   


    def select_file2(self):

        """seleciono la capa con la zona de interes para recortar o seleccionar el resto de capas predefinidas"""
        global ruta_capa_zona
        
        ruta_capa_zona = QFileDialog.getOpenFileName(self.dlg , "Capa con la zona del parque",None ,'SHP(*.shp)')
        self.dlg.ruta_capa_zona.setText(ruta_capa_zona[0])
        #print(ruta_capa_zona)
        
    
   
    

    def help_pressed(self):
        help_file = 'file:' + os.path.dirname(__file__) + '/Ayuda_renovables.pdf'
        webbrowser.open_new(help_file)  


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.iface.removePluginMenu(
                self.tr(u'&Sigmena'),
                action)

    #configuro el sentido del papel, lo que puede llevar a un grupo de plantillas   
    def solar(self):
        global tiporenovable
        if self.dlg.radioButtonSolar.isChecked()==True:
            tiporenovable="solar"
            print(tiporenovable)
    def eolica(self):
        global sentido
        if self.dlg.radioButtonEolica.isChecked()==True:
            tiporenovable="eolica"
            print(tiporenovable)

    #empiezo el cruce de capas vectoriales con la zona de interes, hace una seleccion de los elementos, no un clip. los selecciona  y los guarda. capa fotovoltaicas o eolicas es el elementofijo
    def crucecapasvectoriales(self,capadetrabajo,elementofijo,carpetasalida):
        global resultadocapas
        sufijo='sensibilidad'
        print ("sufijo")
        print (sufijo)
        salida=carpetasalida+"/"+sufijo
        layer = QgsVectorLayer(elementofijo, sufijo, "ogr")
        
        #deberia hacer un zum a esta capa que luego ser√° el que utilice para hacer el mapa.
        canvas = iface.mapCanvas()
        extent = capadetrabajo.extent()
        canvas.setExtent(extent)
        
        
        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':capadetrabajo,'METHOD':0})
        #guardo los selecionados con la codifiacion indicada
        selection = layer.selectedFeatures()
        feats = [feat for feat in layer.selectedFeatures()]
        elementos=len(feats)
        resultado1=[]
        if len(feats)==0:
            print("no afecta a RANP, ni especies protegidas, ni montes arbolados")
        if len(feats)>0:
            print("si afecta a RANP, o especies protegidas, o montes arbolados")  #creo capa de poligonos
            mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", sufijo, "memory")
            mem_layer_data = mem_layer.dataProvider()
            attr = layer.dataProvider().fields().toList()
            mem_layer_data.addAttributes(attr)
            mem_layer.updateFields()
            mem_layer_data.addFeatures(feats)
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer,salida,"utf-8",driverName="ESRI Shapefile")
            QgsProject.instance().addMapLayer(mem_layer)
            # coloreo
            mem_layer.loadNamedStyle(os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\renovables\sensibilidad_fotovoltaica_estilo_boton.qml"))
            mem_layer.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology(mem_layer.id())
            

            #trato de ver a que afecta para poder escribirlo en un informe
            
            for feature in mem_layer.getFeatures():
                ambito = feature["ambito"]
                nombre = feature["nombre"]
                areaexcl= feature["areaexcl"]
                espacio=feature["espacio"]
                
                resultado1.append([ambito,areaexcl,nombre,espacio])
        return resultado1
            
    #empiezo el cruce de capas vectoriales con la zona de interes, hace una seleccion de los elementos, no un clip. los selecciona  y los guarda. capa regadio
    def crucecapasvectoriales2(self,capadetrabajo,regadios,carpetasalida):
        #cruce con las zonas de regadio
        global resultadocapas
        sufijo='regadios'
        salida=carpetasalida+"/"+sufijo
        layer = QgsVectorLayer(regadios, sufijo, "ogr")#no es necesario con el saveselectedfeatures
        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':capadetrabajo,'METHOD':0})
        #guardo los selecionados con la codifiacion indicada
        selection = layer.selectedFeatures()
        feats = [feat for feat in layer.selectedFeatures()]
        elementos=len(feats)
        resultado4=[]
        if len(feats)==0:
            print("no afecta a zonas regables")
        if len(feats)>0:
            print("si afecta a zonas regables")
            mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", sufijo, "memory")
            mem_layer_data = mem_layer.dataProvider()
            attr = layer.dataProvider().fields().toList()
            mem_layer_data.addAttributes(attr)
            mem_layer.updateFields()
            mem_layer_data.addFeatures(feats)
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer,salida,"utf-8",driverName="ESRI Shapefile")
            QgsProject.instance().addMapLayer(mem_layer)
            # coloreo
            mem_layer.loadNamedStyle(os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\renovables\regadios_estilo_boton.qml"))
            mem_layer.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology(mem_layer.id())
            #trato de ver a que afecta para poder escribirlo en un informe
            for feature in mem_layer.getFeatures():
                zona = feature["zona"]
                resultado4.append([zona])
        return resultado4

    def distancia1(self,bic,capadetrabajo,carpetasalida):
        #voy a mirar la distancia a los bic
        salida=carpetasalida+"/"+'buffer.shp'
        salida2=carpetasalida+"/"+'yacimientos_afectados.shp'
        salida3=carpetasalida+"/"+'yacimientos_afectados_distancia.shp'
        salida4=carpetasalida+"/"+'bic_afectados_distancia.shp'
        #deberia hacer un filtro de la de yacimientos cada vez, creo que es lo mejor. o buscar todos y luego filtrar lo que son de los que nos interesan, bic solo.
        layerbic = QgsVectorLayer(bic, 'yacimientos', "ogr")#no es necesario con el saveselectedfeatures
        processing.run("native:buffer", {'DISSOLVE' : True, 'DISTANCE' : 500, 'END_CAP_STYLE' : 0, 'INPUT' :capadetrabajo,'JOIN_STYLE' : 0, 'MITER_LIMIT' : 2, 'OUTPUT' : salida, 'SEGMENTS' : 10})
        capabuffer=QgsVectorLayer(salida, 'buffer', "ogr")
        #hago la interseccion entre estas dos capas a ver si afecta a algo.
        processing.run("native:selectbylocation", {'INPUT':layerbic,'PREDICATE':[0],'INTERSECT':capabuffer,'METHOD':0})
        selection = layerbic.selectedFeatures()
        feats = [feat for feat in layerbic.selectedFeatures()]
        elementos=len(feats)
        resultado2=[]
        if len(feats)==0:
            print("no afecta a yacimientos")
        if len(feats)>0:
            print("si afecta a yacimientos")
            mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", 'yacimientos_afectados', "memory")
            mem_layer_data = mem_layer.dataProvider()
            attr = layerbic.dataProvider().fields().toList()
            mem_layer_data.addAttributes(attr)
            mem_layer.updateFields()
            mem_layer_data.addFeatures(feats)
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer,salida2,"utf-8",driverName="ESRI Shapefile")
            fix_layer_salida2 = processing.run("native:fixgeometries", {'INPUT':salida2,'OUTPUT':'memory:'})['OUTPUT']            
            processing.run('native:joinbynearest',{ 'DISCARD_NONMATCHING' : False, 'FIELDS_TO_COPY' : [], 'INPUT' : fix_layer_salida2, 'INPUT_2' : capadetrabajo, 'MAX_DISTANCE' : None, 'NEIGHBORS' : 1, 'OUTPUT' : salida3, 'PREFIX' : '' })
            layerselecionar=QgsVectorLayer(salida3, 'yacimientos_distancia', "ogr")
            state='BIENES DE INTER√âS CULTURAL'#'BIENES DE INTER√É‚Ä∞S CULTURAL'
            expression = QgsExpression( "\"REGIMEN\"='{}' ".format( state ))
            # Added / changed lines ##########
            context = QgsExpressionContext()
            scope = QgsExpressionContextScope()
            context.appendScope(scope)
            feats = []
            ids = []
            for feat in layerselecionar.getFeatures():
                scope.setFeature(feat)
                result = expression.evaluate(context)
                if result:
                    feats.append(feat)
                    ids.append(feat.id())
            if len(ids) == 0:
                print("No afecta a BIC")
            if len(ids) > 0:
                print("afecta a BIC")
                layerselecionar.selectByIds(ids)   
                QgsVectorFileWriter.writeAsVectorFormat(layerselecionar, salida4, "CP120", layerselecionar.crs(), "ESRI Shapefile",  onlySelected=True)
                layerbiccercanos= QgsVectorLayer(salida4,'bic cercanos', "ogr")
                QgsProject.instance().addMapLayer(layerbiccercanos)
                # coloreo
                ruta=QgsApplication.qgisSettingsDirPath()+"python/plugins/renovables/bic_estilo_boton.qml"
                #print(ruta)
                layerbiccercanos.loadNamedStyle(ruta)#('R:/SIGMENA/prueba/2022/09/05/bic_estilo_boton.qml')
                layerbiccercanos.triggerRepaint()
                iface.layerTreeView().refreshLayerSymbology(layerbiccercanos.id())
                #trato de ver a que afecta para poder escribirlo en un informe
                for feature in layerbiccercanos.getFeatures():
                    denominacion = feature["A_DENO_PPA"]
                    distance = feature["distance"] 
                    resultado2.append([denominacion,round(distance)])       
        return resultado2
        
    #miro la distancia nucleos urbanos
    def distancia2(self,capadetrabajo,carpetasalida,distancia,parcelas,nucleos):
        #voy a mirar la distancia a los nucleos urbanos de la parcela en la qu eesta contenida
        salidamenosbuffer=carpetasalida+"/"+'menosbuffer.shp'#para que la interseccion de la original con las parcelas no saque las colindantes por algo minusculo
        salida=carpetasalida+"/"+'buffer2.shp'
        salida0=carpetasalida+"/"+'parcelas.shp'
        salida2=carpetasalida+"/"+'nucleos_afectados.shp'
        salida3=carpetasalida+"/"+'nucleos_afectados_distancia.shp'
        layernucleos = QgsVectorLayer(nucleos, 'nucleos', "ogr")#no es necesario con el saveselectedfeatures
        layerparcelas = QgsVectorLayer(parcelas, 'parcelas', "ogr")
        #hago un bufer para adentro de la capa de trabajo.
        processing.run("native:buffer", {'DISSOLVE' : True, 'DISTANCE' : -1, 'END_CAP_STYLE' : 0, 'INPUT' :capadetrabajo,'JOIN_STYLE' : 0, 'MITER_LIMIT' : 2, 'OUTPUT' : salidamenosbuffer, 'SEGMENTS' : 10})
        capabuffer=QgsVectorLayer(salidamenosbuffer, 'buffer_negativo', "ogr")
        #el input debe ser la parcela no lo que meto como zona de parque.Para ello la tengo que seleccionar las aprcelas que intecsectan.
        processing.run("native:selectbylocation", {'INPUT':layerparcelas,'PREDICATE':[0],'INTERSECT':salidamenosbuffer,'METHOD':0})
        selection = layerparcelas.selectedFeatures()
        feats = [feat for feat in layerparcelas.selectedFeatures()]
        feats_no9000=[]
        #trato de quitar los 9000
        for feature in feats:
            if int(feature["C_REFPAR"][-5:])<9000:# AND round(left(right(feature["C_REFPAR"],8),3),0)>9999:
                    feats_no9000.append(feature)
            if int(feature["C_REFPAR"][-5:])>9999:
                feats_no9000.append(feature)
        elementos=len(feats_no9000)        
        if len(feats_no9000)==0:
            print("no hay parcela, debe estar fuera de la provincia")
        #if len(feats)>0:
        if len(feats_no9000)>0:    
            mem_layer1 = QgsVectorLayer("Polygon?crs=epsg:25830", 'parcelas_afectadas', "memory")
            mem_layer_data1 = mem_layer1.dataProvider()
            attr = layerparcelas.dataProvider().fields().toList()
            mem_layer_data1.addAttributes(attr)
            mem_layer1.updateFields()
            mem_layer_data1.addFeatures(feats_no9000)
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer1,salida0,"utf-8",driverName="ESRI Shapefile")
        #hago buffer de las parcelas afectadas
        processing.run("native:buffer", {'DISSOLVE' : True, 'DISTANCE' : distancia, 'END_CAP_STYLE' : 0, 'INPUT' :salida0,'JOIN_STYLE' : 0, 'MITER_LIMIT' : 2, 'OUTPUT' : salida, 'SEGMENTS' : 10})
        capabuffer=QgsVectorLayer(salida, 'buffer', "ogr")
        #hago la interseccion entre estas dos capas a ver si afecta a algo.
        processing.run("native:selectbylocation", {'INPUT':layernucleos,'PREDICATE':[0],'INTERSECT':capabuffer,'METHOD':0})
        selection = layernucleos.selectedFeatures()
        feats = [feat for feat in layernucleos.selectedFeatures()]
        elementos=len(feats)
        resultado3=[]
        if len(feats)==0:
            print("no afecta a nucleos")
        if len(feats)>0:
            mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", 'nucleos_afectados', "memory")
            mem_layer_data = mem_layer.dataProvider()
            attr = layernucleos.dataProvider().fields().toList()
            mem_layer_data.addAttributes(attr)
            mem_layer.updateFields()
            mem_layer_data.addFeatures(feats)
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer,salida2,"utf-8",driverName="ESRI Shapefile")
            print("ojo, afecta a nucleos.")
            #calcular la distancia a todos
            processing.run('native:joinbynearest',{ 'DISCARD_NONMATCHING' : False, 'FIELDS_TO_COPY' : [], 'INPUT' : salida2, 'INPUT_2' : salida0, 'MAX_DISTANCE' : None, 'NEIGHBORS' : 1, 'OUTPUT' : salida3, 'PREFIX' : '' })
            layerselecionar=QgsVectorLayer(salida3, 'nucleos_distancia', "ogr")
            layerselecionar.setProviderEncoding(u'UTF-8')# porque me salian mal algunos caracteres.
            QgsProject.instance().addMapLayer(layerselecionar)
            # coloreo
            layerselecionar.loadNamedStyle(os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\renovables\nucleos_estilo_boton.qml"))#('R:/SIGMENA/prueba/2022/09/05/nucleos_estilo_boton.qml')
            layerselecionar.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology(layerselecionar.id())
            #si hay afeccion a nucleos, cargo la capa de parcelas, sino no.
            QgsProject.instance().addMapLayer(mem_layer1)#capa de las parcelas
            # coloreo
            mem_layer1.loadNamedStyle(os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\renovables\parcela_estilo_boton.qml"))#('R:/SIGMENA/prueba/2022/09/05/parcela_estilo_boton.qml')
            mem_layer1.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology(mem_layer1.id())
            #saco datos para informe
            for feature in layerselecionar.getFeatures():
                    denominacion = feature["DENNUC"]
                    distance = feature["distance"]
                    if [denominacion,round(distance)] not in resultado3:
                        resultado3.append([denominacion,round(distance)])
        return resultado3

    def hagomapa(self,carpetasalida,tipo,nombre,resultado1,resultado2,resultado3,resultado4,escala):#basado en hagomapa3 del complemento informes resultado1=capa sigmena valladolid, resultado2=bic, resultado3=nucleos urbanos, escala=escala del mapa a sacar
        #para los informes en pdf
        from reportlab.platypus import SimpleDocTemplate,Paragraph,Table,TableStyle,Image
        from reportlab.lib.styles import getSampleStyleSheet
        from reportlab.lib import colors
        from reportlab.lib.pagesizes import A3,A4,A6,portrait,landscape
        from reportlab.lib.units import mm
        from reportlab.pdfgen import canvas
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
        #from PyPDF2 import PdfFileWriter, PdfFileReader
        import io
        filePath = carpetasalida
        #elimino capas del proeycto actual
        def eliminacapas():
            capasinteresantes=['regadios','bic cercanos',"Capa proyecto",'parcelas_afectadas','sensibilidad','nucleos_distancia','PNOA_2017','pnoa_2021','pnoa2020']
            capas =QgsProject.instance().mapLayers()
            #print(capas)
            #print(type(capas))
            for capa in capas.items():
                #print(type(capa))
                #print (capa)
                #print (capa[1].name())
                #print(capa[:9])
                if capa[1].name() not in capasinteresantes :
                    #QgsProject.instance().removeMapLayers( [capa] )   
                    QgsProject.instance().layerTreeRoot().findLayer(capa[1]).setItemVisibilityChecked(False)
            del(capas)
        eliminacapas()
        QgsProject.instance().layerTreeRegistryBridge().setLayerInsertionPoint( QgsProject.instance().layerTreeRoot(), 1 )
        projectInstance = QgsProject.instance()
        layoutmanager = projectInstance.layoutManager()
        layout = layoutmanager.layoutByName("A6") #Layout name  ojo importante
        mapItem = layout.referenceMap()
        mapItem.zoomToExtent(iface.mapCanvas().extent())
        mapItem.setScale(escala)
        # genero el png
        imagenes=[]
        legendExporter=QgsLayoutExporter(layout)
        imageSettings=legendExporter.ImageExportSettings()
        imageSettings.cropToContents=True
        imageSettings.dpi=100
        imageSettings.pages=[0]
        exporter = QgsLayoutExporter(layout)
        archi=( filePath  + "imagen.png" )
        exporter.exportToImage(archi,imageSettings )
        imagenes.append(archi)
        #anado todas las imagenes a un pdf
        carpetasalida=filePath
        c = canvas.Canvas(carpetasalida+"/salida.pdf", pagesize=portrait(A4))#landscape(A4))  # alternatively use bottomup=False
        ruta_logo=r"o:/sigmena/logos/color_consejeria.jpg"#ojo
        img_logo=Image(ruta_logo)#,, width)#250*mm,250*mm)#los numeross son opcionales para determinar el tama√±o
        img_logo._restrictSize(30 * mm, 20 * mm)
        img_logo.drawOn(c,170*mm,275 * mm)
        width, height = A6
        c.setFont("Helvetica-Bold", 10)
        #aqui meto un texto de cabecera
        ptext =  "PLANTA " +tipo+" de: "+nombre
        c.drawString(30*mm, 270*mm, ptext)
        nmax=len(imagenes)
        #meto la imagen
        c.setFont("Helvetica", 12)
        #aqui meto un texto
        ptext = "Cartograf√≠a" 
        img_data1=Image(imagenes[0],height, width)
        x,y=30,160#30,20
        z,t=100,130
        img_data1.drawOn(c,x*mm,y * mm)
        #otro texto
        ytexto=162
        c.setFont("Helvetica-Bold", 8)
        #aqui meto un texto 
        ptext =  "ESCALA 1:" +str(escala)
        c.drawString(150*mm, ytexto*mm, ptext)
        #otro texto
        ytexto=152
        c.setFont("Helvetica-Bold", 10)
        #aqui meto un texto 
        ptext =  "Decreto Ley 2/2022 de 23 de junio por el que se adoptan medidas urgentes para la agilizaci√≥n" 
        c.drawString(30*mm, ytexto*mm, ptext)
        ytexto=ytexto-8
        ptext =  "de la gesti√≥n de los fondos europeos y el impulso de la actividad econ√≥mica"
        c.drawString(30*mm, ytexto*mm, ptext)
        #otro texto
        ytexto=ytexto-8#140
        c.setFont("Helvetica", 10)
        #aqui meto un texto
        texto='NO'
        for i in range(len(resultado1)):
            #print(resultado1[i][0])
            if 'RANP - 'in resultado1[i][0]:      
                texto='S√ç'
                break
        if tipo=='FOTOVOLTAICA':        
            ptext =  "Art√≠culo13, 2a), Terrenos incluidos en la Red de √Åreas Naturales Protegidas................."+texto
        if tipo=='E√ìLICA':
            ptext =  "Art√≠culo13, 1a), Terrenos incluidos en la RANP,salvo protectores y de UP......................"+texto
        c.drawString(40*mm, ytexto*mm, ptext)
        #meto un subtexto con los datos de porque es RANP
        if texto=='S√ç':
            c.setFont("Helvetica", 8)
            n=1
            for i in range(len(resultado1)):
                if 'RANP - 'in resultado1[i][0]:
                    ytexto=ytexto-8
                    ptext=resultado1[i][1]+': '+resultado1[i][2]
                    c.drawString(60*mm, ytexto*mm, ptext)
                    n=n+1
        #otro texto
        ytexto=ytexto-8
        c.setFont("Helvetica", 10)
        #aqui meto un texto de cabecera
        texto='NO'
        for i in range(len(resultado1)):
            #print(resultado1[i][0])
            if 'Plan 'in resultado1[i][0]:      
                texto='S√ç'
                break
        if tipo=='FOTOVOLTAICA': 
            ptext =  "Art√≠culo13, 2b), Terrenos incluidos en √°reas cr√≠ticas de las especies protegidas............."+texto
        if tipo=='E√ìLICA':
            ptext =  "Art√≠culo13, 1b), Terrenos incluidos en √°reas cr√≠ticas de las especies protegidas............."+texto
        c.drawString(40*mm, ytexto*mm, ptext)
        #meto un subtexto con los datos de porque es RANP
        if texto=='S√ç':
            c.setFont("Helvetica", 8)
            n=1
            for i in range(len(resultado1)):
                if 'Plan 'in resultado1[i][0]:
                    ytexto=ytexto-8
                    ptext=resultado1[i][0]+': '+resultado1[i][3]
                    c.drawString(60*mm, ytexto*mm, ptext)
                    n=n+1
        #otro texto
        #aqui meto un texto de cabecera
        if tipo=='FOTOVOLTAICA':
            ytexto=ytexto-8
            c.setFont("Helvetica", 10)
            for i in range(len(resultado1)):
                if 'Monte arbolado'== resultado1[i][1]:      
                    texto='S√ç'
                    break
                else:
                    texto='NO'
            ptext =  "Art√≠culo13, 2c), Montes arbolados....................................................................................."+texto
            c.drawString(40*mm, ytexto*mm, ptext)
            c.setFont("Helvetica", 10)
        #aqui meto un texto de cabecera
        ytexto=ytexto-8
        if len(resultado2)==0:
            texto='NO'
        else:
            texto='S√ç'
        if tipo=='FOTOVOLTAICA':
            ptext =  "Art√≠culo13, 2d), Terrenos ubicados a menos de 500 metros de un B.I.C.........................."+texto
        if tipo=='E√ìLICA':
            ptext =  "Art√≠culo13, 1c), Terrenos ubicados a menos de 500 metros de un B.I.C.........................."+texto
        c.drawString(40*mm, ytexto*mm, ptext)
        #meto un subtexto con los datos de porque esta cerca de bic
        if texto=='S√ç':
            c.setFont("Helvetica", 8)
            n=1
            for i in range(len(resultado2)):
                    ytexto=ytexto-8
                    ptext=resultado2[i][0]+' a '+str(resultado2[i][1])+' metros'
                    c.drawString(60*mm, ytexto*mm, ptext)
                    n=n+1
        c.setFont("Helvetica", 10)
        #aqui meto un texto de cabecera
        ytexto=ytexto-8
        if len(resultado3)==0:
            texto='NO'
        else:
            texto='S√ç'
        if tipo=='FOTOVOLTAICA':
            ptext =  "Art√≠culo13, 2e), Parcelas ubicadas a menos de 500 metros de los n√∫cleos urbanos......."+texto
        if tipo=='E√ìLICA':
            ptext =  "Art√≠culo13, 1d), Parcelas ubicadas a menos de 1000 metros de los n√∫cleos urbanos......"+texto
        c.drawString(40*mm, ytexto*mm, ptext)
        #meto un subtexto con los datos de porque esta cerca de nucleos urbanos
        if texto=='S√ç':
            c.setFont("Helvetica", 8)
            n=1
            for i in range(len(resultado3)):
                    ytexto=ytexto-8
                    ptext=resultado3[i][0]+' a '+str(resultado3[i][1])+' metros'
                    c.drawString(60*mm, ytexto*mm, ptext)
                    n=n+1
        #aqui meto un texto de cabecera
        ytexto=ytexto-8
        c.setFont("Helvetica", 10)
        if len(resultado4)==0:
            texto='NO'
        else:
            texto='S√ç' 
        if tipo=='FOTOVOLTAICA':
            ptext =  "Art√≠culo13, 2f), Terrenos sobre los que se hayan desarrollado zonas regables................"+texto
        if tipo=='E√ìLICA':
             ptext =  "Art√≠culo13, 1e), Terrenos sobre los que se hayan desarrollado zonas regables................"+texto
        c.drawString(40*mm, ytexto*mm, ptext)
        #meto un subtexto con los datos de porque esta en regadio
        if texto=='S√ç':
            print(resultado4)
            c.setFont("Helvetica", 8)
            n=1
            for i in range(len(resultado4)):
                    ytexto=ytexto-8
                    ptext=resultado4[i][0]
                    c.drawString(60*mm, ytexto*mm, ptext)
                    n=n+1
        c.setFont("Helvetica", 8)
        c.drawString(190*mm, 15*mm, "SIGMENA")
    
        c.save()
        result_file = 'file:' + carpetasalida + '/salida.pdf'
        webbrowser.open_new(result_file)
                    
    def run(self):
        print ("paso por el run")
        #coloco el puntero arriba del todo
        QgsProject.instance().layerTreeRegistryBridge().setLayerInsertionPoint( QgsProject.instance().layerTreeRoot(), 0 )
        #carpeta de trabajo
        carpetasalida = tempfile.mkdtemp()
        print(carpetasalida)
        # show the dialog
        self.dlg.show()
        if self.first_start == True:
            self.first_start = False
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            print("llego al result")
            # Get the coordinates and scale factor from the dialog
            nombre_parque_b=self.dlg.nombre_parque.text()##displayText()
            escala=int(self.dlg.lineEdit_escala.text())
            print(ruta_capa_zona[0])
            lyr9 = QgsVectorLayer(ruta_capa_zona[0], 'Capa proyecto', 'ogr')
            QgsProject.instance().addMapLayers([lyr9])
            # coloreo
            lyr9.loadNamedStyle(os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\renovables\proyecto_estilo_boton.qml"))#('R:/SIGMENA/prueba/2022/09/05/parcela_estilo_boton.qml')
            lyr9.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology(lyr9.id())
            #leo el txt y sus variables
            #lo nuevo empieza aqui
            myfile=open (os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\renovables\archivoconcapas.txt"))
            myline = myfile.readline()
            while myline:
                print(myline)
                exec(myline)
                myline = myfile.readline()#para pasar a la siguiente
            time.sleep(1)
            #lo nuevo acaba aqui
            if self.dlg.radioButtonSolar.isChecked():
                tiporenovable="solar"
                resultado1=self.crucecapasvectoriales(lyr9,sensifoto,carpetasalida)
                resultado2=self.distancia1(bic,lyr9,carpetasalida)
                resultado3=self.distancia2(lyr9,carpetasalida,500,parcelas,nucleos)
                resultado4=self.crucecapasvectoriales2(lyr9,regadios,carpetasalida)
                self.hagomapa(carpetasalida,'FOTOVOLTAICA',nombre_parque_b,resultado1,resultado2,resultado3,resultado4,escala)
            if self.dlg.radioButtonEolica.isChecked():
                tiporenovable="eolica"
                resultado11=self.crucecapasvectoriales(lyr9,sensieo,carpetasalida)
                resultado22=self.distancia1(bic,lyr9,carpetasalida)
                resultado33=self.distancia2(lyr9,carpetasalida,1000,parcelas,nucleos)
                resultado44=self.crucecapasvectoriales2(lyr9,regadios,carpetasalida)
                self.hagomapa(carpetasalida,'E√ìLICA',nombre_parque_b,resultado11,resultado22,resultado33,resultado44,escala)

            os.startfile(carpetasalida)

            
    

            
