# -*- coding: cp1252 -*-
"""
/***************************************************************************
 Sigpac
                                 A QGIS plugin
 Carga una capa con los recintos o las parcelas del sigpac que se indique, bien selecionado el codigo, bien introduciendo una coordenada.
 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-29
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Javier Diez Rabanos
        email                : dierabfr@jcyl.es
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


from PyQt5 import QtWidgets
from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QVariant#,QFileInfo
from qgis.PyQt.QtGui import QIcon, QColor,QFont
from qgis.PyQt.QtWidgets import QAction, QFileDialog,QMessageBox,QInputDialog
from PyQt5.QtWidgets import QMessageBox
from qgis.core import QgsSettings

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .sigpac_dialog import SigpacDialog
from .config_dialog import ConfigDialog
import os.path

#import para procesar
import qgis.core as qgisCore
from qgis.core import QgsProject, QgsVectorLayer,QgsField,QgsExpression,QgsExpressionContext,QgsExpressionContextScope,QgsVectorFileWriter, QgsMarkerSymbol,QgsRendererCategory,QgsCategorizedSymbolRenderer,QgsPointXY, QgsPoint,QgsFeature,QgsGeometry,QgsLineSymbol,QgsFillSymbol,QgsSingleSymbolRenderer,QgsPalLayerSettings,QgsTextFormat ,QgsVectorLayerSimpleLabeling,QgsExpressionContextUtils, QgsApplication, QgsTextBufferSettings
from qgis.utils import iface

from qgis.gui import QgsMapToolEmitPoint

#from qgis.gui import QgsMessageBar
import os
import processing
import os
import glob
import re
import sys

import ast
import math
import time
import random

from PyQt5.QtCore import Qt
from qgis.gui import QgsMapTool

from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.gui import QgsMapToolEmitPoint, QgsRubberBand
from qgis.core import QgsWkbTypes, QgsPointXY, QgsApplication

import webbrowser

settings = QgsSettings()

class CoordinateCaptureMapTool(QgsMapToolEmitPoint):
    mouseClickedsenal = pyqtSignal(QgsPointXY)

    def __init__(self, canvas):
        print("cambio el cusor y empiezo a escuchar")
        super(CoordinateCaptureMapTool, self).__init__(canvas)
        self.mapCanvas = canvas
        self.setCursor(QgsApplication.getThemeCursor(QgsApplication.Cursor.CrossHair))
        
    def canvasPressEvent(self, e):
        if e.button() == Qt.LeftButton:
            originalPoint = QgsPointXY(self.mapCanvas.getCoordinateTransform().toMapCoordinates(e.x(), e.y()))
            self.mouseClickedsenal.emit(originalPoint)
            print("emitido desde el canvaspressevent")
            
        
    """def deactivate(self):
        #self.rubberBand.reset(QgsWkbTypes.LineGeometry)
        super(CoordinateCaptureMapTool, self).deactivate()"""

            



class SendPointToolCoordinates(QgsMapTool): #old
    """ devuelve la coordenada en la que se ha hecho click en el mapa.
    """
    
    def __init__(self, canvas, layer):
        """ Constructor.
        """
        QgsMapTool.__init__(self, canvas)
        self.canvas = canvas
        self.layer = layer
        self.setCursor(Qt.CrossCursor)

        
        


    """def canvasReleaseEvent(self, event):
        import os

        usuario=QgsApplication.qgisSettingsDirPath()
        fileclick=os.path.join(usuario,r"python\plugins\sigpac\clik.txt")
        archivo = open(fileclick, "w")
        point = self.toLayerCoordinates(self.layer, event.pos())
        x=point.x()
        y=point.y()
        archivo.write(str(x)+"\n")
        archivo.write(str(y))
        print(x,y)
        archivo.close()
        
        self.canvas.unsetMapTool(self)

        #nuevo desde aqui
        #a partir de aqui lo copio pego como si hubiera escrito la coordenada en el combobox.
        #creo una capa temporal con las coordenadas
        # create layer
        vl2 = QgsVectorLayer("Point?crs=epsg:25830", "Punto", "memory")
        pr2 = vl2.dataProvider()
        
        vl2.startEditing()
        # add fields
        pr2.addAttributes([
                        QgsField("x",  QVariant.Double),
                        QgsField("y", QVariant.Double)])
        vl2.updateFields() 
        # tell the vector layer to fetch changes from the provider
        
        #$add a feature
        fet = QgsFeature()
        fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(x),float(y))))
        fet.setAttributes([ float(x),float( y)])
        pr2.addFeatures([fet])
        
        
       
        #cambio la simbologia
        symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'blue','size': '3',})
        vl2.renderer().setSymbol(symbol)

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl2.updateExtents()
        vl2.commitChanges()
        vl2.updateExtents()
        #canvas = self.iface.mapCanvas()
        self.canvas.setExtent(vl2.extent())


        #QgsProject.instance().addMapLayer(vl)
        QgsProject.instance().addMapLayer(vl2)"""









class Config:
    def __init__(self, iface):
        self.dlg2 = ConfigDialog()

class Sigpac:
    """QGIS Plugin Implementation."""
    #la variable almacen contendra en forma de lista los datos necesario de provincia,usodecomarca, comarca, comarcas y municipios

    def __init__(self, iface):
        global almacen
        global almacen0
        global recintosselecionados
        
        almacen=["",False,"",[],[],0]
        almacen0=["",False,"",[],[]]
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Sigpac_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        self.dlg = SigpacDialog()
        self.dlg2 = ConfigDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sigmena')
        
        #self.toolbar = self.iface.addToolBar(u'Sigmena')             #creo que no hace nada
        #self.toolbar.setObjectName(u'Sigmena')            #creo que no hace nada
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        global usarcomarca
        #ojo esto luego lo debera buscar del gui
        if self.dlg.mycheckbox2.isChecked():
            usarcomarca=True
        else:
            usarcomarca=False
        #hago lo mismo con el usar recintos o parcelas
        recintosselecionados=bool()
        
        self.first_start = None
        self.dlg.pushButton_select_path.clicked.connect(self.select_file)
        self.dlg.pushButton_limpiar.clicked.connect(self.limpiar)
        self.dlg.cbMUN.activated.connect(self.limpiar2)
        self.dlg.MUN.textChanged.connect(self.limpiar3)
        self.dlg.mycheckbox2.toggled.connect(self.pinchoenusarcomarca)#(self.usarcomarcascambia)

        

        
        self.dlg.cbPRO.activated.connect(self.pinchoenprovincia)#(self.rellenarcombocom)
        self.dlg.cbCOM.activated.connect(self.pinchoencomarca)#(self.rellenarcombomun)

        #self.dlg.pushButton_click.clicked.connect(self.pincharenbotonclick)

        #abre la nueva ventana de configuracion



        self.dlg.pushButton_clikenmapa.clicked.connect(self.startCapturing) 

        self.mapTool = CoordinateCaptureMapTool(self.iface.mapCanvas())
        self.mapTool.mouseClickedsenal.connect(self.mouseClicked)

        self.dlg.radioButtonRecintos.toggled.connect(self.funcionrecintos)
        self.dlg.radioButtonParcelas.toggled.connect(self.funcionparcelas)
        self.dlg.help_button.clicked.connect(self.help_pressed)
        

        
        

        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
       
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Sigpac', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        


        
        #cambio el icon path para mi equipo.

        usuario=QgsApplication.qgisSettingsDirPath()
        icon_path=os.path.join(usuario,r"python\plugins\sigpac\icon.png")
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/sigpac/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Sigpac'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

        #cojo los parametros necesarios del archivo de configuracion
        global ano
        global rutaarchivomunicipiossigpac
        global rutacarpetarecintos
        global usarcomarca
        global miprovincia
        global micomarca
        #global rutacache
        rutaarchivoconfiguracion=r"O:\sigmena\utilidad\PROGRAMA\QGIS\Complementos\Sigpac_configuracion.txt" #os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\sigpac\configuracion.txt")
        #rutacache=os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\sigpac\cache.txt")
        if os.path.isfile(rutaarchivoconfiguracion) ==True:
            #fileconfig = open(rutaarchivoconfiguracion, "r")
            # leer un archivo de texto que contiene una lista con tres elementos en cada linea y convertirlo en una lista de listas
            def leer_archivo_configuracion(ruta_archivo):
                with open(ruta_archivo, "r") as archivo:
                    lineas = archivo.readlines()
                lista = [linea.strip().split(",") for linea in lineas]
                return lista
            listaconfiguracion=leer_archivo_configuracion(rutaarchivoconfiguracion)
            print(listaconfiguracion)
            def filtrar_lista_de_listas(listafinal, parametro):
                listafiltrada = [lista for lista in listafinal if lista[0] == parametro]
                return listafiltrada
            try:
                ano=self.dlg.ANNO.text()
                print(ano)
            except:
                ano="2025"
                print("paso por la excepcion del año")
            print("año linea 350",ano)
            print("lista filtrada ",filtrar_lista_de_listas(listaconfiguracion, ano)[0])
            ano,rutaarchivomunicipiossigpac, rutacarpetarecintos=filtrar_lista_de_listas(listaconfiguracion, ano)[0]
            print("año,ruta1,ruta2",ano,rutaarchivomunicipiossigpac, rutacarpetarecintos)

            #fileconfigleido=fileconfig.readlines()

        if os.path.isfile(rutaarchivoconfiguracion) ==False:
            fileconfig = open(rutaarchivoconfiguracion, "w")
            fileconfig.close()
            rutaarchivomunicipiossigpac=""
            rutacarpetarecintos=""


    def help_pressed(self):
        help_file = r'O:\sigmena/utilidad/PROGRAMA/QGIS/Complementos/Manual/Manual_Sigpac_SIGMENA.htm'
        webbrowser.open_new(help_file)
        
    
    def select_file(self): 
        """seleciono la carpeta con los datos de entrada"""
     
        
        #self.dlg.carpetalaz.clear()
        carpeta = QFileDialog.getSaveFileName(self.dlg , "Nuevo archivo shp",None ,'SHP(*.shp)')
   
        self.dlg.ruta_archivo.setText(carpeta[0])
  
        archivo=carpeta[0]
 

   
    def hacerclickenmapa_pressed(self):
        print ("ahora deberia cambiar el cursor por uno que recoja la coordenada cuando cliquee")
        layer, canvas = iface.activeLayer(), iface.mapCanvas()

        #send_point_tool_coordinates = SendPointToolCoordinates(canvas,layer)
        self.dockwidget.captureButton.clicked.connect(self.startCapturing)
        #cuando haga click en el mapa, evento, se guardara la coordenada
        #canvas.setMapTool(send_point_tool_coordinates)#.resultado())
         

        
        self.dlg.close()
        #leo la x y la y que acabo de guardar
        usuario=QgsApplication.qgisSettingsDirPath()
        fileclick=os.path.join(usuario,r"python\plugins\sigpac\clik.txt")
        archivo = open(fileclick, "r")
        #print(archivo.readline(0))
        x=float(archivo.readline()[:-1])#float(archivo.readline(0))
        print("x",x)
        y=float(archivo.readline())#float(archivo.readlines(1))
        print("y",y)
        """for linea in archivo.readlines():
            print linea"""

        #esta funcion deberia estar en el click event.
        """
        #a partir de aqui lo copio pego como si hubiera escrito la coordenada en el combobox.
        #creo una capa temporal con las coordenadas
        # create layer
        vl2 = QgsVectorLayer("Point?crs=epsg:25830", "Punto", "memory")
        pr2 = vl2.dataProvider()
        
        vl2.startEditing()
        # add fields
        pr2.addAttributes([
                        QgsField("x",  QVariant.Double),
                        QgsField("y", QVariant.Double)])
        vl2.updateFields() 
        # tell the vector layer to fetch changes from the provider
        
        #$add a feature
        fet = QgsFeature()
        fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(x),float(y))))
        fet.setAttributes([ float(x),float( y)])
        pr2.addFeatures([fet])
        
        
       
        #cambio la simbologia
        symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'blue','size': '3',})
        vl2.renderer().setSymbol(symbol)
        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl2.updateExtents()
        vl2.commitChanges()
        vl2.updateExtents()
        canvas = self.iface.mapCanvas()
        canvas.setExtent(vl2.extent())
        #QgsProject.instance().addMapLayer(vl)
        QgsProject.instance().addMapLayer(vl2)
        layerbase = QgsVectorLayer(rutaarchivomunicipiossigpac, "municipio", 'ogr')
        processing.run("native:selectbylocation", {'INPUT':layerbase,'PREDICATE':[0],'INTERSECT':vl2,'METHOD':0})
        sellectionado = layerbase.selectedFeatureIds()
        #QgsProject.instance().addMapLayers([layerbase])
        mun = str(layerbase.getFeature(sellectionado[0])["C_PROVMUN"])
        #cuando se el municipio lo cargo y seleciono el punto de nuevo
        caparecintos=os.path.join(rutacarpetarecintos,"RECFE20_"+str(mun)+".shp")
        layer = QgsVectorLayer(caparecintos, str(mun), 'ogr')
        #seleciono de nuevo por la localizacion sobre esta capa del municipio
        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':vl2,'METHOD':0})
        sellectionado2 = layer.selectedFeatureIds()
        
        
        pol = str(layer.getFeature(sellectionado2[0])["C_POLIGONO"])
        par = str(layer.getFeature(sellectionado2[0])["C_PARCELA"])"""
    def startCapturing(self):
        self.iface.mapCanvas().setMapTool(self.mapTool)
        self.dlg.close()
        
    def mouseClicked(self, point: QgsPointXY):
        #recibe el evento emitido por la senal
        
        self.update(point)
        #self.mapTool.deactivate()
        

    def update(self, point: QgsPointXY):
        global recintosselecionados
        #userCrsPoint = self.transform.transform(point)
        #self.dockwidget.userCrsEdit.setText('{0:.{2}f},{1:.{2}f}'.format(userCrsPoint.x(), userCrsPoint.y(), self.userCrsDisplayPrecision))
        
        #self.dockwidget.canvasCrsEdit.setText('{0:.{2}f},{1:.{2}f}'.format(point.x(),point.y(),self.canvasCrsDisplayPrecision))
        print('{0:.{2}f},{1:.{2}f}'.format(point.x(),point.y(),2))
        x=point.x()
        y=point.y()
        ano=self.dlg.ANNO.text()
        print(ano)
        #a partir de aqui lo copio pego como si hubiera escrito la coordenada en el combobox.
        #creo una capa temporal con las coordenadas
        # create layer
        vl2 = QgsVectorLayer("Point?crs=epsg:25830", "Punto", "memory")
        pr2 = vl2.dataProvider()
        
        vl2.startEditing()
        # add fields
        pr2.addAttributes([
                        QgsField("x",  QVariant.Double),
                        QgsField("y", QVariant.Double)])
        vl2.updateFields() 
        # tell the vector layer to fetch changes from the provider
        
        #$add a feature
        fet = QgsFeature()
        fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(x),float(y))))
        fet.setAttributes([ float(x),float( y)])
        pr2.addFeatures([fet])

        #hago un bufer al rededor del punto con la distancia leida del cuadro de dialogo
        radio=int(self.dlg.lineedit_radio.text())
        parametros={ 'DISSOLVE' : False, 'DISTANCE' : radio, 'END_CAP_STYLE' : 0, 'INPUT' : vl2, 'JOIN_STYLE' : 0, 'MITER_LIMIT' : 2, 'OUTPUT' : 'TEMPORARY_OUTPUT', 'SEGMENTS' : 5 }
        mibufer=processing.run('native:buffer',parametros)
        capabufer=mibufer['OUTPUT']
        #QgsProject.instance().addMapLayer(capabufer)
        
       
        #cambio la simbologia
        symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'blue','size': '3',})
        vl2.renderer().setSymbol(symbol)

        

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl2.updateExtents()
        vl2.commitChanges()
        vl2.updateExtents()
        canvas = self.iface.mapCanvas()
        #canvas.setExtent(vl2.extent())

        #nuevo
        rutaarchivoconfiguracion = r"O:\sigmena\utilidad\PROGRAMA\QGIS\Complementos\Sigpac_configuracion.txt"  # os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\sigpac\configuracion.txt")
        def leer_archivo_configuracion(ruta_archivo):
            with open(ruta_archivo, "r") as archivo:
                lineas = archivo.readlines()
            lista = [linea.strip().split(",") for linea in lineas]
            return lista
        listaconfiguracion = leer_archivo_configuracion(rutaarchivoconfiguracion)
        def filtrar_lista_de_listas(listafinal, parametro):
            listafiltrada = [lista for lista in listafinal if lista[0] == parametro]
            return listafiltrada
        ano, rutaarchivomunicipiossigpac, rutacarpetarecintos = filtrar_lista_de_listas(listaconfiguracion, ano)[0]
        print("año,ruta1,ruta2", ano, rutaarchivomunicipiossigpac, rutacarpetarecintos)
        #nuevo

        #QgsProject.instance().addMapLayer(vl)
        #QgsProject.instance().addMapLayer(vl2)
        layerbase = QgsVectorLayer(rutaarchivomunicipiossigpac.strip(), "municipio", 'ogr')
        #VOY A CAPTURAR EL MUNICIPIO DONDE DAE EL PUNTO
        processing.run("native:selectbylocation", {'INPUT':layerbase,'PREDICATE':[0],'INTERSECT':vl2,'METHOD':0})
        sellectionado = layerbase.selectedFeatureIds()
        #QgsProject.instance().addMapLayers([layerbase])
        try:
            mun = str(layerbase.getFeature(sellectionado[0])["C_PROVMUN"])
            print (mun)
        except:
            mun= ''
        #cuando se el municipio lo cargo y seleciono el punto de nuevo
        caparecintos=os.path.join(rutacarpetarecintos,"RECFE"+str(ano[2:])+"_"+str(mun)+".shp")
        print(caparecintos.strip())
        layer = QgsVectorLayer(caparecintos.strip(), str(mun), 'ogr')
        #seleciono de nuevo por la localizacion sobre esta capa del municipio
        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':capabufer,'METHOD':0})
        sellectionado2 = layer.selectedFeatureIds()
        try:
            lyr9=processing.run('native:saveselectedfeatures', { "INPUT": layer, "OUTPUT": "memory: Sigpac_"+str(ano)+"_Click_recintos" })['OUTPUT']
        
            #cuenta elementos
            elementos=len(list(lyr9.getFeatures()))
            sym1 = QgsFillSymbol.createSimple({'style': 'vertical','color': '0,0,0,0', 'outline_color': 'blue'})
            renderer=QgsSingleSymbolRenderer(sym1)
            #etiqueto
            layer_settings  = QgsPalLayerSettings()
            text_format = QgsTextFormat()
            text_format.setFont(QFont("Arial", 12))
            text_format.setSize(12)
            text_format.setColor(QColor("Blue"))
            #le meto un buffer a la etiqueta
            buffer_settings = QgsTextBufferSettings()
            buffer_settings.setEnabled(True)
            buffer_settings.setSize(1)
            buffer_settings.setColor(QColor("white"))

            text_format.setBuffer(buffer_settings)
            layer_settings.setFormat(text_format)
        except:
            elementos=0
        if elementos==0:
            iface.messageBar().pushMessage("SIGPAC","Has hecho click fuera de la provincia", qgisCore.Qgis.Info,5)
            
            #QgsProject.instance().removeMapLayer(layer)
            #canvas.freeze(False)  
       
        if elementos>1 and recintosselecionados==False :
            
            layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''
            #hacer un dissolve y llamar a la capa de salida igual
            #archivo2=os.environ['TMP']+r"/"+str(random.random())+".shp"
           
            #processing.run("native:dissolve",{ 'FIELD' : [], 'INPUT' : archivo3, 'OUTPUT' : archivo2 })
            lyr8=processing.run("native:dissolve",{ 'FIELD' : ['C_PROVINCI','C_MUNICIPI','C_AGREGADO','C_ZONA','C_POLIGONO','C_PARCELA'], 'INPUT' : lyr9, 'OUTPUT' : "memory:"+"Sigpac_"+str(ano)+" Click_parcelas" })['OUTPUT']
            lyr9=processing.run("qgis:deletecolumn",{ 'COLUMN' : ['L_PERIMETR','L_SUP_SIGP','DN_PK','DN_OID','DN_VERSION','DN_VERSI_1','C_RECINTO','C_USO_SIGP','C_COEF_REG','M_PENDIENT','CAP_AUTO','FACTOR_SUE','FACTOR_PEN','FACTOR_VEG','CAP_MANUAL','FECHA_CAMP','REGION','GRUPO_CULT','PORC_INT_C','PORC_INT_P','CAP_RESULT','INCIDENCIA','PARCELA_AG','C_REFREC','PROVMUN','TIPO','SPLIT','Shape_Leng','Shape_Area'], 'INPUT' : lyr8, 'OUTPUT' : "memory:"+"Sigpac_"+str(ano)+"_click_parcelas"  })['OUTPUT']

            #calculo la superficie de la parcela, otra opcion seria sumar la superficie de los recintos
            lyr9.startEditing()

            fields = lyr9.fields()
            idx = fields.indexFromName('SUP_SIGPAC')
                
            if idx == -1:
                myField = QgsField( 'SUP_SIGPAC', QVariant.Double )
                lyr9.dataProvider().addAttributes([myField])
                lyr9.updateFields()
                

            for f in lyr9.getFeatures():
                f.setAttribute(f.fieldNameIndex('SUP_SIGPAC'), f.geometry().area()/10000 )
                #f[idx] = '"$area"*1000'
                lyr9.updateFeature( f )

            lyr9.commitChanges()

            layer_settings.isExpression = True
            layer_settings.enabled = True
            layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
            #lyr9=QgsVectorLayer(archivo2,"Sigpac_"+str(mun)+"_"+str(pol)+"_"+str(par),"ogr")
            lyr9.setLabelsEnabled(True)
            lyr9.setLabeling(layer_settings)
            lyr9.triggerRepaint()
            lyr9.setRenderer(renderer)
            QgsProject.instance().addMapLayer(lyr9)
            #QgsProject.instance().removeMapLayer(layer)
            #canvas.freeze(False)
            lyr9.updateExtents()
            lyr9.commitChanges()
            lyr9.updateExtents()
            #canvas.setExtent(lyr9.extent())

                    
                    
        if elementos>1 and recintosselecionados==True :
           
            layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA",' Rec ',"C_RECINTO")'''
            layer_settings.isExpression = True
            layer_settings.enabled = True
            layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
            lyr9.setLabelsEnabled(True)
            lyr9.setLabeling(layer_settings)
            lyr9.triggerRepaint()
            lyr9.setRenderer(renderer)
            QgsProject.instance().addMapLayer(lyr9)
            #QgsProject.instance().removeMapLayer(layer)
            #canvas.freeze(False)
            lyr9.updateExtents()
            lyr9.commitChanges()
            lyr9.updateExtents()
            #canvas.setExtent(lyr9.extent())

















        





        

        """sym1 = QgsFillSymbol.createSimple({'style': 'vertical','color': '0,0,0,0', 'outline_color': 'blue'})
        renderer=QgsSingleSymbolRenderer(sym1)
        #etiqueto
        layer_settings  = QgsPalLayerSettings()
        text_format = QgsTextFormat()
        text_format.setFont(QFont("Arial", 12))
        text_format.setSize(12)
        text_format.setColor(QColor("Blue"))
        #le meto un buffer a la etiqueta
        buffer_settings = QgsTextBufferSettings()
        buffer_settings.setEnabled(True)
        buffer_settings.setSize(1)
        buffer_settings.setColor(QColor("white"))
        text_format.setBuffer(buffer_settings)
        layer_settings.setFormat(text_format)
        layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''            
        layer_settings.isExpression = True
        layer_settings.enabled = True
        layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
        lyr9.setLabelsEnabled(True)
        lyr9.setLabeling(layer_settings)
        lyr9.triggerRepaint()
        lyr9.setRenderer(renderer)
        QgsProject.instance().addMapLayer(lyr9)
        #QgsProject.instance().removeMapLayer(layer)
        #canvas.freeze(False)
        lyr9.updateExtents()
        lyr9.commitChanges()
        lyr9.updateExtents()
        #canvas.setExtent(lyr9.extent())
        
        
        pol = str(layer.getFeature(sellectionado2[0])["C_POLIGONO"])
        par = str(layer.getFeature(sellectionado2[0])["C_PARCELA"])
        #QgsProject.instance().addMapLayers([layer])"""
        print("se supone que he hecho lo que tenia que hacer")

        canvas.unsetMapTool(self.mapTool)
     

        #aqui estoy en el punto de partida como si hubiese metido municipio, poligono y parcela 

        #aqui estoy en el punto de partida como si hubiese metido municipio, poligono y parcela   ################################################
        
    def hacerclickenmapa_pressed_1(self):#old
        print ("ahora deberia cambiar el cursor por uno que recoja la coordenada cuando cliquee")
        layer, canvas = iface.activeLayer(), iface.mapCanvas()

        send_point_tool_coordinates = SendPointToolCoordinates(canvas,layer)
        #cuando haga click en el mapa, evento, se guardara la coordenada
        canvas.setMapTool(send_point_tool_coordinates)#.resultado())
        
        self.dlg.close()
        #leo la x y la y que acabo de guardar
        usuario=QgsApplication.qgisSettingsDirPath()
        fileclick=os.path.join(usuario,r"python\plugins\sigpac\clik.txt")
        archivo = open(fileclick, "r")
        #print(archivo.readline(0))
        x=float(archivo.readline()[:-1])#float(archivo.readline(0))
        print("x",x)
        y=float(archivo.readline())#float(archivo.readlines(1))
        print("y",y)
        """for linea in archivo.readlines():
            print linea"""

        #esta funcion deberia estar en el click event.
        """
        #a partir de aqui lo copio pego como si hubiera escrito la coordenada en el combobox.
        #creo una capa temporal con las coordenadas
        # create layer
        vl2 = QgsVectorLayer("Point?crs=epsg:25830", "Punto", "memory")
        pr2 = vl2.dataProvider()
        
        vl2.startEditing()
        # add fields
        pr2.addAttributes([
                        QgsField("x",  QVariant.Double),
                        QgsField("y", QVariant.Double)])
        vl2.updateFields() 
        # tell the vector layer to fetch changes from the provider
        
        #$add a feature
        fet = QgsFeature()
        fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(x),float(y))))
        fet.setAttributes([ float(x),float( y)])
        pr2.addFeatures([fet])
        
        
       
        #cambio la simbologia
        symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'blue','size': '3',})
        vl2.renderer().setSymbol(symbol)
        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl2.updateExtents()
        vl2.commitChanges()
        vl2.updateExtents()
        canvas = self.iface.mapCanvas()
        canvas.setExtent(vl2.extent())
        #QgsProject.instance().addMapLayer(vl)
        QgsProject.instance().addMapLayer(vl2)
        layerbase = QgsVectorLayer(rutaarchivomunicipiossigpac, "municipio", 'ogr')
        processing.run("native:selectbylocation", {'INPUT':layerbase,'PREDICATE':[0],'INTERSECT':vl2,'METHOD':0})
        sellectionado = layerbase.selectedFeatureIds()
        #QgsProject.instance().addMapLayers([layerbase])
        mun = str(layerbase.getFeature(sellectionado[0])["C_PROVMUN"])
        #cuando se el municipio lo cargo y seleciono el punto de nuevo
        caparecintos=os.path.join(rutacarpetarecintos,"RECFE20_"+str(mun)+".shp")
        layer = QgsVectorLayer(caparecintos, str(mun), 'ogr')
        #seleciono de nuevo por la localizacion sobre esta capa del municipio
        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':vl2,'METHOD':0})
        sellectionado2 = layer.selectedFeatureIds()
        
        
        pol = str(layer.getFeature(sellectionado2[0])["C_POLIGONO"])
        par = str(layer.getFeature(sellectionado2[0])["C_PARCELA"])
     
        #aqui estoy en el punto de partida como si hubiese metido municipio, poligono y parcela   """
        
                
          
                
          

    

    def limpiar(self):
        global almacen
        #self.dlg.PRO.setText('')##displayText()
        self.dlg.cbMUN.setCurrentIndex(0)
        self.dlg.MUN.setText('')##displayText()
        self.dlg.POL.setText('')##displayText()
        self.dlg.PAR.setText('')##displayText()
        self.dlg.XX.setText('')##displayText()
        self.dlg.YY.setText('')##displayText()

    def limpiar2(self):
        self.dlg.MUN.setText('')##displayText()
    def limpiar3(self):
        self.dlg.cbMUN.setCurrentIndex(0)

    
    def pinchoenprovincia(self):
        global almacen
        global almacen0
        self.dlg.cbMUN.clear()
        self.dlg.cbMUN.setCurrentIndex(0)
        print("1 cojo la provincia seleccionada en el combo")
        provincias=[["","00"],["Avila","05"],["Burgos","09"],["León","24"],["Palencia","34"],["Salamanca","37"],["Segovia","40"],["Soria","42"],["Valladolid","47"],["Zamora","49"]]# ojo cambiada esta linea avila y burgos solo llevan ahora un caracter. Antes fallaba a la hora de buscar la comarca.
        indpro=self.dlg.cbPRO.currentIndex()
        provincia=str("{:02d}".format(int((provincias[int(indpro)][1]))))
        print(provincia)
        print ("escribo la provincia en el almacen")
        almacen[0]=provincia

        #para ver si tengo que rellenar las comarcas
        print ("leo del almacen si true o false y lo pongo en pantalla")
        print ("lacabo de pinchar en provincia")
        print("almacen",almacen[0], 'linea 837')
        if almacen[1]=="False":
            print("1.1 no tengo selecionado que use la comarca")
            self.dlg.cbMUN.clear()
            self.dlg.cbMUN.setCurrentIndex(0)
            self.dlg.mycheckbox2.setChecked (False)
            usarcomarca=False
            almacen[2]=""
            almacen[3]=[]
            #ahora deberia rellenar los municipios de la cache o no
            if almacen[0]==almacen0[0] and almacen0[1]=="False":
                print("almacen", almacen0[0], 'linea 848')
                print("1.1.1 la provincia es la misma dela cache y no tengo que mirar las comarcas, asi que pongo los municipios de la cahce")
                #la lista de municipios que tengo de la cache es la buena
                municipios=almacen[4]
                #anado un elemneto enblanco en el desplegable
                self.dlg.cbMUN.addItem("" ) 
                for element in municipios:
                    self.dlg.cbMUN.addItem( element[0])

            else:
                municipios=[]
                print("1.1.2 no tengo selecionado que use la comarca y la provincia es distinta de la de la cache asi que tengo que leer la capa de munciipios")
                #tengo que sacar los municipios de la capa
                print("tengo que leer todo el shp de municipios")
                #para evitar problemas con la codificacion de los shapes con los municipios y las tildes  ##OJO######
                QSettings().setValue("/qgis/ignoreShapeEncoding", False)
                #selecciono la ruta capa con todos los municipios del sigpac****************************************************************************************************************************
                layerlista = QgsVectorLayer(rutaarchivomunicipiossigpac, 'Municipios Sigpac', 'ogr')
                idpro = layerlista.dataProvider().fieldNameIndex('C_PROVINCI')
                idTM =layerlista.dataProvider().fieldNameIndex('D_NOMBRE')
                idmun=  layerlista.dataProvider().fieldNameIndex('C_PROVMUN')
                feats = [ feat for feat in layerlista.getFeatures() ]
                for feature in feats:
                    lista=[]
                    #filtro para meter solo los municipios de la provincia que me interesa
                    print('linea 873 ',feature.attributes()[idpro])
                    if str(feature.attributes()[idpro]).zfill(2)==almacen[0]:  #antes ponia pro, tengo que analizar que sea la que tengo seleccionada, no la del txt
                        lista=[feature.attributes()[idTM],feature.attributes()[idpro], feature.attributes()[idmun]]
                        municipios.append(lista)
                #ordeno por el primer elemento
                municipios.sort(key=lambda x: x[2])
                #anado un elemneto enblanco en el desplegable
                self.dlg.cbMUN.addItem("" ) 
                for element in municipios:
                    self.dlg.cbMUN.addItem( element[0])
                almacen[4]=municipios
                almacen[2]=""
                almacen[3]=[]
                
            
        else:
            print("1.2")
            usarcomarca=True
            almacen[1]="True"
            self.dlg.mycheckbox2.setChecked (True)
            #relleno las comarcas
            #si la provincia es la del cache
            if almacen[0]==almacen0[0]:
                print("1.2.1")
                #para rellenar las comarcas 
                comarca=almacen[2]
                comarcas=almacen0[3]
                print("lo limpio")
                self.dlg.cbCOM.clear()
                #anado un elemneto enblanco en el desplegable
                print("Estoy cambaido la comarca porque he cambiado la provincia.")
                self.dlg.cbCOM.addItem("") 
                for element in comarcas:
                    self.dlg.cbCOM.addItem(element)#[0])
                #ahora tendre que tocar en una comarca para despues poner los municipios correspondientes. eso es otro cantar
                    
            else:
                print("1.2.2")
                #relleno las comarcas busscando en la capa shp
                self.dlg.cbCOM.setCurrentIndex(0)
                self.dlg.cbCOM.clear()
                #tengo que leer todos los municipios para sacar las comarcas de esa provincia
                print("tengo que leer todo el shp de municipios.......................")
                #para evitar problemas con la codificacion de los shapes con los municipios y las tildes  ##OJO######
                QSettings().setValue("/qgis/ignoreShapeEncoding", False)
                #selecciono la ruta capa con todos los municipios del sigpac****************************************************************************************************************************
                layerlista = QgsVectorLayer(rutaarchivomunicipiossigpac, 'Municipios Sigpac', 'ogr')
                #para rellenar el combo de comarcas
                comarcas=[]
                feats = [ feat for feat in layerlista.getFeatures() ]
                idpro = layerlista.dataProvider().fieldNameIndex('C_PROVINCI')
                idCOM =layerlista.dataProvider().fieldNameIndex('COMARCA')
                idmun=  layerlista.dataProvider().fieldNameIndex('C_PROVMUN')
                for feature in feats:
                    #filtro para meter solo las comarcas de la provincia que me interesa
                    if str("{:02d}".format(int((feature.attributes()[idpro]))))==almacen[0]:#antes ponia pro
                        elemento=feature.attributes()[idCOM]
                        if elemento not in comarcas:
                            comarcas.append(elemento)
                #ordeno por el primer elemento
                comarcas.sort(key=lambda x: x[0]) 
                #anado un elemneto enblanco en el desplegable
                self.dlg.cbCOM.addItem("" ) 
                for element in comarcas:
                    self.dlg.cbCOM.addItem( element)
                almacen[3]=comarcas
                almacen[2]=""
                almacen[4]=[]

                #por aqui he acabado, tendre que tocar en municipio
                
                
        
    def pinchoencomarca(self):
        global almacen
        global almacen0
        self.dlg.cbMUN.clear()
        self.dlg.cbMUN.setCurrentIndex(0)
        #lo unico que tengo que hacer es rellenar los municipios
        #saco que comarca he seleccionado
        print("almacen en linea 950 ", almacen)
        print("almacen0 en linea 950 ", almacen0)
        comarcas=almacen[3]
        indcom=self.dlg.cbCOM.currentIndex()
        comarca=str(comarcas[int(indcom)-1])
        print ("2. comarca seleccionada en el combo",comarca)
        almacen[2]=comarca

        #si la comarca es la del almacen0, entonces solo tengo que leer los municipios del almacen0
        if almacen[2]==almacen0[2]:
            print("2.1")
            municipios=almacen0[4]
        #tengo que sacar los municipios de la capa
        else:
            print("2.2 tengo que leer todo el shp de municipios")
            #para evitar problemas con la codificacion de los shapes con los municipios y las tildes  ##OJO######
            QSettings().setValue("/qgis/ignoreShapeEncoding", False)
            #selecciono la ruta capa con todos los municipios del sigpac****************************************************************************************************************************
            print(rutaarchivomunicipiossigpac.strip())
            layerlista = QgsVectorLayer(rutaarchivomunicipiossigpac.strip(), 'Municipios Sigpac', 'ogr')
            #comprobar si la capa es valida
            if not layerlista.isValid():
                print("Layer failed to load!")
            idpro = layerlista.dataProvider().fieldNameIndex('C_PROVINCI')
            idCOM = layerlista.dataProvider().fieldNameIndex('COMARCA')
            idTM =layerlista.dataProvider().fieldNameIndex('D_NOMBRE')
            idmun=  layerlista.dataProvider().fieldNameIndex('C_PROVMUN')
            feats = [ feat for feat in layerlista.getFeatures() ]
            municipios=[]
            for feature in feats:
                lista=[]
                #filtro para meter solo los municipios de la provincia que me interesa
                if str(feature.attributes()[idCOM])==almacen[2]:  #antes ponia pro, tengo que analizar que sea la que tengo seleccionada, no la del txt
                    lista=[feature.attributes()[idTM],feature.attributes()[idpro], feature.attributes()[idmun]]
                    municipios.append(lista)
            #ordeno por el primer elemento
            municipios.sort(key=lambda x: x[2])
        print(municipios)
        #anado un elemneto enblanco en el desplegable
        self.dlg.cbMUN.addItem("" ) 
        for element in municipios:
            self.dlg.cbMUN.addItem( element[0])
        almacen[4]=municipios
        print("almacen en linea 986 ", almacen)
        
        
        
        #ssi no tengo que leer la capa
    def pinchoenusarcomarca(self):
        
        global almacen
        global almacen0

        print("3. he vaciado los municipios y comarcas")
        self.dlg.cbCOM.setCurrentIndex(0)
        self.dlg.cbCOM.clear()
        self.dlg.cbMUN.setCurrentIndex(0)
        self.dlg.cbMUN.clear()
        if self.dlg.mycheckbox2.isChecked():
            print("3.1")
            almacen[1]="True"
            almacen[2]=""
            #debo rellenar las comarcas de esa provincia.
            #si la provincia es la del almacen0, cojo esas comarcas y las meto al combo
            provincia=almacen[0]
            #para rellenar las comarcas
            if almacen[0]==almacen0[0]:
                print("3.1.1 provincia del almacen0")
                if almacen0[3] ==['']:
                    
                    #almacen[3]
                    #tendre que rellenar las comarcas como siempre
                    print("3.1.1.1 tengo que leer todo el shp de municipios")
                    #para evitar problemas con la codificacion de los shapes con los municipios y las tildes  ##OJO######
                    QSettings().setValue("/qgis/ignoreShapeEncoding", False)
                    #selecciono la ruta capa con todos los municipios del sigpac****************************************************************************************************************************
                    layerlista = QgsVectorLayer(rutaarchivomunicipiossigpac.strip(), 'Municipios Sigpac', 'ogr')
                    #para rellenar el combo de comarcas
                    comarcas=[]
                    feats = [ feat for feat in layerlista.getFeatures() ]
                    idpro = layerlista.dataProvider().fieldNameIndex('C_PROVINCI')
                    idCOM =layerlista.dataProvider().fieldNameIndex('COMARCA')
                    idmun=  layerlista.dataProvider().fieldNameIndex('C_PROVMUN')
                    for feature in feats:
                        #filtro para meter solo las comarcas de la provincia que me interesa
                        if str("{:02d}".format(int((feature.attributes()[idpro]))))==almacen[0]:#antes ponia pro
                            elemento=feature.attributes()[idCOM]
                            if elemento not in comarcas:
                                comarcas.append(elemento)
                    #ordeno por el primer elemento
                    comarcas.sort(key=lambda x: x[0])
                    almacen[3]=comarcas
                else:
                    print("3.1.1.2")
                    comarcas=almacen0[3]
                #anado un elemneto enblanco en el desplegable
                self.dlg.cbCOM.addItem("") 
                for element in comarcas:
                    self.dlg.cbCOM.addItem(element)#[0])
                #ahora tendre que tocar en una comarca para despues poner los municipios correspondientes. eso es otro cantar
                    
            #si la provincia no es la del almacen busco todas las que coincidan en la capa con esa provincia        
            else:
                print("3.1.2")
                #tengo que leer todos los municipios para sacar las comarcas de esa provincia
                print("tengo que leer todo el shp de municipios")
                #para evitar problemas con la codificacion de los shapes con los municipios y las tildes  ##OJO######
                QSettings().setValue("/qgis/ignoreShapeEncoding", False)
                #selecciono la ruta capa con todos los municipios del sigpac****************************************************************************************************************************
                layerlista = QgsVectorLayer(rutaarchivomunicipiossigpac.strip(), 'Municipios Sigpac', 'ogr')
                #para rellenar el combo de comarcas
                comarcas=[]
                feats = [ feat for feat in layerlista.getFeatures() ]
                idpro = layerlista.dataProvider().fieldNameIndex('C_PROVINCI')
                idCOM =layerlista.dataProvider().fieldNameIndex('COMARCA')
                idmun=  layerlista.dataProvider().fieldNameIndex('C_PROVMUN')
                for feature in feats:
                    #filtro para meter solo las comarcas de la provincia que me interesa
                    if str("{:02d}".format(int((feature.attributes()[idpro]))))==almacen[0]:#antes ponia pro
                        elemento=feature.attributes()[idCOM]
                        if elemento not in comarcas:
                            comarcas.append(elemento)
                #ordeno por el primer elemento
                comarcas.sort(key=lambda x: x[0])  
                #anado un elemneto enblanco en el desplegable
                self.dlg.cbCOM.addItem("" ) 
                for element in comarcas:
                    self.dlg.cbCOM.addItem( element)
                almacen[3]=comarcas
        else:#si no esta checkeado el usar las comarcas
            print("3.2")
            almacen[1]="False"
            almacen[2]=""
            almacen[3]=[]
            almacen[4]=[]
            #deberia rellenar los municipios de la provincia seleccionada
            #si la provincia seleccionada es la del cache, solo tengo que cogerlo de la cache

            

            print("si solo quito el usar comarcas y no tengo la provincia orignal voy por aqui")
            #tengo que sacar los municipios de la capa
            print("tengo que leer todo el shp de municipios")
            #para evitar problemas con la codificacion de los shapes con los municipios y las tildes  ##OJO######
            QSettings().setValue("/qgis/ignoreShapeEncoding", False)
            #selecciono la ruta capa con todos los municipios del sigpac****************************************************************************************************************************
            layerlista = QgsVectorLayer(rutaarchivomunicipiossigpac.strip(), 'Municipios Sigpac', 'ogr')
            idpro = layerlista.dataProvider().fieldNameIndex('C_PROVINCI')
            idTM =layerlista.dataProvider().fieldNameIndex('D_NOMBRE')
            idmun=  layerlista.dataProvider().fieldNameIndex('C_PROVMUN')
            #idCOM=layerlista.dataProvider().fieldNameIndex('COMARCA')
            feats = [ feat for feat in layerlista.getFeatures() ]
            municipios=[]
            for feature in feats:
                lista=[]
                #filtro para meter solo los municipios de la provincia que me interesa
                if str(feature.attributes()[idpro])==almacen[0]:  #antes ponia pro, tengo que analizar que sea la que tengo seleccionada, no la del txt
                    lista=[feature.attributes()[idTM],feature.attributes()[idpro], feature.attributes()[idmun]]
                    municipios.append(lista)
            #ordeno por el primer elemento
            municipios.sort(key=lambda x: x[2])
            almacen[4]=municipios
            #anado un elemneto enblanco en el desplegable
            self.dlg.cbMUN.addItem("" ) 
            for element in municipios:
                self.dlg.cbMUN.addItem( element[0])
        
                
            
    def display_point( self,pointTool ):
        print("esta es la funcion que saca las coordenadas")
        #print ('({:.4f}, {:.4f})'.format(pointTool[0], pointTool[1]))
        #canvas.setMapTool(preMapTool)       


        
    def hacerclick(self):
        print("acabo de pinchar en el bton de hacer click en las coordenadas")
        

        
        # a reference to our map canvas 
        #canvas = self.iface.mapCanvas()
        
        # this QGIS tool emits as QgsPoint after each click on the map canvas
        pointTool = QgsMapToolEmitPoint(canvas)
        pointTool.canvasClicked.connect( self.display_point )
        canvas.setMapTool( pointTool )
        print("canvas2 ",canvas)
        print("ok")




    
    
       

   

        


        


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        print("desinstalo")
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.iface.removePluginMenu(
                self.tr(u'&Sigmena'),
                action)


    def funcionrecintos(self):
        global recintosselecionados
        if self.dlg.radioButtonRecintos.isChecked()==True:
            recintosselecionados=True
            print ("Quiero sacar recintos")
            
    def funcionparcelas(self):
        global recintosselecionados
        if self.dlg.radioButtonParcelas.isChecked()==True:
            recintosselecionados=False
            print ("Quiero sacar parcelas")
            
    


    def run(self):
        global almacen
        global almacen0
        global rutaarchivomunicipiossigpac
        global rutacarpetarecintos
        global ano
        
        #global provincias
        #global usarcomarca
        #global miprovincia
        #global micomarca
        #global misdatos
        #global misdatoscomarcas
        #global mismunicipios

        #lo primero leer la cache
        #para recuperar los datos de la ultima vez que se cerro el complemento
        print("0 inicio el run")
        print ("leo la cache.........................................................................................................")
        print("construyo el almecen que es una lista, se nutre de los datos de la cache, postseriormente modificados si pinchas en un combo o boton")


        
        """rutacache=os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\sigpac\cache.txt")
        if os.path.isfile(rutacache) ==True:
            filecache = open(rutacache, "r")
            filecacheleido=filecache.readlines()
            try:
                miprovincia = settings.value("sigpac/miprovincia", "42")#(filecacheleido[0].replace('\n',''))
                usarcomarca= settings.value("sigpac/usarcomarca", "True")#(filecacheleido[1].replace('\n',''))
                micomarca= settings.value("sigpac/micomarca", "Vinuesa")#(filecacheleido[2].replace('\n',''))
                miscomarcas=settings.value("sigpac/miscomarcas", "[Almazan,Agreda,Almarza,Bayubas de Abajo,Burgo de Osma,Covaleda,Gomara,Navaleno,San Leonardo de Yague,San Pedro Manrique,Soria,Vinuesa]").strip('][').split(',')#(filecacheleido[3].replace('\n','')).strip('][').split(',') #convierto una str en una list
                mismunicipios=ast.literal_eval(settings.value("sigpac/mismunicipios", "[['Montenegro de Cameros', 42, '42197'], ['Vinuesa', 42, '42340']]").replace(" [[","[[").replace("]] ","]]"))#.split(','))#ast.literal_eval((filecacheleido[4].replace('\n','')).replace(" [[","[[").replace("]] ","]]"))#.split(',')) #convierto una str en una list
                misrecintos=settings.value("sigpac/misrecintos", "True")#(filecacheleido[5].replace('\n',''))
                if misrecintos=="False":
                    recintosselecionados==False
                    self.dlg.radioButtonParcelas.setChecked(True)
                else:
                    recintosselecionados==True
                    self.dlg.radioButtonRecintos.setChecked(True)
                print("la seleccion de recintos, leida de la cache es ",recintosselecionados, "linea 1199")
                self.dlg.radioButtonRecintos.setChecked (recintosselecionados)
                filecache.close()
                
            except:
                print("esta no encuentra el file cache")"""

        miprovincia = settings.value("sigpac/miprovincia", "42")  # (filecacheleido[0].replace('\n',''))
        usarcomarca = settings.value("sigpac/usarcomarca", "True")  # (filecacheleido[1].replace('\n',''))
        micomarca = settings.value("sigpac/micomarca", "Vinuesa")  # (filecacheleido[2].replace('\n',''))
        miscomarcas = settings.value("sigpac/miscomarcas",
                                     "[Almazan,Agreda,Almarza,Bayubas de Abajo,Burgo de Osma,Covaleda,Gomara,Navaleno,San Leonardo de Yague,San Pedro Manrique,Soria,Vinuesa]").strip(
            '][').split(
            ',')  # (filecacheleido[3].replace('\n','')).strip('][').split(',') #convierto una str en una list
        mismunicipios = ast.literal_eval(settings.value("sigpac/mismunicipios",
                                                        "[['Montenegro de Cameros', 42, '42197'], ['Vinuesa', 42, '42340']]").replace(
            " [[", "[[").replace("]] ",
                                 "]]"))  # .split(','))#ast.literal_eval((filecacheleido[4].replace('\n','')).replace(" [[","[[").replace("]] ","]]"))#.split(',')) #convierto una str en una list
        misrecintos = settings.value("sigpac/misrecintos", "True")  # (filecacheleido[5].replace('\n',''))
        if misrecintos == "False":
            recintosselecionados == False
            self.dlg.radioButtonParcelas.setChecked(True)
        else:
            recintosselecionados == True
            self.dlg.radioButtonRecintos.setChecked(True)
        print("la seleccion de recintos, leida de la cache es ", recintosselecionados, "linea 1199")
        self.dlg.radioButtonRecintos.setChecked(recintosselecionados)
        print("cache leida......................................................................................................................")
        almacen0[0]=miprovincia
        almacen0[1]=usarcomarca
        almacen0[2]=micomarca
        almacen0[3]=miscomarcas
        almacen0[4]=mismunicipios
        #hago una copia que no modificare para usar como cache, la 0 es la del txt
        almacen[0]=miprovincia
        almacen[1]=usarcomarca
        almacen[2]=micomarca
        almacen[3]=miscomarcas
        almacen[4]=mismunicipios
        #almacen[5]=indmun

        canvas = self.iface.mapCanvas()
        print ("canvas1 ",canvas)

        
        #para evitar problemas con la codificacion de los shapes con los municipios y las tildes  ##OJO######
        QSettings().setValue("/qgis/ignoreShapeEncoding", False)

        #selecciono la ruta capa con todos los municipios del sigpac****************************************************************************************************************************
        
        layerlista = QgsVectorLayer(rutaarchivomunicipiossigpac.strip(), 'Municipios Sigpac', 'ogr')
        time.sleep(1)
        #layer = iface.activeLayer()
        ## ojo comprobar que layer existe

        #DEBERIA ESPERAR A QUE LA PROVINCIA CAMBIE PARA HACER ESTO Y CARGAR SOLO LO QUE CONCUERDE CON LA PROVINCIA.
        #lo primero seria leer la provincia.
        
        #Relleno el Combo con als provincias
        print("empiezo a rellenar los desplegables, las provincias del almacen ")
        self.dlg.cbPRO.clear()
        provincias=[["","00"],["Avila","05"],["Burgos","09"],["León","24"],["Palencia","34"],["Salamanca","37"],["Segovia","40"],["Soria","42"],["Valladolid","47"],["Zamora","49"]]
        for elemento in provincias:
                self.dlg.cbPRO.addItem( elemento[0])
        #esto es para poner por defecto la provincia que tenga en el almacen
        lista2=[]
        for elemen in provincias:
            lista2.append(elemen[1])
        indice=lista2.index(almacen[0])
        print("indice de provincia dentro del run",indice)
        #pone la provincia en el combo que tienes en el txt.
        self.dlg.cbPRO.setCurrentIndex(indice)
        
        #para ver si tengo que rellenar las comarcas
        print ("leo del almacen si true o false y lo pongo en pantalla")
        if almacen[1]=="False":
            self.dlg.mycheckbox2.setChecked (False)
            usarcomarca=False
            almacen[1]="False"
            almacen[2]=""
            almacen[3]=[]
        else:
            usarcomarca=True
            almacen[1]="True"
            self.dlg.mycheckbox2.setChecked (True)
        
        
        #para rellenar las comarcas 
            
        print("paso a las comarcas, primero leo la que tengo en el almacen")
        comarca=almacen[2]
        comarcas=almacen[3]
        print("lo limpio")
        self.dlg.cbCOM.clear()
        #anado un elemneto enblanco en el desplegable
        print("Estoy en el run, dentro de lo que se abre la primera vez.")
        self.dlg.cbCOM.addItem("") 
        for element in comarcas:
            self.dlg.cbCOM.addItem(element)#[0])
        if almacen[1]=="True":
            #pongo el indice en la que diga la cache
            indice=comarcas.index(comarca)
            self.dlg.cbCOM.setCurrentIndex(indice+1)#lo que pone en la ventanita, que esta bien
        else:
            pass

        #relleno los municipios que tengo en la cache
        print ("leo los municipios del almacen")
        municipios=almacen[4]
        print("empiezo a rellenar el combo con los municipios")
        self.dlg.cbMUN.clear()

        #misdatos=ast.literal_eval(mismunicipios)
        #anado un elemneto enblanco en el desplegable de municipios
        self.dlg.cbMUN.addItem("" ) 
        for element in municipios:
            self.dlg.cbMUN.addItem(element[0])#( element[0])

        #dejo el puntero del municipio donde estaba si no he cambiado de provincia ni de comarca 
        if almacen[0]==almacen0[0] and almacen[1]==almacen0[1] and almacen[2]==almacen0[2]:
            self.dlg.cbMUN.setCurrentIndex(almacen[5])
            print("mismo municipio")
        else:
            self.dlg.cbMUN.setCurrentIndex(0)
            print("otro municipio")
            
        
                    
                
                    
            





        
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            
            

        # show the dialog
        self.dlg.show()
        
        #self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            def filtrar_lista_de_listas(listafinal, parametro):
                listafiltrada = [lista for lista in listafinal if lista[0] == parametro]
                return listafiltrada

            def obtener_anos(listafinal):
                anos = [lista[0] for lista in listafinal]
                return anos
            comarcas=almacen[3]
            municipios=almacen[4]
            usarcomarca=almacen[1]
            print("0.1 pulso en ok")
            
            archivo=self.dlg.ruta_archivo.text()
            #cojo lo que hay en cada recuadro o desplegable aqui variables que luego deberan estar en la cajita   primero los indicesOJO
            indmun=self.dlg.cbMUN.currentIndex()
            indpro=self.dlg.cbPRO.currentIndex()
            indcom=self.dlg.cbCOM.currentIndex()
            #saco los valores correspondientes
            try:
                comarca=str(comarcas[int(indcom)-1])
            except:
                comarca=""
            pro = str(provincias[int(indpro)][1])
            mun = self.dlg.MUN.text()##displayText()
            pol = self.dlg.POL.text()##displayText()
            par = self.dlg.PAR.text()##displayText()
            x = self.dlg.XX.text()##displayText()
            y = self.dlg.YY.text()##displayText()
            ano = self.dlg.ANNO.text()
            def leer_archivo_configuracion(ruta_archivo):
                with open(ruta_archivo, "r") as archivo:
                    lineas = archivo.readlines()
                lista = [linea.strip().split(",") for linea in lineas]
                return lista

            rutaarchivoconfiguracion = r"O:\sigmena\utilidad\PROGRAMA\QGIS\Complementos\Sigpac_configuracion.txt"
            listaconfiguracion=leer_archivo_configuracion(rutaarchivoconfiguracion)
            if ano not in obtener_anos(listaconfiguracion):
                iface.messageBar().pushMessage("SIGPAC", "NO TENEMOS DISPONIBLE EL AÑO "+ str(ano)+" SELECIONADO. SI CREES QUE DEBIERA ESTARLO COMUNICASELO AL TÉCNICO SIGMENA" , qgisCore.Qgis.Info, 10)
            else:
                if ano not in ['2025']:
                    iface.messageBar().pushMessage( "SIGPAC", "ATENCIÓN, NO ESTÁS CONSULTANDO EL ÚLTIMO SIGPAC DISPONIBLE. SE MUESTRA EL SIGPAC DEL AÑO " + str(
                    ano) ,qgisCore.Qgis.Critical, 10)

                ano, rutaarchivomunicipiossigpac, rutacarpetarecintos = filtrar_lista_de_listas(listaconfiguracion, ano)[0]
                x = x.replace(',','.')
                y = y.replace(',','.')

                #si no hay nada en la casilla de municipio, coge la informacion del desplegable mun es un numero del estilo 42001
                if mun == "":
                    mun=str(municipios[int(indmun)-1][2])#coge la ultima columna de mis datos
                else:
                    mun=str("{:02d}".format(int(pro)))+str("{:03d}".format(int(mun)))
                print("mun",mun)
                print("indmun",indmun)
                almacen[5]=indmun


                #rutacache=os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\sigpac\cache.txt")
                #lo escribo en el txt, mavhacando lo que ya tenia
                #f=open(rutacache,"w")
                #escribir=str(pro)+"\n"+str(usarcomarca)+"\n"+comarca+"\n"+str(comarcas).replace("'","").replace(", ",",")+"\n"+str(municipios)+"\n"+str(recintosselecionados)+"\n"
                #f.write(escribir)
                #f.close()
                settings.setValue("sigpac/miprovincia", str(pro))  # (filecacheleido[0].replace('\n',''))
                settings.setValue("sigpac/usarcomarca", str(usarcomarca))  # (filecacheleido[1].replace('\n',''))
                settings.setValue("sigpac/micomarca", comarca)  # (filecacheleido[2].replace('\n',''))
                settings.setValue("sigpac/miscomarcas",str(comarcas).replace("'","").replace(", ",","))  # (filecacheleido[3].replace('\n','')).strip('][').split(',') #convierto una str en una list
                settings.setValue("sigpac/mismunicipios",    str(municipios) )
                                         #convierto una str en una list
                settings.setValue("sigpac/misrecintos", str(recintosselecionados))  # (filecacheleido[5].replace('\n',''))
                print("he escrito en la cache ",str(recintosselecionados)," linea 1375")

                QgsProject.instance().layerTreeRegistryBridge().setLayerInsertionPoint( QgsProject.instance().layerTreeRoot(), 0 )


                canvas.freeze(True)


                if x is not "" and y is not "" and par=="":
                    #creo una capa temporal con las coordenadas
                    # create layer
                    vl2 = QgsVectorLayer("Point?crs=epsg:25830", "Punto", "memory")
                    pr2 = vl2.dataProvider()

                    vl2.startEditing()
                    # add fields
                    pr2.addAttributes([
                                    QgsField("x",  QVariant.Double),
                                    QgsField("y", QVariant.Double)])
                    vl2.updateFields()
                    # tell the vector layer to fetch changes from the provider

                    #$add a feature
                    fet = QgsFeature()
                    fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(x),float(y))))
                    fet.setAttributes([ float(x),float( y)])
                    pr2.addFeatures([fet])



                    #cambio la simbologia
                    symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'blue','size': '3',})
                    vl2.renderer().setSymbol(symbol)

                    # update layer's extent when new features have been added
                    # because change of extent in provider is not propagated to the layer
                    vl2.updateExtents()
                    vl2.commitChanges()
                    vl2.updateExtents()
                    canvas = self.iface.mapCanvas()
                    canvas.setExtent(vl2.extent())


                    #QgsProject.instance().addMapLayer(vl)
                    #QgsProject.instance().addMapLayer(vl2)
                    layerbase = QgsVectorLayer(rutaarchivomunicipiossigpac.strip(), "municipio", 'ogr')
                    #print(rutaarchivomunicipiossigpac.strip())
                    if not layerbase.isValid():
                        print("Layer failed to load!")
                    processing.run("native:selectbylocation", {'INPUT':layerbase,'PREDICATE':[0],'INTERSECT':vl2,'METHOD':0})
                    sellectionado = layerbase.selectedFeatureIds()
                    #QgsProject.instance().addMapLayers([layerbase])
                    try:
                        mun = str(layerbase.getFeature(sellectionado[0])["C_PROVMUN"])
                        #print("mun",mun)
                    except:
                        mun=''
                        #print("no hay municipio")
                    #cuando se el municipio lo cargo y seleciono el punto de nuevo
                    try:
                        caparecintos=os.path.join(rutacarpetarecintos,"RECFE"+str(ano[2:])+"_"+str(mun)+".shp")
                        layer = QgsVectorLayer(caparecintos.strip(), str(mun), 'ogr')
                        #seleciono de nuevo por la localizacion sobre esta capa del municipio
                        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':vl2,'METHOD':0})
                        sellectionado2 = layer.selectedFeatureIds()
                        pol = str(layer.getFeature(sellectionado2[0])["C_POLIGONO"])
                        par = str(layer.getFeature(sellectionado2[0])["C_PARCELA"])
                    except:
                        pass


                    #aqui estoy en el punto de partida como si hubiese metido municipio, poligono y parcela


                print("aqui estoy en el punto de partida como si hubiese metido municipio, poligono y parcela")
                print(ano[2:])
                caparecintos=os.path.join(rutacarpetarecintos,"RECFE"+str(ano[2:])+"_"+mun+".shp")
                caparecintos = caparecintos.strip()
                #caparecintos = rutacarpetarecintos+"/RECFE" + str(ano[2:]) + "_" + mun + ".shp"
                #print(f"Ruta: {caparecintos}")
                #print(f"Existe: {os.path.exists(caparecintos)}")
                #print("caparecintos ",caparecintos)
                layer = QgsVectorLayer(caparecintos.strip(), "RECFE"+str(ano[2:])+"_"+mun, 'ogr')
                if not layer.isValid():
                    print("Layer failed to load!")
                    print("caparecintos ",caparecintos)
                #QgsProject.instance().addMapLayers([layer])
                #comprobar si la ruta caparecintos es correcta
                if not os.path.exists(caparecintos):
                    print("la capa de recintos no existe")




                layer.selectByExpression("\"C_POLIGONO\" = '{}' ".format(pol)+" AND \"C_PARCELA\" = '{}'".format(par),QgsVectorLayer.SetSelection)
                print("\"C_POLIGONO\" = '{}' ".format(pol)+" AND \"C_PARCELA\" = '{}'".format(par))
                #creo la nueva capa con la seleccion
                #output_path=archivo3
                #ojo esto es lo que acabo de cambiar
                #QgsVectorFileWriter.writeAsVectorFormat(layer, output_path, "CP120", layer.crs(), "ESRI Shapefile", onlySelected=True)
                #lyr9=QgsVectorLayer(output_path,"Sigpac_"+str(mun)+"_"+str(pol)+"_"+str(par),"ogr")
                try:
                    lyr9=processing.run('native:saveselectedfeatures', { "INPUT": layer, "OUTPUT": "memory:"+"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par) })['OUTPUT']




                    sym1 = QgsFillSymbol.createSimple({'style': 'vertical','color': '0,0,0,0', 'outline_color': 'blue'})
                    renderer=QgsSingleSymbolRenderer(sym1)
                    #etiqueto
                    layer_settings  = QgsPalLayerSettings()
                    text_format = QgsTextFormat()
                    text_format.setFont(QFont("Arial", 12))
                    text_format.setSize(12)
                    text_format.setColor(QColor("Blue"))
                    #le meto un buffer a la etiqueta
                    buffer_settings = QgsTextBufferSettings()
                    buffer_settings.setEnabled(True)
                    buffer_settings.setSize(1)
                    buffer_settings.setColor(QColor("white"))

                    text_format.setBuffer(buffer_settings)
                    layer_settings.setFormat(text_format)
                #cuenta elementos
                    elementos=len(list(lyr9.getFeatures()))
                except:
                    elementos=0

                if elementos==0:
                    iface.messageBar().pushMessage("SIGPAC","En el municipio "+str(mun)+" poligono " +str(pol)+" no existe la parcela "+str(par), qgisCore.Qgis.Info,5)

                    #QgsProject.instance().removeMapLayer(layer)
                    #canvas.freeze(False)
                """if elementos==1 and archivo == "": OJO SOLO PARA PRUEBA
                    
                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''            
                    layer_settings.isExpression = True
                    layer_settings.enabled = True
                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    lyr9.setLabelsEnabled(True)
                    lyr9.setLabeling(layer_settings)
                    lyr9.triggerRepaint()
                    lyr9.setRenderer(renderer)
                    QgsProject.instance().addMapLayer(lyr9)
                    #QgsProject.instance().removeMapLayer(layer)
                    #canvas.freeze(False)
                    lyr9.updateExtents()
                    lyr9.commitChanges()
                    lyr9.updateExtents()
                    canvas.setExtent(lyr9.extent())"""
                if elementos>=1 and recintosselecionados==False and archivo == "" :

                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''
                    #hacer un dissolve y llamar a la capa de salida igual
                    #archivo2=os.environ['TMP']+r"/"+str(random.random())+".shp"

                    #processing.run("native:dissolve",{ 'FIELD' : [], 'INPUT' : archivo3, 'OUTPUT' : archivo2 })
                    lyr8=processing.run("native:dissolve",{ 'FIELD' : [], 'INPUT' : lyr9, 'OUTPUT' : "memory:"+"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par) })['OUTPUT']
                    lyr9=processing.run("qgis:deletecolumn",{ 'COLUMN' : ['L_PERIMETR','L_SUP_SIGP','DN_PK','DN_OID','DN_VERSION','DN_VERSI_1','C_RECINTO','C_USO_SIGP','C_COEF_REG','M_PENDIENT','CAP_AUTO','FACTOR_SUE','FACTOR_PEN','FACTOR_VEG','CAP_MANUAL','FECHA_CAMP','REGION','GRUPO_CULT','PORC_INT_C','PORC_INT_P','CAP_RESULT','INCIDENCIA','PARCELA_AG','C_REFREC','PROVMUN','TIPO','SPLIT','Shape_Leng','Shape_Area'], 'INPUT' : lyr8, 'OUTPUT' : "memory:"+"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par) })['OUTPUT']

                    #calculo la superficie de la parcela, otra opcion seria sumar la superficie de los recintos
                    lyr9.startEditing()

                    fields = lyr9.fields()
                    idx = fields.indexFromName('SUP_SIGPAC')

                    if idx == -1:
                        myField = QgsField( 'SUP_SIGPAC', QVariant.Double )
                        lyr9.dataProvider().addAttributes([myField])
                        lyr9.updateFields()


                    for f in lyr9.getFeatures():
                        f.setAttribute(f.fieldNameIndex('SUP_SIGPAC'), f.geometry().area()/10000 )
                        #f[idx] = '"$area"*1000'
                        lyr9.updateFeature( f )

                    lyr9.commitChanges()


                    layer_settings.isExpression = True
                    layer_settings.enabled = True
                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    #lyr9=QgsVectorLayer(archivo2,"Sigpac_"+str(mun)+"_"+str(pol)+"_"+str(par),"ogr")
                    lyr9.setLabelsEnabled(True)
                    lyr9.setLabeling(layer_settings)
                    lyr9.triggerRepaint()
                    lyr9.setRenderer(renderer)
                    QgsProject.instance().addMapLayer(lyr9)
                    #QgsProject.instance().removeMapLayer(layer)
                    #canvas.freeze(False)
                    lyr9.updateExtents()
                    lyr9.commitChanges()
                    lyr9.updateExtents()
                    canvas.setExtent(lyr9.extent())



                if elementos>=1 and recintosselecionados==True and archivo == "":

                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA",' Rec ',"C_RECINTO")'''
                    layer_settings.isExpression = True
                    layer_settings.enabled = True
                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    lyr9.setLabelsEnabled(True)
                    lyr9.setLabeling(layer_settings)
                    lyr9.triggerRepaint()
                    lyr9.setRenderer(renderer)
                    QgsProject.instance().addMapLayer(lyr9)
                    #QgsProject.instance().removeMapLayer(layer)
                    #canvas.freeze(False)
                    lyr9.updateExtents()
                    lyr9.commitChanges()
                    lyr9.updateExtents()
                    canvas.setExtent(lyr9.extent())

                if elementos>1 and recintosselecionados==True and archivo is not "":

                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA",' Rec ',"C_RECINTO")'''
                    layer_settings.isExpression = True
                    layer_settings.enabled = True
                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    #lyr9.setLabelsEnabled(True)
                    #lyr9.setLabeling(layer_settings)
                    #lyr9.triggerRepaint()
                    #lyr9.setRenderer(renderer)
                    #QgsProject.instance().addMapLayer(lyr9)
                    #QgsProject.instance().removeMapLayer(layer)
                    #canvas.freeze(False)

                    QgsVectorFileWriter.writeAsVectorFormat(lyr9, archivo, "CP120", lyr9.crs(), "ESRI Shapefile", onlySelected=False)
                    #QgsProject.instance().removeMapLayer(lyr9)
                    lyr8=QgsVectorLayer(archivo,"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par),"ogr")
                    #etiqueto
                    """layer_settings  = QgsPalLayerSettings()
                    text_format = QgsTextFormat()
                    text_format.setFont(QFont("Arial", 12))
                    text_format.setSize(12)
                    text_format.setColor(QColor("Red"))
                    layer_settings.setFormat(text_format)
                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''
                    layer_settings.isExpression = True"""
                    #layer_settings.enabled = True
                    #layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    lyr8.setLabelsEnabled(True)
                    lyr8.setLabeling(layer_settings)
                    lyr8.triggerRepaint()
                    lyr8.setRenderer(renderer)
                    QgsProject.instance().addMapLayer(lyr8)
                    #QgsProject.instance().removeMapLayer(lyr9.id())
                    #canvas.freeze(False)
                    lyr8.updateExtents()
                    lyr8.commitChanges()
                    lyr8.updateExtents()
                    canvas.setExtent(lyr8.extent())

                if elementos>1 and recintosselecionados==False and archivo is not "":

                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''
                    #hacer un dissolve y llamar a la capa de salida igual

                    lyr8=processing.run("native:dissolve",{ 'FIELD' : [], 'INPUT' : lyr9, 'OUTPUT' : "memory:"+"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par)  })['OUTPUT']
                    lyr9=processing.run("qgis:deletecolumn",{ 'COLUMN' : ['L_PERIMETR','L_SUP_SIGP','DN_PK','DN_OID','DN_VERSION','DN_VERSI_1','C_RECINTO','C_USO_SIGP','C_COEF_REG','M_PENDIENT','CAP_AUTO','FACTOR_SUE','FACTOR_PEN','FACTOR_VEG','CAP_MANUAL','FECHA_CAMP','REGION','GRUPO_CULT','PORC_INT_C','PORC_INT_P','CAP_RESULT','INCIDENCIA','PARCELA_AG','C_REFREC','PROVMUN','TIPO','SPLIT','Shape_Leng','Shape_Area'], 'INPUT' : lyr8, 'OUTPUT' : "memory:"+"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par)  })['OUTPUT']

                    #calculo la superficie de la parcela, otra opcion seria sumar la superficie de los recintos
                    lyr9.startEditing()

                    fields = lyr9.fields()
                    idx = fields.indexFromName('SUP_SIGPAC')

                    if idx == -1:
                        myField = QgsField( 'SUP_SIGPAC', QVariant.Double )
                        lyr9.dataProvider().addAttributes([myField])
                        lyr9.updateFields()


                    for f in lyr9.getFeatures():
                        f.setAttribute(f.fieldNameIndex('SUP_SIGPAC'), f.geometry().area()/10000 )
                        #f[idx] = '"$area"*1000'
                        lyr9.updateFeature( f )

                    lyr9.commitChanges()

                    layer_settings.isExpression = True
                    layer_settings.enabled = True
                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    #lyr9=QgsVectorLayer(archivo2,"Sigpac_"+str(mun)+"_"+str(pol)+"_"+str(par),"ogr")
                    #lyr9.setLabelsEnabled(True)
                    #lyr9.setLabeling(layer_settings)
                    #lyr9.triggerRepaint()
                    #lyr9.setRenderer(renderer)

                    QgsVectorFileWriter.writeAsVectorFormat(lyr9, archivo, "CP120", lyr9.crs(), "ESRI Shapefile", onlySelected=False)
                    #QgsProject.instance().removeMapLayer(lyr9)
                    lyr8=QgsVectorLayer(archivo,"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par),"ogr")
                    #etiqueto
                    """layer_settings  = QgsPalLayerSettings()
                    text_format = QgsTextFormat()
                    text_format.setFont(QFont("Arial", 12))
                    text_format.setSize(12)
                    text_format.setColor(QColor("Red"))
                    layer_settings.setFormat(text_format)
                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''
                    layer_settings.isExpression = True"""
                    #layer_settings.enabled = True
                    #layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    lyr8.setLabelsEnabled(True)
                    lyr8.setLabeling(layer_settings)
                    lyr8.triggerRepaint()
                    lyr8.setRenderer(renderer)
                    QgsProject.instance().addMapLayer(lyr8)
                    #QgsProject.instance().removeMapLayer(lyr9.id())
                    #canvas.freeze(False)
                    lyr8.updateExtents()
                    lyr8.commitChanges()
                    lyr8.updateExtents()
                    canvas.setExtent(lyr8.extent())
                if elementos==1 and archivo is not "":

                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''
                    layer_settings.isExpression = True
                    layer_settings.enabled = True
                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    #lyr9.setLabelsEnabled(True)
                    #lyr9.setLabeling(layer_settings)
                    #lyr9.triggerRepaint()
                    #lyr9.setRenderer(renderer)

                    QgsVectorFileWriter.writeAsVectorFormat(lyr9, archivo, "CP120", lyr9.crs(), "ESRI Shapefile", onlySelected=False)
                    #QgsProject.instance().removeMapLayer(lyr9)
                    lyr8=QgsVectorLayer(archivo,"Sigpac"+str(ano)+"_"+str(mun)+"_"+str(pol)+"_"+str(par),"ogr")
                    #etiqueto
                    """layer_settings  = QgsPalLayerSettings()
                    text_format = QgsTextFormat()
                    text_format.setFont(QFont("Arial", 12))
                    text_format.setSize(12)
                    text_format.setColor(QColor("Red"))
                    layer_settings.setFormat(text_format)
                    layer_settings.fieldName = '''concat('Pol ',"C_POLIGONO",' Par ',"C_PARCELA")'''
                    layer_settings.isExpression = True"""
                    #layer_settings.enabled = True
                    #layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    lyr8.setLabelsEnabled(True)
                    lyr8.setLabeling(layer_settings)
                    lyr8.triggerRepaint()
                    lyr8.setRenderer(renderer)
                    QgsProject.instance().addMapLayer(lyr8)
                    #QgsProject.instance().removeMapLayer(lyr9.id())
                    #canvas.freeze(False)
                    lyr8.updateExtents()
                    lyr8.commitChanges()
                    lyr8.updateExtents()
                    canvas.setExtent(lyr8.extent())




                canvas.freeze(False)
                """try:
                    QgsVectorFileWriter.deleteShapeFile(archivo3)
                except:
                    pass
                try:
                    QgsVectorFileWriter.deleteShapeFile(archivo3)
                except:
                    pass"""


                pass
