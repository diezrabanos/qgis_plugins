# -*- coding: utf-8 -*-
"""
/***************************************************************************
 solicitudes_sigmena
                                 A QGIS plugin
 esto es lo que hace solicitudes_sigmena
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-29
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Javier Diez Rabanos
        email                : dierabfr@jcyl.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
#from PyQt5.QtGui import QIcon
#from PyQt5.QtWidgets import QAction

from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication#,QFileInfo
from qgis.PyQt.QtGui import QIcon, QColor,QFont
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QInputDialog
from PyQt5.QtWidgets import QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .solicitudes_sigmena_dialog import Solicitudes_sigmenaDialog
from .config_dialog import ConfigDialog
from .xy_dialog import XYDialog
import os.path

#import para procesar
import qgis.core as qgisCore
from qgis.core import QgsProject, QgsVectorLayer,QgsField,QgsExpression,QgsExpressionContext,QgsExpressionContextScope,QgsVectorFileWriter, QgsMarkerSymbol,QgsRendererCategory,QgsCategorizedSymbolRenderer,QgsPointXY, QgsPoint,QgsFeature,QgsGeometry,QgsLineSymbol,QgsExpressionContextUtils,QgsPalLayerSettings,QgsTextFormat,QgsVectorLayerSimpleLabeling,QgsExpressionContextUtils,QgsApplication, QgsTextBufferSettings
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
#from PyQt5.QtWidgets import QMessageBox
#from PyQt5.QtCore import QFileInfo
#from qgis.PyQt.QtCore import QFileInfo

import processing
import os
import glob
import re
import sys
#from qgis import *

import math
import time

import webbrowser

import tempfile

import pyproj

class Config:
    def __init__(self, iface):
        self.dlg2 = ConfigDialog()

class XY:
    def __init__(self, iface):
        self.dlg3 = XYDialog()
        

class Solicitudes_sigmena:
    """QGIS Plugin Implementation."""
    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Solicitudes_sigmena_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        self.dlg = Solicitudes_sigmenaDialog()
        self.dlg2 = ConfigDialog()
        self.dlg3 = XYDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sigmena')
        
        #self.toolbar = self.iface.addToolBar(u'Sigmena')             #creo que no hace nada
        #self.toolbar.setObjectName(u'Sigmena')            #creo que no hace nada
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        #abre la nueva ventana de configuracion
        self.dlg.pushButton_configurar.clicked.connect(self.configurar)
        self.dlg.pushButton_ruta_capa_zona.clicked.connect(self.select_file2)
        self.dlg2.pushButton_select_path1.clicked.connect(self.select_file1)
        self.dlg.help_button.clicked.connect(self.help_pressed)
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Solicitudes Sigmena', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """


        
        #cambio el icon path para mi equipo.
        usuario=QgsApplication.qgisSettingsDirPath()
        icon_path=os.path.join(usuario,r"python\plugins\solicitudes_sigmena\icon.png")
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)
            #self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/solicitudes_sigmena/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Solicitudes Sigmena'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        
        #cojo los parametros necesarios del archivo de configuracion
        global rutapuestosvigiancia
        rutaarchivoconfiguracion=os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\solicitudes_sigmena\configuracion.txt")
        if os.path.isfile(rutaarchivoconfiguracion) ==True:
            fileconfig = open(rutaarchivoconfiguracion, "r")
            fileconfigleido=fileconfig.readlines()
            try:
                rutapuestosvigiancia= (fileconfigleido[0].replace('\n',''))
                fileconfig.close()
            except:
                rutapuestosvigiancia=""
                
        if os.path.isfile(rutaarchivoconfiguracion) ==False:
            fileconfig = open(rutaarchivoconfiguracion, "w")
            fileconfig.close()
            rutapuestosvigiancia=""
            
    def select_file1(self):

        """seleciono la capa con los datos de entrada terminos municipales del sigpac"""
        global rutapuestosvigiancia
        rutaarchivoconfiguracion=os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\solicitudes_sigmena\configuracion.txt")
        rutapuestosvigiancia = QFileDialog.getOpenFileName(self.dlg2 , "Capa con los puestos de vigilancia",None ,'SHP(*.shp)')
        self.dlg2.ruta1.setText(rutapuestosvigiancia[0])
        archivo=rutapuestosvigiancia[0]
        #inserto en linea 0 el contenido
        if len(rutapuestosvigiancia[0])>0:
            contenido=open(rutaarchivoconfiguracion).read().splitlines()
            contenido.insert(0,rutapuestosvigiancia[0])
            fileconfig = open(rutaarchivoconfiguracion, "w")

        
            fileconfig.writelines("\n".join(contenido))
            fileconfig.close()
            iface.messageBar().pushMessage("CERRAR Y ABRIR QGIS PARA QUE SE APLIQUEN LOS CAMBIOS", qgisCore.Qgis.Warning,5)




    def select_file2(self):

        """seleciono la capa con la zona de interes para recortar o seleccionar el resto de capas predefinidas"""
        global ruta_capa_zona
        
        ruta_capa_zona = QFileDialog.getOpenFileName(self.dlg , "Capa con la zona de interes",None ,'SHP(*.shp)')
        self.dlg.ruta_capa_zona.setText(ruta_capa_zona[0])
        print(ruta_capa_zona)
        
    
   
    def configurar(self):
        contras = QInputDialog.getText(None, 'CONTRASEÑA', 'Introduce la contraseña')
        print (contras)
        if contras[0]=='SIGMENITA':
            self.dlg2.show()
        else:
            iface.messageBar().pushMessage("PARA CONFIGURAR INRODUCIR CONTRASEÑA", qgisCore.Qgis.Warning,5)    

    def help_pressed(self):
        help_file = 'file:' + os.path.dirname(__file__) + '/Ayuda_solicitudes_sigmena.pdf'
        webbrowser.open_new(help_file)  


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removeToolBarIcon(action)
            self.iface.removePluginMenu(
                self.tr(u'&Sigmena'),
                action)




    #empiezo el cruce de capas vectoriales con la zona de interes, hace una seleccion de los elementos, no un clip. si es de poligonos la selecciona y si es de puntos la convierte en poligonos de 1x1 y la seleciona los presentes y los guarda.
    def crucecapasvectoriales(self,capadetrabajo,elementofijo,carpetasalida):
        #print("entro en crucecapasvectoriales")
        
        global resultadocapas
        
        #global carpetasalida

        
        #carpetasalida= '/'.join(capadetrabajo.split("/")[:-1])+"/capas_intermedias"
        #sufijo=str(elementofijo.split("/")[-1])
        sufijo=elementofijo[1]
        salida=carpetasalida+"/"+sufijo
        #print(capadetrabajo,elementofijo)
        #habra que hacer que carge la capa de mups.
        #print("salida",salida)
        
        layer = QgsVectorLayer(elementofijo[0], sufijo, "ogr")#no es necesario con el saveselectedfeatures

        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':capadetrabajo,'METHOD':0})
        #processing.run("native:saveselectedfeatures", {'INPUT':elementofijo,'OUTPUT':salida})#es lo mas facil pero cambia la codifiacion
        #guardo los selecionados con la codifiacion indicada
        selection = layer.selectedFeatures()
        
        feats = [feat for feat in layer.selectedFeatures()]
        elementos=len(feats)
        
        if len(feats)>0:
            #hay que comprobar de que tipo es la capa si lineas o poligonos
            #print("tipo ",layer.wkbType())
            if layer.wkbType()==3 or layer.wkbType()==6 or layer.wkbType()==1006:
                #print("es poligono")
                mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", sufijo, "memory")
            if layer.wkbType()==2 or layer.wkbType()==5:
                #print("es linea")
                mem_layer = QgsVectorLayer("LineString?crs=epsg:25830", sufijo, "memory")
            if layer.wkbType()==1 or layer.wkbType()==4:
                #print("es punto")
                mem_layer = QgsVectorLayer("Point?crs=epsg:25830", "sufijo", "memory")

            mem_layer_data = mem_layer.dataProvider()
            attr = layer.dataProvider().fields().toList()
            mem_layer_data.addAttributes(attr)
            mem_layer.updateFields()
            mem_layer_data.addFeatures(feats)
            if layer.wkbType()==1 or layer.wkbType()==4:#capa de puntos
                #aqui tengo que incluir la cuadricula de 1x1 contando si existen elementos y borrar si son cero.
                capa=processing.run('qgis:countpointsinpolygon', { 'CLASSFIELD' : None, 'FIELD' : 'presenci', 'OUTPUT' :'TEMPORARY_OUTPUT', 'POINTS' : mem_layer , 'POLYGONS' : 'O:/sigmena/carto/CUADRICU/UTM/UTM1KM/42_malla1x1.shp', 'WEIGHT' : None })['OUTPUT']

                mem_layer=capa
                #despues deberia borrar los features que tienen un 0
                feats = mem_layer.getFeatures()
                dfeats = []


                for feat in feats:
                    if feat['presenci'] == 0:
                        dfeats.append(feat.id())
                res = mem_layer.dataProvider().deleteFeatures(dfeats)
                #men_layer.triggerRepaint()
                #despues deberia borrar la capa si no tiene elementos
                pass
            else:#capa de poligonos
                pass
            #en cualquier caso
            
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer,salida,"utf-8",driverName="ESRI Shapefile")
            QgsProject.instance().addMapLayer(mem_layer)
            
            #hasta aqui para guardar lo selecionado

            

            

            print(sufijo)
            #deberia hacer algo para saber que de una capa el resultado ha sido positivo o negativo. UNa lista al estilo de resultadocambiodecultivo. Estudiarlo OJO

    #empiezo el cruce de capas vectoriales con la zona de interes, hace una seleccion de los elementos, no un clip. solo trabajo con las de puntos y no las convierte en poligonos ni nada.Lo aplico a las de electrocuciones por ejemplo
    def crucecapasvectoriales2(self,capadetrabajo,elementofijo,carpetasalida):
        #print("entro en crucecapasvectoriales")
        
        global resultadocapas
        
        #global carpetasalida

        
        #carpetasalida= '/'.join(capadetrabajo.split("/")[:-1])+"/capas_intermedias"
        #sufijo=str(elementofijo.split("/")[-1])
        sufijo=elementofijo[1]
        salida=carpetasalida+"/"+sufijo
        #print(capadetrabajo,elementofijo)
        #habra que hacer que carge la capa de mups.
        #print("salida",salida)
        
        layer = QgsVectorLayer(elementofijo[0], sufijo, "ogr")#no es necesario con el saveselectedfeatures

        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':capadetrabajo,'METHOD':0})
        #processing.run("native:saveselectedfeatures", {'INPUT':elementofijo,'OUTPUT':salida})#es lo mas facil pero cambia la codifiacion
        #guardo los selecionados con la codifiacion indicada
        selection = layer.selectedFeatures()
        
        feats = [feat for feat in layer.selectedFeatures()]
        elementos=len(feats)
        
        if len(feats)>0:
            #hay que comprobar de que tipo es la capa si lineas o poligonos
            #print("tipo ",layer.wkbType())
            if layer.wkbType()==3 or layer.wkbType()==6 or layer.wkbType()==1006:
                #print("es poligono")
                mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", sufijo, "memory")
            if layer.wkbType()==2 or layer.wkbType()==5:
                #print("es linea")
                mem_layer = QgsVectorLayer("LineString?crs=epsg:25830", sufijo, "memory")
            if layer.wkbType()==1 or layer.wkbType()==4:
                #print("es punto")
                mem_layer = QgsVectorLayer("Point?crs=epsg:25830", "sufijo", "memory")

            mem_layer_data = mem_layer.dataProvider()
            attr = layer.dataProvider().fields().toList()
            
            mem_layer_data.addAttributes(attr)
            mem_layer.updateFields()
            mem_layer_data.addFeatures(feats)

            #en cualquier caso
            
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer,salida,"utf-8",driverName="ESRI Shapefile")
            QgsProject.instance().addMapLayer(mem_layer)
            
            #hasta aqui para guardar lo selecionado

            

            

            print(sufijo)
            #deberia hacer algo para saber que de una capa el resultado ha sido positivo o negativo. UNa lista al estilo de resultadocambiodecultivo. Estudiarlo OJO

    def crucecapasvectoriales3(self,capadetrabajo,elementofijo,carpetasalida):#capa de puntos a poligonos con la inforamcion de cada punto en el poligono en el que cae
        #print("entro en crucecapasvectoriales")
        
        global resultadocapas
        
        #global carpetasalida

        
        #carpetasalida= '/'.join(capadetrabajo.split("/")[:-1])+"/capas_intermedias"
        #sufijo=str(elementofijo.split("/")[-1])
        sufijo=elementofijo[1]
        salida=carpetasalida+"/"+sufijo
        #print(capadetrabajo,elementofijo)
        #habra que hacer que carge la capa de mups.
        #print("salida",salida)
        
        layer = QgsVectorLayer(elementofijo[0], sufijo, "ogr")#esta es la capa de entrada, de puntos en este caso

        processing.run("native:selectbylocation", {'INPUT':layer,'PREDICATE':[0],'INTERSECT':capadetrabajo,'METHOD':0})
        #processing.run("native:saveselectedfeatures", {'INPUT':elementofijo,'OUTPUT':salida})#es lo mas facil pero cambia la codifiacion
        #guardo los selecionados con la codifiacion indicada
        selection = layer.selectedFeatures()
        
        feats = [feat for feat in layer.selectedFeatures()]
        elementos=len(feats)
        cuadricula=QgsVectorLayer(r'O:/sigmena/carto/CUADRICU/UTM/UTM1KM/42_malla1x1.shp',"test","ogr")
        if len(feats)>0:
            #hay que comprobar de que tipo es la capa si lineas o poligonos
            #print("tipo ",layer.wkbType())
            
            #print("es poligono") creo una capa de poligonos donde ir metiendo los atributos de la capa de puntos
            mem_layer = QgsVectorLayer("Polygon?crs=epsg:25830", sufijo, "memory")
            
                        
            temp_data = mem_layer.dataProvider()
            pr = layer.dataProvider()
            attr = layer.dataProvider().fields().toList()

            temp_data.addAttributes(attr)
            mem_layer.updateFields()

            for f in feats:
                print(f.id())#id de la capa de puntos
                for a in cuadricula.getFeatures():
                    if a.geometry().intersects(f.geometry()): 
                        poly = QgsFeature()
                        #print(a.geometry().asWkt())
                        #print("toca")
                        #print(a.id())
                        poly.setGeometry(QgsGeometry.fromWkt(a.geometry().asWkt()))
                        #feat.setGeometry(a.geometry())#fromWkt("POINT(7 45)")
                        #layer.updateExtents()
                        
                        # get the feature's attributes
                        attrs = f.attributes()
                        #print(attrs)
                        poly.setAttributes(attrs)
                        temp_data.addFeatures([poly])
                    else:
                        #print("notoca")
                        pass
            #temp_data.addFeatures(feats)
            #voy a borrar las columnas que no me interesan por indice
            lista=[]
            for columna in elementofijo[2]:
                indice= mem_layer.fields().indexFromName(columna)
                lista.append(indice)
                
                
            res = mem_layer.dataProvider().deleteAttributes(lista)
            mem_layer.updateFields()

            #en cualquier caso
            
            QgsVectorFileWriter.writeAsVectorFormat(mem_layer,salida,"utf-8",driverName="ESRI Shapefile")
            QgsProject.instance().addMapLayer(mem_layer)
            
            #hasta aqui para guardar lo selecionado

            

            

            print(sufijo)
            #deberia hacer algo para saber que de una capa el resultado ha sido positivo o negativo. UNa lista al estilo de resultadocambiodecultivo. Estudiarlo OJO



                    
 
                    

    def run(self):
        print ("paso por el run")
       
        #coloco el puntero arriba del todo
        QgsProject.instance().layerTreeRegistryBridge().setLayerInsertionPoint( QgsProject.instance().layerTreeRoot(), 0 )
        
        #listado de capas con las que trabajar, a cortar
        #CAPAS DE ESPACIOS EMAIL LOLI 20211129, las he pasado a un txt en la misma carpeta. Habria que hacer que se pudiese selecionar desde la configuracion.
        #estas capas, de esta lista o del txt si son de poligonos se seleccionan y si son de puntos se convierten en cuadriculas de 1x1 y se filtran las que si tienen. 
        """alondra_de_dupont_ofical_area_relevancia=[r"O:/sigmena/carto/ESPECIES/ESTUDIOS/CENSOS/ALONDRA RICOTI/42_AREAS_RELEVANCIA_ALONDRA_RICOTI_etrs89.shp","alondra_de_dupont_ofical_area_relevancia"]
        alondra_de_dupont_nudo_medinaceli=[r"O:/sigmena/carto/ESPECIES/ESTUDIOS/CENSOS/ALONDRA RICOTI/Habitat_Medinaceli_2019.shp","alondra_de_dupont_nudo_medinaceli"]
        alondra_de_dupont_censo_provincial_2020=[r"O:/sigmena/carto/ESPECIES/ESTUDIOS/CENSOS/ALONDRA RICOTI/habitat_ricoti_SO_BU_2020_informe.shp","alondra_de_dupont_censo_provincial_2020"]
        alondra_de_dupont_censo_oficial_5x5_2008_2020=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Chersophilus_duponti/HISTORICO/1_PLANIFICACIÓN/ES41_CYL/ES41_HISTORICO_AOCPLA_5x5_Cduponti.shp","alondra_de_dupont_censo_oficial_5x5_2008_2020"]
        avutarda_oficial_cuadricula_5x5_2003_2020=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Otis_tarda/HISTORICO/1_PLANIFICACION/ES41_CYL/ES41_HISTORICO_AOCPLA_5x5_Otarda.shp","avutarda_oficial_cuadricula_5x5_2003_2020"]
        sison_oficial_historico_5x5_1999_2020=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Tetrax_tetrax/HISTORICO/1_PLANIFICACION/ES41_CYL/ES41_HISTORICO_AOCPLA_5x5_Ttetrax.shp","sison_oficial_historico_5x5_1999_2020"]
        ortega_oficial_historico_cuadriculas_5x5_1999_2020_=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Palchata_Porientalis/HISTORICO/1_PLANIFICACION/ES41_CYL/ES41_HISTORICO_AOCPLA_5x5_Palchata.shp","ortega_oficial_historico_cuadriculas_5x5_1999_2020_"]
        ortega_oficial_historico_cuadriculas_5x5_1999_2020=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Palchata_Porientalis/HISTORICO/1_PLANIFICACION/ES41_CYL/ES41_HISTORICO_AOCPLA_5x5_Porientalis.shp","ortega_oficial_historico_cuadriculas_5x5_1999_2020"]
        aguiluchos_censo=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/aguiluchos/2021/Resultados_censoAguiluchos_transectos_2021.shp","aguiluchos_censo"]
        aguila_perdicera_potencial=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguila perdicera/areas potenciales.shp","aguila_perdicera_potencial"]
        aguila_perdicera_ultimos_territorios=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguila perdicera/ultimos territorios.shp","aguila_perdicera_ultimos_territorios"]
        aguila_real_historico=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguila real/Aguila_real_historico.shp","aguila_real_historico"]
        aguila_real_1x1_2018=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguila real/Aguila_real_1x1_2018.shp","aguila_real_1x1_2018"]
        aguilucho_cenizo_cuadriculas_censo_2017=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguilucho cenizo/Cuadrículas_censo_Aguilucho_2017.shp","aguilucho_cenizo_cuadriculas_censo_2017"]
        aguilucho_cenizo_censo_zepas_2017=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguilucho cenizo/Zepas_censo_2017_Aguiluchos.shp","aguilucho_cenizo_censo_zepas_2017"]
        aguilucho_cenizo_parcelas=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguilucho cenizo/parcelas nidos cenizos.shp","aguilucho_cenizo_parcelas"]
        aguilucho_cenizo_cuadriculas_censo_parejas_rep_2017=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguilucho cenizo/Cuadriculas_censo_parejas_rep_2017.shp","aguilucho_cenizo_cuadriculas_censo_parejas_rep_2017"]
        aguilucho_lagunero_2011=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Aguilucho lagunero/Aguilucho_lagunero_2011.shp","aguilucho_lagunero_2011"]
        alimoche_1x1_2018=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Alimoche/Alimoche_1x1_2018.shp","alimoche_1x1_2018"]
        buitre_leonado_1x1_2018=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Buitre leonado/Buitre_leonado_1x1_2018.shp","buitre_leonado_1x1_2018"]
        buitre_leonado_tpores_colonias_2018=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Gyps_fulvus/2018/2_RESULTADOS/42_SO/42_2018_TPORES_COLONIAS_Gfulvus.shp","buitre_leonado_tpores_colonias_2018"]
        milano_real_historico_aocres_1x1_inv=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/42_HISTORICO_AOCRES_1X1_Mmilvus_INV.shp","milano_real_historico_aocres_1x1_inv"]
        milano_real_10x10=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2008-2010 varios/Milano_Real_UTM10.shp","milano_real_10x10"]
        milano_real_tpores_dormideros=[r"o:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2019/2_RESULTADOS/42_SO/42_2019_TPORES_DORMIDEROS_Mmilvus.shp","milano_real_tpores_dormideros"]
        milano_real_2018_tpores_dormideros_inv=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2018/2_RESULTADOS/42_SO/42_2018_TPORES_DORMIDEROS_Mmilvus_INV.shp","milano_real_2018_tpores_dormideros_inv"]
        milano_real_2018_tpores_territorios_rep=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_REPRO/2018/2_RESULTADOS/42_SO/42_2018_TPORES_TERRITORIOS_Mmilvus_REP.shp","milano_real_2018_tpores_territorios_rep"]
        milano_real_nidos=[r"O:/sigmena/usuarios/espacios_naturales/Proyectos Loli/capas/milano real/nidos_milano.shp","milano_real_nidos"]
        milano_real_nidos_2013_17_tierras_altas=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2013-2017 Nidos Milano/Nidos_Milano_real_2013-17_Tierras_Altas.shp","milano_real_nidos_2013_17_tierras_altas"]
        milano_real_2018=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2018/milano real 2018.shp","milano_real_2018"]
        milano_real_reproductor_2018=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2018/milano real reproductor 2018.shp","milano_real_reproductor_2018"]
        milano_real_monta_10=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2018/utm milano monta 10.shp","milano_real_monta_10"]
        milano_real_inv_2019=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2019/MILANO REAL INV 2019.shp","milano_real_inv_2019"]
        milano_real_rep_2019=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2019/milano real rep 2019.shp","milano_real_rep_2019"]
        milano_real_reproductor_2020=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2020/milano real 2020 reproductor.shp","milano_real_reproductor_2020"]
        milano_real_rep_2019_2020=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2020/Milano_real_repr_2019_2020.shp","milano_real_rep_2019_2020"]
        milano_real_campeo_2019_2020=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Milano real/2020/Milano_real_campeo_2019_2020.shp","milano_real_campeo_2019_2020"]
        halcon_peregrino_1x1_2018=[r"O:/sigmena/usuarios/espacios_naturales/ESPECIES PROTEGIDAS/Aves Rapaces/Halcon peregrino/Halcon_peregrino_1x1_2018.shp","halcon_peregrino_1x1_2018"]
        
        c2018_AOCRES_1X1_Achrysaetos=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Aquila_chrysaetos/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_1X1_Achrysaetos.shp","c2018_AOCRES_1X1_Achrysaetos"]
        c2018_AOCRES_10X10_Achrysaetos=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Aquila_chrysaetos/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_10X10_Achrysaetos.shp","c2018_AOCRES_10X10_Achrysaetos"]
        c2018_AOCRES_1x1_Gfulvus=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Gyps_fulvus/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_1x1_Gfulvus.shp","c2018_AOCRES_1x1_Gfulvus"]
        c2018_AOCRES_10x10_Gfulvus=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Gyps_fulvus/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_10x10_Gfulvus.shp","c2018_AOCRES_10x10_Gfulvus"]
        c2018_AOCRES_1x1_Mmilvus_REP=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_REPRO/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_1x1_Mmilvus_REP.shp","c2018_AOCRES_1x1_Mmilvus_REP"]
        c2018_AOCRES_10x10_Mmilvus_REP=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_REPRO/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_10x10_Mmilvus_REP.shp","c2018_AOCRES_10x10_Mmilvus_REP"]
        c2018_AOCRES_1X1_Npercnopterus=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Neophron_percnopterus/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_1X1_Npercnopterus.shp","c2018_AOCRES_1X1_Npercnopterus"]
        c2018_AOCRES_10X10_Npercnopterus=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Neophron_percnopterus/2018/2_RESULTADOS/ES41_CYL/ES41_2018_AOCRES_10X10_Npercnopterus.shp","c2018_AOCRES_10X10_Npercnopterus"]
        c2019_AOCRES_10x10_Mmilvus_INV=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2019/2_RESULTADOS/ES41_CYL/41_2019_AOCRES_10x10_Mmilvus_INV.shp","c2019_AOCRES_10x10_Mmilvus_INV"]
        c2019_AOCRES_1x1_Mmilvus_INV=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2019/2_RESULTADOS/ES41_CYL/41_2019_AOCRES_1x1_Mmilvus_INV.shp","c2019_AOCRES_1x1_Mmilvus_INV"]
        c2019_AOCRES_1X1_Palchata_Porientalis=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Palchata_Porientalis/2019/2_RESULTADOS/ES41_CYL/ES41_2019_AOCRES_1X1_Palchata_Porientalis.shp","c2019_AOCRES_1X1_Palchata_Porientalis"]
        c2019_AOCRES_10X10_Palchata_Porientalis=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Palchata_Porientalis/2019/2_RESULTADOS/ES41_CYL/ES41_2019_AOCRES_10X10_Palchata_Porientalis.shp","c2019_AOCRES_10X10_Palchata_Porientalis"]
        c2019_AOCRES_1X1_Porientalis=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Palchata_Porientalis/2019/2_RESULTADOS/ES41_CYL/ES41_2019_AOCRES_1X1_Porientalis.shp","c2019_AOCRES_1X1_Porientalis"]
        c2019_AOCRES_10X10_Porientalis=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ESTEP/Palchata_Porientalis/2019/2_RESULTADOS/ES41_CYL/ES41_2019_AOCRES_10X10_Porientalis.shp","c2019_AOCRES_10X10_Porientalis"]
        c2019_AOCRES_10x10_Mmilvus_INV=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2019/2_RESULTADOS/ES41_CYL/ES41_2019_AOCRES_10x10_Mmilvus_INV.shp","c2019_AOCRES_10x10_Mmilvus_INV"]
        c2019_AOCRES_1x1_Mmilvus_INV=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2019/2_RESULTADOS/ES41_CYL/ES41_2019_AOCRES_1x1_Mmilvus_INV.shp","c2019_AOCRES_1x1_Mmilvus_INV"]
        c2019_AOCRES_10X10_AVEAC_INV=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ACUAT/ACUAT_INVER/2019/2_RESULTADOS/ES41_CYL/ES41_2019_AOCRES_10X10_AVEAC_INV.shp","c2019_AOCRES_10X10_AVEAC_INV"]
        c2019_HUMEDALES_AVEAC=[r"O:/sigmena/carto/ESPECIES/PLAN_SEGUIM/PMONIT_FAU/AVES/AVES_ACUAT/ACUAT_INVER/2019/2_RESULTADOS/ES41_CYL/ES41_2019_HUMEDALES_AVEAC.shp","c2019_HUMEDALES_AVEAC"]
        
        c2019_TPORES_ESTES_Ttetrax=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_ESTEP/Tetrax_tetrax/2019/2_RESULTADOS/42_SO/42_2019_TPORES_ESTES_Ttetrax.shp","c2019_TPORES_ESTES_Ttetrax"]
        c2019_TPORES_EJEMPLARES_Palchata_Porientalis=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_ESTEP/Palchata_Porientalis/2019/2_RESULTADOS/42_SO/42_2019_TPORES_EJEMPLARES_Palchata_Porientalis.shp","c2019_TPORES_EJEMPLARES_Palchata_Porientalis"]
        c2019_TPORES_EJEMPLARES_AVEAC_INV=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_ACUAT/ACUAT_INVER/2019/2_RESULTADOS/42_SO/42_2019_TPORES_EJEMPLARES_AVEAC_INV.shp","c2019_TPORES_EJEMPLARES_AVEAC_INV"]
        c2019_TPORES_DORMIDEROS_Mmilvus=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2019/2_RESULTADOS/42_SO/42_2019_TPORES_DORMIDEROS_Mmilvus.shp","c2019_TPORES_DORMIDEROS_Mmilvus"]
        c2018_TPORES_DORMIDEROS_Mmilvus_INV=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_INVER/2018/2_RESULTADOS/42_SO/42_2018_TPORES_DORMIDEROS_Mmilvus_INV.shp","c2018_TPORES_DORMIDEROS_Mmilvus_INV"]
        c2018_TPORES_TERRITORIOS_Npercnopterus=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Neophron_percnopterus/2018/2_RESULTADOS/42_SO/42_2018_TPORES_TERRITORIOS_Npercnopterus.shp","c2018_TPORES_TERRITORIOS_Npercnopterus"]
        c2018_TPORES_COLONIAS_Gfulvus=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Gyps_fulvus/2018/2_RESULTADOS/42_SO/42_2018_TPORES_COLONIAS_Gfulvus.shp","c2018_TPORES_COLONIAS_Gfulvus"]
        c2018_TPORES_TERRITORIOS_Mmilvus_REP=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_FORES_AMEN/Milvus_milvus_REPRO/2018/2_RESULTADOS/42_SO/42_2018_TPORES_TERRITORIOS_Mmilvus_REP.shp","c2018_TPORES_TERRITORIOS_Mmilvus_REP"]
        c2018_TPORES_TERRITORIOS_Achrysaetos=[r"O:/sigmena/tablas/espacios_naturales/PMONIT_FAU/AVES/AVES_RAPAC_RUPI/Aquila_chrysaetos/2018/2_RESULTADOS/42_SO/42_2018_TPORES_TERRITORIOS_Achrysaetos.shp","c2018_TPORES_TERRITORIOS_Achrysaetos"]
        """

        
        #defino capas generales
                
        mup=r'O:/sigmena/carto/PROPIEDA/MONTES/PERTENEN/Mup_etrs89.shp'#QgsVectorLayer(r'O:/sigmena/carto/PROPIEDA/MONTES/PERTENEN/Mup_etrs89.shp' ,"M.U.P.","ogr")     #OJO ESTA CAPA NO ESTA BIEN, NO ES LA BUENA AUN!!!!
        consorcio="O:/sigmena/carto/PROPIEDA/MONTES/CONTRATO/Consorcios_etrs89.shp"#QgsVectorLayer(r"O:/sigmena/carto/PROPIEDA/MONTES/CONTRATO/Consorcios_etrs89.shp","Consorcios","ogr")
        vvpp=r"O:/sigmena/carto/VVPP/REDVVPP/42_vvpp_etrs89.shp"#QgsVectorLayer(r"O:/sigmena/carto/VVPP/REDVVPP/42_vvpp_etrs89.shp","VVPP","ogr")
        ren="O:/sigmena/carto/ESPACIOS/REN/42_ren_ex_etrs89.shp"#QgsVectorLayer(r"O:\sigmena\carto\ESPACIOS\REN\42_ren_ex_etrs89.shp","R.E.N","ogr")
        zec=r"O:/sigmena/carto/ESPACIOS/NATU2000/ZEC/42_ZEC.shp"#QgsVectorLayer(r"O:\sigmena\carto\ESPACIOS\NATU2000\ZEC\42_ZEC.shp","Z.E.C","ogr")
        zepa=r"O:/sigmena/carto/ESPACIOS/NATU2000/ZEPA/42_ZEPA.shp"#QgsVectorLayer(r"O:\sigmena\carto\ESPACIOS\NATU2000\ZEPA\42_ZEPA.shp","Z.E.P.A","ogr")
        alondra=r"O:/sigmena/carto/ESPECIES/ESTUDIOS/CENSOS/ALONDRA RICOTI/42_AREAS_RELEVANCIA_ALONDRA_RICOTI_etrs89.shp"#QgsVectorLayer(r"O:\sigmena\carto\ESPECIES\ESTUDIOS\CENSOS\ALONDRA RICOTI\42_AREAS_RELEVANCIA_ALONDRA_RICOTI_etrs89.shp","Z. Alondra","ogr")
        yacimientos=r"O:/sigmena/carto/OTROS/BIENPATCULT/42_VW_BIENES.shp"#QgsVectorLayer(r"O:\sigmena\carto\OTROS\BIENPATCULT\42_VW_BIENES.shp","Yacimientos","ogr")

        #carpeta de trabajo
        carpetasalida = tempfile.mkdtemp()
        print(carpetasalida)
    
       


        
        

        




        

        # show the dialog
        self.dlg.show()
        if self.first_start == True:
            self.first_start = False
            
        
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            print("llego al result")
            print(ruta_capa_zona[0])
            lyr9 = QgsVectorLayer(ruta_capa_zona[0], 'Capa zona interes', 'ogr')
            QgsProject.instance().addMapLayers([lyr9])

            #lista vacia con el resultado de lo que afecta y de lo que no
            resultadocapas=[]

            #lo nuevo empieza aqui
            myfile=open (os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\solicitudes_sigmena\archivoconcapas.txt"))
            myline = myfile.readline()
            print(myline)
            #lista_de_capas_a_cruzar=[]
            while myline:
                #print(myline)
                #titulo=myline.split("=")[0]
                #lista_de_capas_a_cruzar.append(titulo)
                #elemento=eval(myline.split("=")[1])
                elemento=eval(myline)
                #print(elemento)
                self.crucecapasvectoriales(lyr9,elemento,carpetasalida)#tengo que ver como llamar al mup, tb layer 8 o 9
            
    
                myline = myfile.readline()#para pasar a la siguiente
            myfile.close()
            
            #lo nuevo acaba aqui


            
            electrocuciones=[r"O:/sigmena/usuarios/espacios_naturales/Proyectos Loli/capas/Electrocuciones/Electrocuciones 1993-2021 nov21.shp","Electrocuciones"]
            corredores=[r"O:/sigmena/carto/VEGETACI/OTROS/Corredores_Forestales_2_A_Crespo.shp","Corredores_Forestales_A_Crespo"]
            mortandad_milano=[r"O:/sigmena/usuarios/espacios_naturales/Proyectos Loli/capas/milano real/mortandad_milano.shp","Mortandad_milano"]
            muladares=[r"O:\sigmena\usuarios\espacios_naturales\ESPECIES PROTEGIDAS\Muladares\42_Muladares_etrs89.shp","Muladares"]
            #hago los cruces entre lyr9 que es la zona de interes y todas las demas en este caso metos lineas y puntos que no quiero convertir en poligonos.
            lista_de_capas_a_cruzar2=[electrocuciones,corredores, mortandad_milano,muladares]
            for elemento in lista_de_capas_a_cruzar2:
                self.crucecapasvectoriales2(lyr9,elemento,carpetasalida)


            #para capas de puntos con informacion relevante que hay que pasar a cuadriculas, con su informacion
            citas_BD_catalogo_de_flora=[r"R:/SIGMENA/prueba/2021/12/09/42_Citas_BD_Catalogo_de_Flora_etrs89.shp","Citas_BD_Catalogo_de_Flora",["X","Y"]]
            lista_de_capas_a_cruzar3=[citas_BD_catalogo_de_flora]
            for elemento in lista_de_capas_a_cruzar3:
                self.crucecapasvectoriales3(lyr9,elemento,carpetasalida)
            
            os.startfile(carpetasalida)

            #para la capa de citas de fauna que es de puntos y hay que convertir en cuadriculas.
            #lo más facil puede ser hacer una cuadricula por cada punto.
            #leer la capa de puntos.
    

            
