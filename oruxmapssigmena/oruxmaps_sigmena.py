# -*- coding: utf-8 -*-
"""
/***************************************************************************
Oruxmaps
                                 A QGIS plugin
 Crea cartografia para oruxmaps
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-01-03
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Javier Díez
        email                : fjavier.diez@jcyl.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.utils import iface
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QFileInfo, Qt,QRectF
from PyQt5.QtGui import QIcon,QColor,QFont
from PyQt5.QtWidgets import QAction
# The following two imports are probably a bit overkill...
from PyQt5 import QtGui, QtCore, QtWidgets
from PyQt5.QtWidgets import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog and for copying the templates to local profile folder
from .oruxmaps_sigmena_dialog import OruxmapsSigmenaDialog
import os.path
from qgis.core import QgsApplication, QgsProject,QgsPrintLayout,QgsUnitTypes,QgsLayoutSize,QgsLayoutItemMap,QgsLayoutItemLabel,QgsLayoutExporter,QgsLayoutItemScaleBar,QgsVector,QgsVectorLayer,QgsRasterLayer,QgsLayoutItemMapGrid,QgsLayoutItemLegend,QgsLayoutPoint,QgsLegendStyle,QgsWkbTypes,QgsMapLayer
from distutils.dir_util import copy_tree
from random import randrange as rand
import webbrowser
import tempfile
import time

import win32api, win32con
from win32api import GetSystemMetrics
import os
   


class OruxmapsSigmena:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OruxmapsSigmena_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = OruxmapsSigmenaDialog()
        # Set Layer Name line edit disabled at the start
        #self.dlg.txtLayoutName.setEnabled(False)
        
        # Run the function to load templates into the dialog listWidget (probably not needed, it's called later)
        # self.loadTemplates()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sigmena')

        self.dlg.pushButton_select_path.clicked.connect(self.select_file)
        
        # TODO: We are going to let the user set this up in a future iteration
        #self.toolbar = self.iface.addToolBar(u'Sigmena')
        #self.toolbar.setObjectName(u'Impresion Sigmena')
        
        # Connect signals from the dialog to functions in this file
        #self.dlg.listWidget.itemClicked.connect(self.suggestLayoutName)
        
        
        # Context menu when right click in layout list
        #self.dlg.listWidget.setContextMenuPolicy(Qt.CustomContextMenu)
        #self.dlg.listWidget.customContextMenuRequested.connect(self.listMenu)

        #self.dlg.radioButtonHorizontal.toggled.connect(self.horizontal)
        #self.dlg.radioButtonVertical.toggled.connect(self.vertical)

        #self.dlg.checkBox5.toggled.connect(self.pinchoenzona5)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OruxmapsSigmena', message)    

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        
    

        
        #cambio el icon path para mi equipo.
        usuario=QgsApplication.qgisSettingsDirPath()
        icon_path=os.path.join(usuario,r"python\plugins\oruxmapssigmena\icon.png")
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)
            #self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)
        return action
    
    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/oruxmapssigmena/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'OruxmapsSigmena'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Sigmena'),
                action)
            self.iface.removeToolBarIcon(action)


    def select_file(self): 
        """seleciono la carpeta con los datos de entrada"""
     
        
        #self.dlg.carpetalaz.clear()
        carpeta_resultado = QFileDialog.getExistingDirectory(self.dlg , "Seleccionar carpeta",None )
        print(carpeta_resultado)
        self.dlg.lineEdit_ruta.setText(carpeta_resultado)
  
        
    

   



    def run(self):
        """Run method that performs all the real work"""
        # This loads the dialog with templates (again) TODO check when it's best to do this
        #self.loadTemplates()
        sentido="h"
        #escalas=["5000","10000","15000","20000","25000","30000","50000","100000"]
        #self.dlg.escalasComboBox.clear() 
        #for element in escalas:
        #    self.dlg.escalasComboBox.addItem( element)
        #self.dlg.escalasComboBox.setCurrentIndex(4)
        #defino la capa con la cuadricula a cortar
        layer=iface.activeLayer()
        if layer is None:
            iface.messageBar().pushMessage("ATENCION", "Activa una capa de polígonos que utilizar como cuadrícula para cortar el mapa y selecciona los polígonos de la zona que quieras crear.", duration=10)
        #if vl2.wkbType()< 1 or vl2.wkbType() > 1:
            #iface.messageBar().pushMessage("ATENCION", "Selecciona una capa de puntos", duration=10)
        #else:
        if layer.type()== QgsMapLayer.VectorLayer: 
            if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                misdatos=[]
                misdatos = [f.name() for f in layer.fields()]
                
                #trato de rellenar el desplegable con las columnas
                #anado un elemneto en blanco en el desplegable
                self.dlg.cb1.clear()
                self.dlg.cb1.addItem( "")
                for element in misdatos:
                    self.dlg.cb1.addItem( element)
        else:
            iface.messageBar().pushMessage("ATENCION", "Activa una capa de polígonos que utilizar como cuadrícula para cortar el mapa y selecciona los polígonos de la zona que quieras crear.", duration=10)
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        
        

        
        # See if OK was pressed TODO: probably need something to happen when pressing "cancel" too.
        if result:
            column = self.dlg.cb1.currentIndex()
            columna=misdatos[int(column)-1] 
            #ruta donde guardar los archivos resultantes
            archivos_ruta=self.dlg.lineEdit_ruta.text()
            
            #defino la columna para etiquetar los resultados
            nombredelacolumna=str(columna)#"IGN50"
            #tempfile.mkdtemp()
            filePath = archivos_ruta+"/temporales"
            try:
                os.mkdir(filePath)
            except:
                print ("No se pudo crear el archivo" )
            #print(filePath)
            
            #layer=QgsVectorLayer("O:/sigmena/carto/HOJAS/E50/42_Hojas_e50_etrs89.shp", "hojas de corte", "ogr")
            #print("nombre de la capa")
            #print(layer.name())
            
            listadodeboundingbox=[]
            for feature in layer.selectedFeatures():
                geom=feature.geometry()
                #x=geom.boundingBox().center()[0]
                #y=geom.boundingBox().center()[1]
                caja=geom.boundingBox()
                hoja=feature.attribute(nombredelacolumna)
                
                listadodeboundingbox.append([caja,hoja])
                #attributes=feature.attributes()
                #print(attributes)
                #for attribute in attributes:
                    #print(attribute)
            
            #print("le he dado a ok")
            #print(listadodecentros)
            #print(listadodeboundingbox)
            #indescala=self.dlg.escalasComboBox.currentIndex()
            #escala=int(escalas[int(indescala)])
            #print(escala)
            
            # get the users input
            #recogo la zona a sacar
            
            #titel = "titulo"#self.dlg.titelFld.text()
            #subTitel = self.dlg.subTitelFld.text()

            
            
            project = QgsProject.instance()
            l = QgsPrintLayout(project)
            l.initializeDefaults()
            l.setUnits(QgsUnitTypes.LayoutMillimeters)
            page = l.pageCollection().pages()[0]


            
        
            # paperSize = 'A0'
            ladolargo = 1189
            ladocorto = 841
            #por defecto horizontal
            
            width = ladolargo
            height = ladocorto
           
           
            paperSize = [width, height]
            page.setPageSize(QgsLayoutSize(paperSize[0],paperSize[1]))
            
            # add gadgets
            # but first get margins and paper size right
            lm = 0#10         # left margin
            tm = 0#10         # upper margin
            bm = 0#40         # lower margin

            #no se para que hace esto que sigue
            refSize = paperSize[0]
            if paperSize[1] < refSize:
                refSize = paperSize[1]

            # add map
            x, y = lm, tm
            w, h = paperSize[0] -  2 * lm, paperSize[1] - bm
            #print("ya he definido el tamaño de papel")
            #print(paperSize[0] , paperSize[1])
            theMap = QgsLayoutItemMap(l)
            theMap.updateBoundingRect()
            theMap.setRect(QRectF(x, y, w, h))
            
            theMap.setPos(x,y)
            theMap.setFrameEnabled(True)
            #podria crear una funcion para cambiar la extension
            extendoriginal=self.iface.mapCanvas().extent()
            #print(extendoriginal)

            #meto los elementos que tengo que modificar despues, como la fecha, 
            """#add date
            d = time.localtime()
            dString = "%d-%d-%d (%d:%d)" % (d[2],  d[1],  d[0],d[3],d[4])
            dateLabel = QgsLayoutItemLabel(l)
            dateLabel.setText(dString)
            dateLabel.adjustSizeToText()
            dateStringWidth = dateLabel.sizeForText().width()
            dateLabel.setPos(paperSize[0] - lm - dateStringWidth -5, (paperSize[1] - bm) + tm + 5)
            print(paperSize[0] - lm - dateStringWidth -5, (paperSize[1] - bm) + tm + 5)
            l.addItem(dateLabel)"""
             # add scalebar

            """scaleBar = QgsLayoutItemScaleBar(l)
            scaleBar.setLinkedMap(theMap)
            scaleBar.applyDefaultSettings()
            scaleBar.applyDefaultSize()
            # scaleBar.setStyle('Line Ticks Down') 
            scaleBar.setNumberOfSegmentsLeft(0)
            scaleBar.setNumberOfSegments (3)
            scaleBar.update()
            scaleBar.setPos(lm + 10, tm + (paperSize[1] - bm) + tm + 5 )
            l.addItem(scaleBar)"""
            """escaleLabel= QgsLayoutItemLabel(l)
            escaleLabel.setText("Escala 1:" + str(escala))
            escaleLabel.adjustSizeToText()
            escaleStringWidth = escaleLabel.sizeForText().width()
            escaleLabel.setPos(paperSize[0] - lm - dateStringWidth -5, (paperSize[1] - bm) + tm + 10)#(paperSize[0] - lm - escaleStringWidth -5, (paperSize[1] - bm) + tm + 5)
            print((paperSize[0] - lm - escaleStringWidth -5, (paperSize[1] - bm) + tm + 10))
            l.addItem(escaleLabel)
            print(lm + 10, tm + (paperSize[1] - bm) + tm + 5 )"""


                  

                                


##            def moverextend(xx,yy):
##                global newextend
##                #print(extendoriginal)
##                newextend=extendoriginal+QgsVector(xx,yy)
##                #print(newextend)
##                return newextend
            
            #podria crear una funcion desde aqui para meter las capas que interesa que se impriman.
            
            
            def configuraplanoproyecto(newexten_hoja):
                print(newexten_hoja)
                newextend=newexten_hoja[0]
                hoja=newexten_hoja[1]
                print(hoja)
                #global newextend
                # project.mapLayers().values():
                """#BORRO LAS CAPAS QUE HAY EN EL PROYECTO
                capas =QgsProject.instance().mapLayers()
                for capa in capas:
                    QgsProject.instance().layerTreeRoot().findLayer(capa).setItemVisibilityChecked(False)"""
                theMap.setLayers(project.mapThemeCollection().masterVisibleLayers())   # remember ANNOTATION!
                theMap.setExtent(newextend.scaled(1.1))
                print("ojo scale 1.1")
                print(newextend)
                theMap.attemptSetSceneRect(QRectF(x, y, w, h))
                l.addItem(theMap)
                #pongo la escala
                #print(escala)
                #theMap.setScale(escala)
                #print("he incluido el mapa")
                # export bmp
                exporter =  QgsLayoutExporter(l)
                settings = exporter.ImageExportSettings()
                settings.dpi = 499#OJO PODRIA SER VARIABLE
                settings.generateWorldFile = True

                #path = 'C:\\Users\\Username\\Desktop\\test_layout_image.png'

                
                #pdf_settings = exporter.PdfExportSettings()
                #ruta="c:/work/borrarpdfincendios.pdf"
                #filePath = tempfile.mkdtemp()
                #print(filePath)
                
                path=filePath+"/"+self.dlg.lineEdit_nombre.text().replace(' ','_')+str(hoja)+".bmp"
                exporter.exportToImage(path, settings)
                

            def orux(elemento):
                print(elemento)
                hoja=elemento[1]
                print(hoja)
                rasterLyr=QgsRasterLayer(filePath+"/"+self.dlg.lineEdit_nombre.text().replace(' ','_')+str(hoja)+".bmp",self.dlg.lineEdit_nombre.text().replace(' ','_')+str(hoja))
                #print(rasterLyr)
                #iface.addRasterLayer(data_source,layer_name)
                rectagle_extent = rasterLyr.dataProvider().extent()
                #print(rectagle_extent)
                fichero = open(filePath+"/calibracion"+str(elemento[1])+".txt", 'w')
                fichero.write(filePath+"/"+self.dlg.lineEdit_nombre.text().replace(' ','_')+str(hoja)+".bmp\n")
                fichero.write("0\n")
                fichero.write("0\n")
                fichero.write(str(int(round(rectagle_extent.xMinimum(),0)))+str("\n"))
                fichero.write(str(int(round(rectagle_extent.yMaximum(),0)))+str("\n"))
                fichero.write(str(int(round(rasterLyr.width())))+str("\n"))
                fichero.write(str(int(round(rasterLyr.height())))+str("\n"))
                #fichero.write(str(int(round(1189*499/25.4003,0)))+str("\n"))#OJO PODRIA SER VARIABLE
                #fichero.write(str(int(round(841*499/25.4003,0)))+str("\n"))#OJO PODRIA SER VARIABLE
                fichero.write(str(int(round(rectagle_extent.xMaximum(),0)))+str("\n"))
                fichero.write(str(int(round(rectagle_extent.yMinimum(),0)))+str("\n"))
                
                
                fichero.close()

            def oruxdesktop(elemento):
                print(elemento)
                time.sleep(2)
                #abro oruxmapsdesktop    
                #os.chdir("C:/WORK/Aplicaciones/OruxMapsDesktop")
                os.chdir(os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\oruxmapssigmena\OruxMapsDesktop"))
                os.startfile("OruxMapsDesktop.jar")

                #empiezo a rellenar datos
                #funcion para mover el raton e intentar rellenar los datos en la apliocacion oruxmaps desktop

                def clic(x,y):
                    #para hacer clic
                    win32api.SetCursorPos((x,y))
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0)
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)

                #funciones para escribir texto
                VK_CODE = {'backspace':0x08,
               'tab':0x09,
               'clear':0x0C,
               'enter':0x0D,
               'shift':0x10,
               'ctrl':0x11,
               'alt':0x12,
               'pause':0x13,
               'caps_lock':0x14,
               'esc':0x1B,
               'spacebar':0x20,
               'page_up':0x21,
               'page_down':0x22,
               'end':0x23,
               'home':0x24,
               'left_arrow':0x25,
               'up_arrow':0x26,
               'right_arrow':0x27,
               'down_arrow':0x28,
               'select':0x29,
               'print':0x2A,
               'execute':0x2B,
               'print_screen':0x2C,
               'ins':0x2D,
               'del':0x2E,
               'help':0x2F,
               '0':0x30,
               '1':0x31,
               '2':0x32,
               '3':0x33,
               '4':0x34,
               '5':0x35,
               '6':0x36,
               '7':0x37,
               '8':0x38,
               '9':0x39,
               'a':0x41,
               'b':0x42,
               'c':0x43,
               'd':0x44,
               'e':0x45,
               'f':0x46,
               'g':0x47,
               'h':0x48,
               'i':0x49,
               'j':0x4A,
               'k':0x4B,
               'l':0x4C,
               'm':0x4D,
               'n':0x4E,
               'o':0x4F,
               'p':0x50,
               'q':0x51,
               'r':0x52,
               's':0x53,
               't':0x54,
               'u':0x55,
               'v':0x56,
               'w':0x57,
               'x':0x58,
               'y':0x59,
               'z':0x5A,
               'numpad_0':0x60,
               'numpad_1':0x61,
               'numpad_2':0x62,
               'numpad_3':0x63,
               'numpad_4':0x64,
               'numpad_5':0x65,
               'numpad_6':0x66,
               'numpad_7':0x67,
               'numpad_8':0x68,
               'numpad_9':0x69,
               'multiply_key':0x6A,
               'add_key':0x6B,
               'separator_key':0x6C,
               'subtract_key':0x6D,
               'decimal_key':0x6E,
               'divide_key':0x6F,
               'F1':0x70,
               'F2':0x71,
               'F3':0x72,
               'F4':0x73,
               'F5':0x74,
               'F6':0x75,
               'F7':0x76,
               'F8':0x77,
               'F9':0x78,
               'F10':0x79,
               'F11':0x7A,
               'F12':0x7B,
               'F13':0x7C,
               'F14':0x7D,
               'F15':0x7E,
               'F16':0x7F,
               'F17':0x80,
               'F18':0x81,
               'F19':0x82,
               'F20':0x83,
               'F21':0x84,
               'F22':0x85,
               'F23':0x86,
               'F24':0x87,
               'num_lock':0x90,
               'scroll_lock':0x91,
               'left_shift':0xA0,
               'right_shift ':0xA1,
               'left_control':0xA2,
               'right_control':0xA3,
               'left_menu':0xA4,
               'right_menu':0xA5,
               'browser_back':0xA6,
               'browser_forward':0xA7,
               'browser_refresh':0xA8,
               'browser_stop':0xA9,
               'browser_search':0xAA,
               'browser_favorites':0xAB,
               'browser_start_and_home':0xAC,
               'volume_mute':0xAD,
               'volume_Down':0xAE,
               'volume_up':0xAF,
               'next_track':0xB0,
               'previous_track':0xB1,
               'stop_media':0xB2,
               'play/pause_media':0xB3,
               'start_mail':0xB4,
               'select_media':0xB5,
               'start_application_1':0xB6,
               'start_application_2':0xB7,
               'attn_key':0xF6,
               'crsel_key':0xF7,
               'exsel_key':0xF8,
               'play_key':0xFA,
               'zoom_key':0xFB,
               'clear_key':0xFE,
               '+':0xBB,
               ',':0xBC,
               '-':0xBD,
               '.':0xBE,
               #'/':0xBF,
               '`':0xC0,
               ';':0xBA,
               '[':0xDB,
               '\\':0xDC,
               ']':0xDD,
               "'":0xDE,
               '`':0xC0}



                def press(*args):
                    '''
                    one press, one release.
                    accepts as many arguments as you want. e.g. press('left_arrow', 'a','b').
                    '''
                    for i in args:
                        win32api.keybd_event(VK_CODE[i], 0,0,0)
                        time.sleep(.05)
                        win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)

                def pressAndHold(*args):
                    '''
                    press and hold. Do NOT release.
                    accepts as many arguments as you want.
                    e.g. pressAndHold('left_arrow', 'a','b').
                    '''
                    for i in args:
                        win32api.keybd_event(VK_CODE[i], 0,0,0)
                        time.sleep(.05)
                           
                def pressHoldRelease(*args):
                    '''
                    press and hold passed in strings. Once held, release
                    accepts as many arguments as you want.
                    e.g. pressAndHold('left_arrow', 'a','b').

                    this is useful for issuing shortcut command or shift commands.
                    e.g. pressHoldRelease('ctrl', 'alt', 'del'), pressHoldRelease('shift','a')
                    '''
                    for i in args:
                        win32api.keybd_event(VK_CODE[i], 0,0,0)
                        time.sleep(.05)
                            
                    for i in args:
                            win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            time.sleep(.1)
                            
                        

                def release(*args):
                    '''
                    release depressed keys
                    accepts as many arguments as you want.
                    e.g. release('left_arrow', 'a','b').
                    '''
                    for i in args:
                           win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)


                def typer(string=None,*args):
                ##    time.sleep(4)
                    for i in string:
                        if i == ' ':
                            win32api.keybd_event(VK_CODE['spacebar'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['spacebar'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '!':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['1'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['1'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '@':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['2'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['2'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '{':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['['], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['['],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '?':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['/'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['/'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == ':':#ojo javi sustituyo ; con .
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['.'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['.'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '"':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['\''], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['\''],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '}':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE[']'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE[']'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '#':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['3'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['3'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '$':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['4'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['4'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '%':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['5'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['5'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '^':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['6'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['6'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '&':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['7'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['7'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '/':#ojo javi lo he creado yo.
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['7'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['7'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '*':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['8'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['8'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '(':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['9'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['9'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == ')':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['0'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['0'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '_':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['-'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['-'],0 ,win32con.KEYEVENTF_KEYUP ,0)


                        elif i == '=':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['+'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['+'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '~':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['`'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['`'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '<':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE[','], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE[','],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == '>':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['.'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['.'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'A':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['a'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['a'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'B':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['b'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['b'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'C':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['c'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['c'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'D':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['d'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['d'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'E':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['e'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['e'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'F':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['f'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['f'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'G':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['g'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['g'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'H':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['h'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['h'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'I':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['i'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['i'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'J':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['j'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['j'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'K':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['k'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['k'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'L':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['l'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['l'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'M':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['m'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['m'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'N':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['n'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['n'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'O':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['o'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['o'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'P':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['p'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['p'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'Q':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['q'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['q'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'R':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['r'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['r'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'S':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['s'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['s'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'T':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['t'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['t'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'U':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['u'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['u'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'V':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['v'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['v'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'W':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['w'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['w'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'X':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['x'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['x'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'Y':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['y'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['y'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        elif i == 'Z':
                            win32api.keybd_event(VK_CODE['left_shift'], 0,0,0)
                            win32api.keybd_event(VK_CODE['z'], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE['left_shift'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                            win32api.keybd_event(VK_CODE['z'],0 ,win32con.KEYEVENTF_KEYUP ,0)

                        
                                                    
                    
                        else:    
                            win32api.keybd_event(VK_CODE[i], 0,0,0)
                            time.sleep(.05)
                            win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)


                
                time.sleep(2)
                #abro archivo de georeferenciacion
                f = open (filePath+"/calibracion"+str(elemento[1])+".txt",'r')
                mensaje = f.readlines()
                


                
                #calculo el centro de la pantalla
                centropantalla_x=int(GetSystemMetrics(0)/2)
                centropantalla_y=int(GetSystemMetrics(1)/2)
                
                #ruta bmp
                clic(centropantalla_x-150,centropantalla_y-240)
                
                #print(mensaje[0][:-1])
                nuevomensaje=mensaje[0][:-1].replace('\\','/')
                #print(nuevomensaje)
                typer(nuevomensaje)
                time.sleep(1)

                #datum
                #clic(650,390)
                clic(centropantalla_x-150,centropantalla_y-210)
                time.sleep(1)
                typer("e")
                time.sleep(1)
                typer("e")
                time.sleep(1)
                typer("e")
                time.sleep(1)
                typer("e")
                time.sleep(1)
                win32api.keybd_event(VK_CODE['enter'], 0,0,0)
                time.sleep(.05)
                win32api.keybd_event(VK_CODE['enter'],0 ,win32con.KEYEVENTF_KEYUP ,0)
                time.sleep(1)

                #proyeccion
                #clic(950,390)
                clic(centropantalla_x+150,centropantalla_y-210)
                time.sleep(1)
                typer("u")
                time.sleep(1)
                typer("30")
                time.sleep(1)
                #clic(800,610)
                clic(centropantalla_x,centropantalla_y+12)
                time.sleep(1)
                
                #p1 x
                #clic(370,450)
                clic(centropantalla_x-430,centropantalla_y-150)
                typer(mensaje[1][:-1])
                time.sleep(1)
                #p1 y
                #clic(650,450)
                clic(centropantalla_x-150,centropantalla_y-150)
                typer(mensaje[2][:-1])
                time.sleep(1)
                #p1 lon
                #clic(950,450)
                clic(centropantalla_x+150,centropantalla_y-150)
                typer(mensaje[3][:-1])
                time.sleep(1)
                #p1 lat
                #clic(1150,450)
                clic(centropantalla_x+350,centropantalla_y-150)
                typer(mensaje[4][:-1])
                time.sleep(1)
                
                #p2 x
                #clic(370,480)
                clic(centropantalla_x-430,centropantalla_y-120)
                typer(mensaje[5][:-1])
                time.sleep(1)
                #p2 y
                #clic(650,480)
                clic(centropantalla_x-150,centropantalla_y-120)
                typer(mensaje[6][:-1])
                time.sleep(1)
                #p2 lon
                #clic(950,480)
                clic(centropantalla_x+150,centropantalla_y-120)
                typer(mensaje[7][:-1])
                time.sleep(1)
                #p2 lat
                #clic(1150,480)
                clic(centropantalla_x+350,centropantalla_y-120)
                typer(mensaje[8][:-1])
                time.sleep(1)

                #cuadricula
                #clic(1050,590)
                clic(centropantalla_x+250,centropantalla_y-10)
                time.sleep(1)

                #nombremapa
                #clic(1050,630)
                clic(centropantalla_x+250,centropantalla_y+35)
                #print(mensaje[0].split("/")[-1][:-5])
                typer(mensaje[0].split("/")[-1][:-5])#(mensaje[0][-18:-5])
                time.sleep(1)

                #rutamapa
                #clic(1050,660)
                clic(centropantalla_x+250,centropantalla_y+60)
                nuevomensaje=archivos_ruta#("D:/pruebas/IGN_JAVI")
                #print(nuevomensaje)
                typer(nuevomensaje)
                time.sleep(1)
                
                
                
                #jpg100
                #clic(770,690)
                clic(centropantalla_x-30,centropantalla_y+90)
                time.sleep(1)
                #clic(810,710)
                clic(centropantalla_x+10,centropantalla_y+110)
                time.sleep(1)
                #clic(810,710)
                clic(centropantalla_x+10,centropantalla_y+110)
                time.sleep(1)
                #clic(810,710)
                clic(centropantalla_x+10,centropantalla_y+110)
                time.sleep(1)
                #clic(770,715)
                clic(centropantalla_x-30,centropantalla_y+115)
                time.sleep(1)

                #prueba multicapa 
                #clic(320,750)
                clic(centropantalla_x-480,centropantalla_y+150)
                time.sleep(1)
                #clic(420,750)#50
                clic(centropantalla_x-380,centropantalla_y+150)
                time.sleep(1)
                #clic(470,750)#25
                clic(centropantalla_x-330,centropantalla_y+150)
                time.sleep(1)
                #clic(520,750)#12.5
                clic(centropantalla_x-280,centropantalla_y+150)
                time.sleep(1)
                #clic(570,750)#6.25
                clic(centropantalla_x-230,centropantalla_y+150)
                time.sleep(1)

                #run
                #clic(1050,710)
                clic(centropantalla_x+250,centropantalla_y+110)
                time.sleep(1)
                
                

                f.close()

                time.sleep(120)
                #cierra ventana
                #clic(800,620)
                clic(centropantalla_x,centropantalla_y+20)
                time.sleep(1)
                #cierra programa
                #clic(1290,260)
                clic(centropantalla_x+490,centropantalla_y-340)
                time.sleep(1)
                


            
           
            
            
          

            #print("aqui estoy")
            
            for elemento in listadodeboundingbox:
                print(elemento)
                print("empiezo con el bmp")
                configuraplanoproyecto(elemento)
                time.sleep(10)
                print("empiezo con el orux")
                orux(elemento)
                time.sleep(10)
                print("empiezo con el oruxdesktop")
                oruxdesktop(elemento)
            iface.messageBar().pushMessage("ATENCION", "Ha finalizado la ejecución del complemento Oruxmaps Sigmena")
            os.startfile(archivos_ruta)
        
                
            

            
            
            
                                 
                



   
