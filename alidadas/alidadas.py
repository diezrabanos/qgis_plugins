# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Alidadas
                                 A QGIS plugin
 esto es lo que hace Alidadas
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-29
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Javier Diez Rabanos
        email                : dierabfr@jcyl.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
#from PyQt5.QtGui import QIcon
#from PyQt5.QtWidgets import QAction

from qgis.PyQt.QtCore import QSettings, QTranslator, qVersion, QCoreApplication#,QFileInfo
from qgis.PyQt.QtGui import QIcon, QColor,QFont
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QInputDialog
from PyQt5.QtWidgets import QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .alidadas_dialog import AlidadasDialog
from .config_dialog import ConfigDialog
import os.path

#import para procesar
import qgis.core as qgisCore
from qgis.core import QgsProject, QgsVectorLayer,QgsField,QgsExpression,QgsExpressionContext,QgsExpressionContextScope,QgsVectorFileWriter, QgsMarkerSymbol,QgsRendererCategory,QgsCategorizedSymbolRenderer,QgsPointXY, QgsPoint,QgsFeature,QgsGeometry,QgsLineSymbol,QgsExpressionContextUtils,QgsPalLayerSettings,QgsTextFormat,QgsVectorLayerSimpleLabeling,QgsExpressionContextUtils,QgsApplication
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
#from PyQt5.QtWidgets import QMessageBox
#from PyQt5.QtCore import QFileInfo
#from qgis.PyQt.QtCore import QFileInfo

import processing
import os
import glob
import re
import sys
#from qgis import *

import math
import time

import webbrowser

class Config:
    def __init__(self, iface):
        self.dlg2 = ConfigDialog()

class Alidadas:
    """QGIS Plugin Implementation."""
    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Alidadas_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        self.dlg = AlidadasDialog()
        self.dlg2 = ConfigDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sigmena')
        
        #self.toolbar = self.iface.addToolBar(u'Sigmena')             #creo que no hace nada
        #self.toolbar.setObjectName(u'Sigmena')            #creo que no hace nada
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        #abre la nueva ventana de configuracion
        self.dlg.pushButton_configurar.clicked.connect(self.configurar)
        self.dlg2.pushButton_select_path1.clicked.connect(self.select_file1)
        self.dlg.help_button.clicked.connect(self.help_pressed) 

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Alidadas', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """


        
        #cambio el icon path para mi equipo.
        usuario=QgsApplication.qgisSettingsDirPath()
        icon_path=os.path.join(usuario,r"python\plugins\alidadas\icon.png")
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)
            #self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/alidadas/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Alidadas'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        
        #cojo los parametros necesarios del archivo de configuracion
        global rutapuestosvigiancia
        rutaarchivoconfiguracion=os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\alidadas\configuracion.txt")
        if os.path.isfile(rutaarchivoconfiguracion) ==True:
            fileconfig = open(rutaarchivoconfiguracion, "r")
            fileconfigleido=fileconfig.readlines()
            try:
                rutapuestosvigiancia= (fileconfigleido[0].replace('\n',''))
                fileconfig.close()
            except:
                rutapuestosvigiancia=""
                
        if os.path.isfile(rutaarchivoconfiguracion) ==False:
            fileconfig = open(rutaarchivoconfiguracion, "w")
            fileconfig.close()
            rutapuestosvigiancia=""
            
    def select_file1(self):

        """seleciono la capa con los datos de entrada terminos municipales del sigpac"""
        global rutapuestosvigiancia
        rutaarchivoconfiguracion=os.path.join(QgsApplication.qgisSettingsDirPath(),r"python\plugins\alidadas\configuracion.txt")
        rutapuestosvigiancia = QFileDialog.getOpenFileName(self.dlg2 , "Capa con los puestos de vigilancia",None ,'SHP(*.shp)')
        self.dlg2.ruta1.setText(rutapuestosvigiancia[0])
        archivo=rutapuestosvigiancia[0]
        #inserto en linea 0 el contenido
        if len(rutapuestosvigiancia[0])>0:
            contenido=open(rutaarchivoconfiguracion).read().splitlines()
            contenido.insert(0,rutapuestosvigiancia[0])
            fileconfig = open(rutaarchivoconfiguracion, "w")

        
            fileconfig.writelines("\n".join(contenido))
            fileconfig.close()
            iface.messageBar().pushMessage("CERRAR Y ABRIR QGIS PARA QUE SE APLIQUEN LOS CAMBIOS", qgisCore.Qgis.Warning,5)
    
    def configurar(self):
        contras = QInputDialog.getText(None, 'CONTRASEÑA', 'Introduce la contraseña')
        print (contras)
        if contras[0]=='SIGMENITA':
            self.dlg2.show()
        else:
            iface.messageBar().pushMessage("PARA CONFIGURAR INRODUCIR CONTRASEÑA", qgisCore.Qgis.Warning,5)    

    def help_pressed(self):
        help_file = 'file:' + os.path.dirname(__file__) + '/Ayuda_Alidadas.pdf'
        webbrowser.open_new(help_file)  


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Sigmena'),
                action)
            self.iface.removeToolBarIcon(action)


    


    def run(self):
        print ("paso por el run")
       
        #coloco el puntero arriba del todo
        QgsProject.instance().layerTreeRegistryBridge().setLayerInsertionPoint( QgsProject.instance().layerTreeRoot(), 0 )
        
        def haceelcruce(x1,y1,ang1,x2,y2,ang2):
            #saco las pendientes
            m1=(1/math.tan(math.radians(ang1+0.000001)))
            m2=(1/math.tan(math.radians(ang2+0.000001)))
            #print ("m1")
            #print (m1)
            #print("m2")
            #print (m2)

            #saco las coordenadas de x e y
            x = ((y2 - y1) + (m1*x1) - (m2*x2))/((m1 - m2)+0.000001)
            y = m1*x + y1 - m1*x1

           
            #compruebo que el cruce no es erroneo
            if ang1>0 and ang1<180 and x<x1 :
                iface.messageBar().pushMessage("OJO: LAS VISUALES NO SE CRUZAN", qgisCore.Qgis.Info,5)
                x,y,error=0,0,0
            if ang1>180 and ang1<360 and x>x1 :
                iface.messageBar().pushMessage("OJO: LAS VISUALES NO SE CRUZAN", qgisCore.Qgis.Info,5)
                x,y,error=0,0,0
            if ang1>0 and ang1<90 and y<y1 :
                iface.messageBar().pushMessage("OJO: LAS VISUALES NO SE CRUZAN", qgisCore.Qgis.Info,5)
                x,y,error=0,0,0
            if ang1>270 and ang1<360 and y<y1 :
                iface.messageBar().pushMessage("OJO: LAS VISUALES NO SE CRUZAN", qgisCore.Qgis.Info,5)
                x,y,error=0,0,0
            if ang1>90 and ang1<270 and y>y1 :
                iface.messageBar().pushMessage("OJO: LAS VISUALES NO SE CRUZAN", qgisCore.Qgis.Info,5)
                x,y,error=0,0,9999999999999999999999999
            else:

                #calculo el error
                d1a=math.sqrt((x-x1)**2+(y-y1)**2)
                d2a=math.sqrt((x-x2)**2+(y-y2)**2)
                d12=math.sqrt((x2-x1)**2+(y2-y1)**2)
                A=math.acos((d1a**2+d2a**2-d12**2)/(2*d1a*d2a))
                if math.degrees(A)>90:
                    A=math.pi-A
                distancias=[d1a,d2a]
                distancias.sort(reverse=True) 
                mayordistancia=distancias[0]
                
                error=mayordistancia*erroralidada/(math.sin(A/2)+0.000001)
                #print (ang1,ang2)
                #print (x,y,error)
            return x,y,error

        def generapunto(x,y):
            #creo una capa de puntos temporal con los resultados
            # create layer
            vl = QgsVectorLayer("Point", "Pto_Cruce", "memory")
            pr = vl.dataProvider()
            #print ("ok creada la capa")
            vl.startEditing()
            # add fields
            pr.addAttributes([QgsField("error", QVariant.Int),
                            QgsField("x",  QVariant.Int),
                            QgsField("y", QVariant.Double)])
            vl.updateFields() 
            # tell the vector layer to fetch changes from the provider
            #print ("ok creados los campos")
            # add a feature
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x,y)))

            fet.setAttributes([error, x, y])
            pr.addFeatures([fet])
            #print ("ok, anadido el elemento con error "+str(error))
            #cambio la simbologia
            symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'orange','size': '5',})
            vl.renderer().setSymbol(symbol)

            # update layer's extent when new features have been added
            # because change of extent in provider is not propagated to the layer
            #vl.updateExtents()
            vl.commitChanges()
            #vl.updateExtents()
            # show the point
            if x!=0 and y!=0:
                QgsProject.instance().addMapLayers([vl])
                canvas = self.iface.mapCanvas()
            #canvas.setExtent(vl.extent())
            #vl.updateFieldMap()
    


        def generalinea(x,y,angulo):
            m=(1/math.tan(math.radians(angulo+0.000001)))
            x1=x+100000*math.sin(math.radians(angulo+0.0000001))
            y1=y -m*(x-x1)
            
            line_start = QgsPoint(x,y)
            line_end = QgsPoint(x1,y1)
            #print (m)

            # create a new memory layer
            v_layer = QgsVectorLayer("LineString", "visual", "memory")
            pr = v_layer.dataProvider()
            # create a new feature
            seg = QgsFeature()
            # add the geometry to the feature, 
            seg.setGeometry(QgsGeometry.fromPolyline([line_start, line_end]))
            # add the geometry to the layer
            pr.addFeatures( [ seg ] )
            # update extent of the layer (not necessary)
            v_layer.updateExtents()
            #cambio la simbologia
            symbol3 = QgsLineSymbol.createSimple({'penstyle':'solid', 'color':'yellow', 'width':'2'})
            v_layer.renderer().setSymbol(symbol3)
            # show the line  
            QgsProject.instance().addMapLayers([v_layer])




        
        erroralidada=1
        #selecciono la capa de las torretas
        global rutapuestosvigiancia
        layer = QgsVectorLayer(rutapuestosvigiancia, '42_Puestos_vigilancia_etrs89', 'ogr')
        time.sleep(1)
        #layer = iface.activeLayer()
        ## ojo comprobar que layer existe
        """if layer is None or (layer.type() == RasterLayer):
            iface.messageBar().pushMessage("Warning:",  u"Seleciona la capa de los puestos de vigilancia",  QgsMessageBar.WARNING, 10) """
        #genero una lista con las torres y ls coordenadas
        misdatos=[]
        feats = [ feat for feat in layer.getFeatures() ]
        for feature in feats:
            if feature.geometry().type() != 0: #0 es ptos, 1 lineas y 2 poligonos QGis.Point:
                iface.messageBar().pushMessage("Warning:", u"Debe selecionar una capa de puntos", QgsMessageBar.WARNING, 10)
            point=[]

            idTM =layer.dataProvider().fieldNameIndex('Nombre')
            idx = layer.dataProvider().fieldNameIndex('x')
            idy=  layer.dataProvider().fieldNameIndex('y')
            
            point=[feature.attributes()[idTM],feature.attributes()[idx], feature.attributes()[idy]]
            misdatos.append(point)
        #trato de rellenar el desplegable con las torretas
        #self.dlg.cb1.clear()
       
        #ordeno por el primer elemento
        misdatos.sort(key=lambda x: x[0])
        #anado un elemneto enblanco en el desplegable
        self.dlg.cb1.addItem( "")
        self.dlg.cb2.addItem("" )
        self.dlg.cb3.addItem( "")
        self.dlg.cb4.addItem( "") 
        for element in misdatos:
            self.dlg.cb1.addItem( element[0])
            self.dlg.cb2.addItem( element[0])
            self.dlg.cb3.addItem( element[0])
            self.dlg.cb4.addItem( element[0]) 
        #count vertices if there is layer in project in order to show it when dialog is loaded
        #layer = self.dlg.cb1.itemData(self.cb1.currentIndex())

        
    




        
        

        




        
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            #self.dlg = SilvilidarDialog()
            #la siguiente linea inicia el boton de cargar carpetas, peta al cerrar el qgis, deberia poner algun close o algo
            #self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)
            #print("inicio el boton en el gui")
            #self.dlg.pushButton_select_path.setEnabled(True)
            #print ("pone le boton como habiltado")
            

        # show the dialog
        self.dlg.show()
        
        #self.dlg.pushButton_select_path.clicked.connect(self.select_laz_folder)

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:

            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #print ("lo imprime si le doy a aceptar en el dialogo")
            
            #la carpeta la he cogido al pulsar el boton de la carpeta

             #meto aqui variables que luego deberan estar en la cajita   OJO
            torret1=self.dlg.cb1.currentIndex()
            torret2=self.dlg.cb2.currentIndex()
            torret3=self.dlg.cb3.currentIndex()
            torret4=self.dlg.cb4.currentIndex()
            angulo1= self.dlg.ang1.text()##displayText()
            angulo2=self.dlg.ang2.text()##displayText()
            angulo3=self.dlg.ang3.text()##displayText()
            angulo4=self.dlg.ang4.text()##displayText()
            if angulo2=="":
                angulo2=9999
            if angulo3=="":
                angulo3=9999
            if angulo4=="":
                angulo4=9999
            try:
                ang1=float(angulo1)
                ang2=float(angulo2)
                ang3=float(angulo3)
                ang4=float(angulo4)
            except:
                pass
            #print (misdatos)
            
            torre1=misdatos[int(torret1)-1][0]
            x1=float(misdatos[int(torret1)-1][1])
            y1=float(misdatos[int(torret1)-1][2])
            torre2=misdatos[int(torret2)-1][0]
            x2=float(misdatos[int(torret2)-1][1])
            y2=float(misdatos[int(torret2)-1][2])
            torre3=misdatos[int(torret3)-1][0]
            x3=float(misdatos[int(torret3)-1][1])
            y3=float(misdatos[int(torret3)-1][2])
            torre4=misdatos[int(torret4)-1][0]
            x4=float(misdatos[int(torret4)-1][1])
            y4=float(misdatos[int(torret4)-1][2])

           
            #print (angulo1, angulo2, angulo3, angulo4)
            #print (torret1)
            #print (torre1, x1, y1)
            #print (torret2)
            #print (torre2, x2, y2)
            #print (torret3)
            #print (torret4)

                
            generalinea(x1,y1,ang1)
            resultado=[]
            if angulo2 != 9999:
                generalinea(x2,y2,ang2) 
                x,y,error=haceelcruce(x1,y1,ang1,x2,y2,ang2)
                #print ("hecho el cruce")
                #print  (x,y, error)
                
                generapunto(x,y)
                resultado=[]
                resultado.append(x)
                resultado.append(y)
                resultado.append(error)
            if angulo3 != 9999: 
                generalinea(x3,y3,ang3) 
                x,y,error=haceelcruce(x1,y1,ang1,x3,y3,ang3)
               
                generapunto(x,y)
                if error<resultado[2]:
                    resultado=[]
                    resultado.append(x)
                    resultado.append(y)
                    resultado.append(error)
                x,y,error=haceelcruce(x2,y2,ang2,x3,y3,ang3)
                
                generapunto(x,y)
                if error<resultado[2]:
                    resultado=[]
                    resultado.append(x)
                    resultado.append(y)
                    resultado.append(error)
            if angulo4 != 9999:
                generalinea(x4,y4,ang4) 
                #print ("empiezo el angulo4")
                x,y,error=haceelcruce(x1,y1,ang1,x4,y4,ang4)
                
                generapunto(x,y)
                if error<resultado[2]:
                    resultado=[]
                    resultado.append(x)
                    resultado.append(y)
                    resultado.append(error)
                x,y,error=haceelcruce(x2,y2,ang2,x4,y4,ang4)
               
                generapunto(x,y)

                if error<resultado[2]:
                    resultado=[]
                    resultado.append(x)
                    resultado.append(y)
                    resultado.append(error)
                x,y,error=haceelcruce(x3,y3,ang3,x4,y4,ang4)
                
                generapunto(x,y)

                if error<resultado[2]:
                    resultado=[]
                    resultado.append(x)
                    resultado.append(y)
                    resultado.append(error)  

            
            #hago una nueva capa con el mejor resultado
            if resultado !=[]:
                x,y,error=resultado[0],resultado[1],resultado[2]
                
                if x!=0 and y!=0:
                    #creo una capa temporal con los resultados
                    # create layer
                    vl2 = QgsVectorLayer("Point", "MejorResultado", "memory")
                    pr2 = vl2.dataProvider()
                    #print ("ok creada la capa resultado final")
                    vl2.startEditing()
                    # add fields
                    pr2.addAttributes([QgsField("error", QVariant.Int),
                                    QgsField("x",  QVariant.Int),
                                    QgsField("y", QVariant.Double)])
                    vl2.updateFields() 
                    # tell the vector layer to fetch changes from the provider
                    #print ("ok creados los campos")
                    #$add a feature
                    fet = QgsFeature()
                    fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x,y)))
                    fet.setAttributes([error, x, y])
                    pr2.addFeatures([fet])
                    print("MEJOR RESULTADO")
                    print(int(resultado[0]),int(resultado[1]))
                    #print ("ok, creda la capa con el resultado final")
                    #cambio la simbologia
                    symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'red','size': '10',})
                    vl2.renderer().setSymbol(symbol)

                    #etiqueto con la x e y
                    
                    layer_settings  = QgsPalLayerSettings()
                    text_format = QgsTextFormat()

                    text_format.setFont(QFont("Arial", 12))
                    text_format.setSize(12)
                    text_format.setColor(QColor("Orange"))

                    #buffer_settings = QgsTextBufferSettings()
                    #buffer_settings.setEnabled(True)
                    #buffer_settings.setSize(0.10)
                    #buffer_settings.setColor(QColor("Orange"))

                    #text_format.setBuffer(buffer_settings)
                    layer_settings.setFormat(text_format)
                    #myexp=QgsExpression('''concat('X: ',"X",' Y: ',"Y")''')
                    layer_settings.fieldName = '''concat('X: ',round("X",0),' Y: ',round("Y"),0)'''
                    layer_settings.isExpression = True
                    #layer_settings.placement = 7
                    #layer_settings.quadOffset = QgsPalLayerSettings.QuadrantBelow
                    #layer_settings.yOffset = 1

                    layer_settings.enabled = True

                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    vl2.setLabelsEnabled(True)
                    vl2.setLabeling(layer_settings)
                    vl2.triggerRepaint()


                    
                    # update layer's extent when new features have been added
                    # because change of extent in provider is not propagated to the layer
                    vl2.updateExtents()
                    vl2.commitChanges()
                    vl2.updateExtents()
                    canvas = self.iface.mapCanvas()
                    canvas.setExtent(vl2.extent())
                    self.iface.mapCanvas().zoomScale(100000)


                    #QgsProject.instance().addMapLayer(vl)
                    QgsProject.instance().addMapLayer(vl2)
            
            pass
